<html>
<head>
  <title>wireshark/tcpdump</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="696"/>
<h1>wireshark/tcpdump</h1>

<div>
<span><div><div>Wireshark中的关键字：</div><ol><li><div>Seq和Ack是随机生成的，wireshark将Seq和Ack的初始值都设为0，即用“相对值”代替“真实值”方便查看。使用Edit——Preferences——Protocols——TCP选项中的Relative Sequence Numbers来选择启用</div></li><li><div>在TCP中，同一台主机发出的包应该是连续的，即后一个包的seq等于前一个包的Seq+Len</div></li><li><div>Ack可以理解为应答。A发给B的Ack是告诉B，我已收到你发的数据包，收到Ack号这里了，你下次要发Seq为Ack号的给我——B的Ack为A的Seq+Len</div></li><li><div>Len：数据段的长度，不包含TCP头</div></li></ol><div><br/></div><div>WireShark中的标记：</div><ol><li><div>TCP Out-of-Order：TCP传输过程中同一台主机发出的包是连续的，即后一个包的Seq等于前一个包的Seq+Len。当Wireshark发现后一个包的Seq小于前一个包的Seq+Len时就认为是乱序了，会提示TCP Out-of-Order。小跨度的乱序影响不大，但跨度大的乱序可能触发快速重传</div></li><li><div>TCP Dup ACK：当乱序或丢包时，接收方会收到一些Seq号比期望值大的包，每次收到这个包就会Ack一次期望的Seq，以此提醒发送方，于是就产生了一些重复的Ack，Wireshark就会在这些重复的Ack上标记TCP Dup ACK</div></li><li><div>TCP Fast Retransmission：当发送方收到三个或以上的TCP Dup ACK，就意识到之前发送的包可能丢了，于是快速重传(RFC规定)</div></li><li><div>TCP Retransmission：如果一个包真丢了，又没有后续包可以在接收方触发Dup ACK，就不会快速重传，之中情况下只能等待超时重传，这类包被标记为TCP Retransmission</div></li><li><div>TCP zerowindow：当Win等于0时就会被标记</div></li><li><div>TCP window Full</div></li><li><div>TCP segment of a reassembled PDU——不知道是干啥的</div></li><li><div>Continuation to #</div></li><li><div>Time-to-live exceeded</div></li><li><div>TCP Previous segment not captured</div></li></ol><div>Wireshark搜索/过滤关键字</div><ul><li><div>常用的关键字，“eq” 和 “==”等同，“and” 表示并且，“or”表示或者。“!&quot; 和 &quot;not” 都表示取反。</div></li><li><div>搜索字符串xxx：tcp contains &quot;xxx&quot;</div></li><li><div>按协议过滤，如：tcp，http等，直接输入，或tcp||http</div></li><li><div>按ip过滤：</div></li><ul><li><div>按源IP过滤：ip.src==172.0.0.1 或ip.src eq 172.0.0.1</div></li><li><div>按目的IP过滤：ip.dst==172.0.0.1或ip.dst eq 172.0.0.1</div></li><li><div>直接按ip过滤：ip.addr == 172.0.0.1或ip.addr eq 172.0.0.1筛选出所有和这个ip相关的包</div></li></ul><li><div>根据端口过滤</div></li><ul><li><div>tcp.port==965</div></li><li><div>只显示目标端口：tcp.dstport==5150</div></li><li><div>只显示来源端口：tcp.srcport == 80</div></li><li><div>过滤端口范围：tcp.port &gt;= 1 and tcp.port &lt;= 80</div></li></ul><li><div>根据数据报中携带的信息搜索：</div></li><ul><li><div>按报长过滤：tcp.len==12</div></li><li><div>按序号搜索：tcp.seq == 11230</div></li></ul><li><div>根据流搜索：</div></li></ul><div>Wireshark菜单功能：</div><ul><li><div>编辑：</div></li><ul><li><div>首选项(Preferences)</div></li></ul><li><div>分析：</div></li><ul><li><div>专家信息，在分析网络性能等方便经常用到，可以看到SYN总量的统计</div></li><ul><li><div>error：：可以看到重传包等</div></li><li><div>warning：</div></li><li><div>note：</div></li><li><div>chat：</div></li></ul></ul><li><div>统计：</div></li><ul><li><div>会话（conversation）：可以看到一共建立了多少条连接，端口号等信息</div></li></ul></ul><div>Wireshark Packet List面板，按网络模型排列：</div><ul><li><div>Frame x：物理层的数据帧概况</div></li><li><div>Ethernet（数据链路层以太网帧头部信息）：</div></li><ul><li><div>Destination：目标mac地址</div></li><li><div>Source：源mac地址</div></li></ul><li><div>Internet Protocol Version 4（网络层）：</div></li><ul><li><div>Total Length：IP包的总长度，包括应用层数据长度和tcp头，ip头</div></li><li><div>Flags：</div></li><li><div>Time to live（TTL）：初始值一般是64，每经过一个路由器就减1</div></li><li><div>Protocol：上层协议</div></li><li><div>Header checksum：头部数据的校验和：不知道干啥的</div></li><li><div>Source：源IP地址</div></li><li><div>Destination：目标IP地址</div></li></ul><li><div>Transmission Control Protocol（传输层），按TCP头顺序：</div></li><ul><li><div>Source Port/Destination：源/目标端口号</div></li><li><div>[Stream index: 1]：</div></li><li><div>[TCP Segment Len：1388]：</div></li><li><div>Sequence number：序列号，【Next Sequence number：下一个要发送的序列号】</div></li><li><div>Acknowledgement number：确认序列号</div></li><li><div>Header Length：头部长度</div></li><li><div>Flags：</div></li><li><div>Window size value：这个值是滑动窗口的大小，这个值*window scale等于win值</div></li><ul><li><div>Calculated window size：这个值是真是的窗口大小</div></li><li><div>Window size scaling factor：这个值应该是系数</div></li><li><div>三者之间的关系是：Calculated window size = Window size value * Window size scaling factor</div></li></ul><li><div>Checksum：TCP数据段的校验和</div></li><li><div><br/></div></li><li><div>Options：</div></li><ul><li><div>Window scale：三次握手时会把这个值告知对方，对方收到后把这个值当作2的指数，算出来的值作为接收窗口的系数（接受窗口*该系数就是真正的接收窗口值）</div></li></ul><li><div>SEQ/ACK analysis：</div></li><ul><li><div>iRTT：RTT时间，往返时间</div></li><li><div>Bytes in flight：拥塞窗口大小</div></li></ul><li><div>Timestamps：</div></li></ul><li><div>Data（有可能是应用层，如NFS协议等）</div></li><li><div>其他操作：</div></li><ul><li><div>添加列：需要添加的地方右键应用为列</div></li></ul></ul><div>Packet Bytes面板：以十六进制和ASCII格式显示数据包的信息</div><div>状态栏：</div><ul><li><div>专家信息</div></li><li><div>注释</div></li><li><div>包数</div></li><li><div>Profile</div></li></ul><div>Wireshark的其他使用技巧：</div><ol><li><div>在Packet Details面板中右键单击任何协议可以启动查看相关的wiki信息</div></li></ol><div> ping的用法：</div><div><br/></div><div>问题汇总：</div><ol><li><div>计算在途数据报：发送方最后一个报的 seq+len 减去最后收到的ack</div></li><li><div>只要很少的丢包重传就足以对性能造成巨大影响</div></li><li><div>发送窗口和MSS有什么区别：发送窗口决定了一口气能发出去多少字节，MSS决定这些字节要分多少个包发完</div></li></ol><div><br/></div><div><span style="font-size: 11pt;">tcpdump</span>:</div><ul><li><div>-i:指定网卡，所有网卡：any； 环回包：lo</div></li><li><div>host：指定这台主机接收和发送的数据</div></li><li><div>-s：指定抓到的每个包的前多少个字节，比如我只想抓每一个frame的前80个字节，就用-s 80，0表示抓取全部</div></li></ul><div><br clear="none"/></div><div><a href="https://www.cnblogs.com/f-ck-need-u/p/7064286.html" shape="rect" target="_blank">https://www.cnblogs.com/f-ck-need-u/p/7064286.html</a></div><div>https://www.cnblogs.com/lvdongjie/p/10911564.html</div><div><br clear="none"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>7.TCP参数过滤</div><div>tcp.flags 显示包含TCP标志的封包。</div><div>tcp.flags.syn == 0x02     显示包含TCP SYN标志的封包。</div><div>tcp.window_size == 0 &amp;&amp; tcp.flags.reset != 1</div><div><br clear="none"/></div><div>去掉重传的包：!(tcp.analysis.retransmission)，重传：tcp.analysis.retransmission</div><div>8.包内容过滤</div><div>-----------------------------------------------</div><div>tcp[20]表示从20开始，取1个字符</div><div>tcp[20:]表示从20开始，取1个字符以上</div><div>注： 些两虚线中的内容在我的wireshark（linux）上测试未通过。</div><div><br/></div><div>关键字过滤/查找：</div><ul><li><div>frame.number&gt;21 &amp;&amp; frame.number&lt;25：过滤序号在(21, 25)内的报文</div></li></ul><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div>1、Wireshark的数据包详情窗口，如果是用中括号[]括起来的，表示注释，在数据包中不占字节</div><div>2、在二进制窗口中，如“DD 3D”，表示两个字节，一个字节8位</div><div>3、TCP数据包中，seq表示这个包的序号，注意，这个序号不是按1递增的，而是按tcp包内数据字节长度加上，如包内数据是21字节，而当前IP1发到IP2的包的seq是10的话，那下个IP1发到IP2的包的seq就是10+21=31——同一个方向看seq，这一个seq=上一个seq+len</div><div><br/></div><div>7、</div><div>8、在网络不堵即滑动窗口一点都不堵的情况下，第一个包的ack号就是第二个包的seq号，如果堵了，由于是滑动窗口缓存处理队列，所以这个值会错开</div><div>9、如果A发到B连续几个包，seq号不变，ack号一直在变大，说明A一直在收B的数据，一直在给B应答</div><div>10、如果A发到B连续几个包，seq号一直变大，ack号一直没变，说明A一直在向B发数据，不用给B应答，而是在等B的应答</div><div>11、可以接收多个数据包后，一次性给一个应答，不用每个数据包一一对应给应答</div><div>12、发了一个包，很久没有收到应答后，会重发包，在Wireshark抓包工具提示“[TCP Retransmission]”，在数据包详情窗口点开可以看到是对哪个数据包的重传</div><div>14、如果出现这个错误“[]”，说明乱序了，前一个包没有收到，收到后面的包了，这时也会重传包</div><div>tcp segment of a seassembled PDU: 说明发送端发送的TCP缓存数据过大，需要进行分片发包，分片发包过程中，发送端发送的数据报文中的Ack(Acknowledgment number)编号保持一致</div><div>retransmission:重传</div><div><br clear="none"/></div><div><span style="font-family: Monaco, Courier, monospace;">常见问题：</span></div><div><span style="font-family: Monaco, Courier, monospace;">为什么会发送RST？<a href="https://blog.csdn.net/u014774781/article/details/48349107" shape="rect" style="font-family: Monaco, Courier, monospace;" target="_blank">https://blog.csdn.net/u014774781/article/details/48349107</a></span></div><div><a href="https://blog.csdn.net/guowenyan001/article/details/11766929" shape="rect" style="font-family: Monaco, Courier, monospace;" target="_blank">https://blog.csdn.net/guowenyan001/article/details/11766929</a></div><div><br clear="none"/></div></div><div><br/></div></span>
</div></body></html> 