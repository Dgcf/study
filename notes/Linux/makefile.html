<html>
<head>
  <title>makefile</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="698"/>
<h1>makefile</h1>

<div>
<span><div><div><div><div><div><span style="font-family: Georgia;">讲解gcc编译的网站：</span><a href="http://c.biancheng.net/gcc/" style="font-family: Georgia;">http://c.biancheng.net/gcc/</a></div><div>-D_DEBUG</div><div>-DNDEBUG</div><div>规则：</div><ul><li><div>用gcc编译时候,既有cpp文件又有c文件时候需要加上-lstdc++。</div></li><li><div>\：换行符</div></li><li><div>-rm：加一个小减号的意思就是也许某些文件出现问题，但不要管，继续做后面的事情</div></li><li><div>引用其他makefile：include filename，会把内容安插在当前位置；如果文件没有指定绝对路径或相对路径，make会在当前目录下查找，如果当前目录下没有找到，make会在以下目录下查找：</div></li><ul><li><div>如果make执行时又 &quot;-I&quot;或&quot;--include-dir&quot;参数，就会在这个参数下查找</div></li><li><div>如果目录&lt;prefix&gt;/include（一般是：usr/local/bin或/usr/include）存在的话make也会去找。</div></li><li><div>如果没有找到make会生成一条警告信息但不会马上出现致命错误。如果想让make不理会那些无法读取的文件而继续执行，可以在include前加 &quot;-&quot;</div></li></ul></ul><div>链接库：</div><ul><li><div>-l加的时候，把&quot;lib&quot;三个字符省略，例如链接libtest.so你就需要加 -ltest ,一般这个库在usr/lib下可以找到。</div></li><li><div>lz是压缩库（libz）</div></li><li><div>lrt是实时库（librt）</div></li><li><div>lm是数学库（libm）</div></li><li><div>lc是标准C库（libc）</div></li><li><div>ldl是显式加载动态库的动态函数库</div></li></ul><div><span style="color: rgb(227, 0, 0);">怎样禁止显示gcc的编译过程？</span></div><div><span style="font-size: 10pt; font-family: Georgia;">gcc/g++：命令：</span></div><ul><li><div><span style="font-family: Georgia;">四步编译过程：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">-E：仅执行预编译，只会将预处理操作的结果输出到屏幕上，并不会自动保存在某个文件中，因此和-o连用，.i和.ii分别为C/C++预处理后所得的文件名</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-S：将c代码转换成汇编代码</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-c：仅执行编译操作，不执行链接操作，如果不加其他参数会将生成的可执行文件的文件名自动生成a.out</span></div></li></ul><li><div><span style="font-family: Georgia;">g++后直接接文件名生成a.out的文件</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-o：指定生成的文件名</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-g：对程序进行调试性编译时加该命令</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-Wall：显示警告信息</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-I/path（i的大写）：后接路径path就是设置include文件的目录，默认在/usr/include下</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-M：自动搜索目标依赖项</span></div></li><li><div><span style="font-family: Georgia;">-C：阻止删除源文件中的注释</span></div></li><li><div><span style="font-family: Georgia;">-w：禁止显示所有警告信息</span></div></li><li><div><span style="font-family: Georgia;">-C/--directory=&lt;dir&gt;:指定读取makefile的目录</span></div></li><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">-std=c++11:支持C++11</span></span></div></li><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Verdana;">编译32位程序：</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">-m32</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">链接库：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">-shared：编译so库</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">-fPIC：作用于编译阶段，告诉编译器产生与位置无关的代码。在产生的代码中没有绝对地址，全部使用相对地址。我们总是用fPIC来生成so，也从来不用fPIC生成.a。当然可以不用fPIC编译so，但这样的so必须要在加载到用户程序的地址空间时重定向所有标目（怎么重定向的所有表目？待实证）</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">链接其他库：通常情况下gcc会在标准库目录中搜索文件，如果想链接其他目录中的库就需要特别指明。三种方式：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">使用-L，为gcc增加另一个搜索链接库的目录，</span><span style="font-size: 10pt; font-family: Georgia;">后紧接路径表示在哪个目录下查找</span><span style="font-size: 10pt; font-family: Georgia;">： gcc main.c -o main.out -L/usr/lib -lm</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">把包括所需链接库的目录加到环境变量LIBRARYPATH中</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">把链接库作为一般的目标文件，为gcc指定该链接库的完整路径和文件名</span></div></li></ul><li><div>优化：</div></li><ul><li><div>-O2</div></li></ul></ul><div><br/></div><div><span style="font-family: Georgia;">make工作步骤：</span></div><ol><li><div><span style="font-family: Georgia;">读入所有的makefile</span></div></li><li><div><span style="font-family: Georgia;">读入include的makefile</span></div></li><li><div><span style="font-family: Georgia;">初始化文件中的变量</span></div></li><li><div><span style="font-family: Georgia;">根据依赖关系，决定哪些目标要(重新)生成</span></div></li><li><div><span style="font-family: Georgia;">执行生成命令</span></div></li></ol><div><span style="font-family: Georgia;">make命令：</span></div></div><ul><li><div><span style="font-family: Georgia;">检查规则/调试：不执行参数，只打印命令，把规则和连带的规则打印出来</span></div></li><ul><li><div><span style="font-family: Georgia;">-n</span></div></li><li><div><span style="font-family: Georgia;">--just-print</span></div></li><li><div><span style="font-family: Georgia;">--dry-run</span></div></li><li><div><span style="font-family: Georgia;">--recon</span></div></li></ul><li><div><span style="font-family: Georgia;">--debug【=【options】】：输出make的调试信息，感觉这个和makefile的调试没多大关系，先记在这里吧</span></div></li></ul><div><br/></div><div><br/></div></div><div><span style="font-family: Georgia;">隐含规则：</span></div><ol><li><div><span style="font-family: Georgia;">&quot;&lt;n&gt;.o的目标的依赖目标会自动推导为&quot;&lt;n&gt;.c&quot;,并且其生成命令为 $(CC) -c $(CPPFLAGS) $(CFLAGS)——依赖文件是cpp就可以自动推导生成.o文件</span></div></li><li><div><span style="font-family: Georgia;">链接object文件的隐含规则：&quot;&lt;n&gt;&quot;目标依赖于&quot;&lt;n&gt;.o&quot;,通过运行C的编译器来运行链接程序生成，其生成命令为：$(CC) -c $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)——如果文件名不一样，就推导不出来，会报错</span></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">隐含规则使用的变量：</span></div></li></ol><ul><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">编译C程序的隐含规则的命令是：$(CC) -c $(CFLAGS) $(CPPFLAGS)，make默认的编译命令是cc，</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">AR 函数库打包程序。默认命令是“ar”。</span></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">AS 汇编语言编译程序。默认命令是“as”。</span></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">CC C语言编译程序。默认命令是“cc”。</span></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">CXX C++语言编译程序。默认命令是“g++”。</span></div></li><li><div><font face="Georgia" style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; color: unset;">CPP C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。</span></font></div></li><li><div><font face="Georgia" style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; color: unset;">RM 删除文件命令。默认命令是“rm –f”。</span></font></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">2、关于命令参数的变量：</span><span style="font-size: 10pt; color: unset; font-family: Georgia;">下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</span></div><ul><li><div><font face="Georgia" style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; color: unset;">ARFLAGS 函数库打包程序AR命令的参数。默认值是“rv”。</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: unset; font-family: Georgia;">ASFLAGS 汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: unset; font-family: Georgia;">CFLAGS C语言编译器参数。</span></font></div></li><li><div><font face="Georgia" style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; color: unset;">CXXFLAGS C++语言编译器参数。——默认值好像是0</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: unset; font-family: Georgia;">CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。</span></font></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">LDFLAGS 链接器参数。（如：“ld”）</span></div></li></ul><div><span style="font-size: 10pt; font-family: Georgia;">自动化变量：只能出现在规则的命令当中</span></div><ul><li><div><font face="Georgia" style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; color: unset;">$@:</span></font></div></li></ul><div><br/></div><div>GCC编译器的选项：</div><ul><li><div>-fleading-underscore/-fno-leading-underscore：打开或关闭是否在C语言符号前加上下划线</div></li><li><div>-ffunctions-sections/-fdata-sections：将每个函数或变量分别保存到独立的段中</div></li><li><div>-fno-builtin：gcc会把一些常用的C库函数替换成编译器内置函数以达到优化的功能；使用-fno-builtin参数关闭GCC内置函数功能</div></li></ul><div>makefile中的函数：</div><ol><li><div>$(filter &lt;pattern...&gt;,&lt;text&gt; ):以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，保留符合模式&lt;pattern&gt;的单词。可以有多个模式。返回符合模式&lt;pattern&gt;的字串。</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sources := foo.c bar.c baz.s ugh.h</div><div>foo: $(sources)</div><div>cc $(filter %.c %.s,$(sources)) -o foo</div><div>$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。</div></div><ol start="2"><li><div>$(filter-out &lt;pattern...&gt;,&lt;text&gt; )</div></li></ol><div>功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可<span style="font-size: unset; color: unset; font-family: unset;">以有多个模式。</span></div><div>返回：返回不符合模式&lt;pattern&gt;的字串。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>objects=main1.o foo.o main2.o bar.o</div><div>mains=main1.o main2.o</div><div>$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。</div></div><ol start="3"><li><div>$(findstring &lt;find&gt;,&lt;in&gt; ) 查找字符串函数</div></li></ol><div>功能：在字串&lt;in&gt;中查找&lt;find&gt;字串。</div><div>返回：如果找到，那么返回&lt;find&gt;，否则返回空字符串。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(findstring a,a b c)</div><div>$(findstring a,b c)    #  第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</div></div><ol start="4"><li><div><span style="font-size: unset; color: unset; font-family: unset;">$(firstword &lt;text&gt; ) </span>首单词函数，这个函数可以用word函数来实现：$(word 1,&lt;text&gt; )。</div></li></ol><div>功能：取字符串&lt;text&gt;中的第一个单词。</div><div>返回：返回字符串&lt;text&gt;的第一个单词。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(firstword foo bar)  #  返回值是“foo”。</div></div><ol start="5"><li><div>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; ):</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(patsubst %.c,%.o,x.c.c bar.c)    // 把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</div></div><ol start="6"><li><div>$(sort &lt;list&gt; )  排序函数</div></li></ol><div>功能：给字符串&lt;list&gt;中的单词排序（升序）。</div><div>返回：返回排序后的字符串。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(sort foo bar lose)    #  返回“bar foo lose” ，注意：sort函数会去掉&lt;list&gt;中相同的单词。</div></div><ol start="7"><li><div><span style="font-size: unset; color: unset; font-family: unset;">$(strip &lt;string&gt; )  </span>去空格函数</div></li></ol><div>功能：去掉&lt;string&gt;字串中开头和结尾的空字符。</div><div>返回：返回被去掉空格的字符串值。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(strip a b c )    # 把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</div></div><ol start="8"><li><div>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )：把字串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;，返回替换后的字符串。</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(subst ee,EE,feet on the street)    # 把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”</div></div><ol start="9"><li><div>$(wildcard &lt;*.cpp&gt;)  因为在变量的定义和函数引用时通配符将失效,用这个函数避免失效</div></li></ol><div>    10.$(word &lt;n&gt;,&lt;text&gt; )   <span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">取单词函数</span></div><div>功能：取字符串&lt;text&gt;中第&lt;n&gt;个单词。（从一开始）</div><div>返回：返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大，那么返回空<span style="font-size: unset; color: unset; font-family: unset;">字符串。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(word 2, foo bar baz)  # 返回值是“bar”。</div></div><ol start="11"><li><div>$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt;）   取单词串函数</div></li></ol><div>功能：从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。</div><div>返回：返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的单词数要大，那<span style="font-size: unset; color: unset; font-family: unset;">么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数，那么返回从&lt;s&gt;开始，到&lt;text&gt;结束的单</span><span style="font-size: unset; color: unset; font-family: unset;">词串。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</div></div><ol start="12"><li><div>$(words &lt;text&gt; )   单词个数统计函数</div></li></ol><div>功能：统计&lt;text&gt;中字符串中的单词个数。</div><div>返回：返回&lt;text&gt;中的单词数。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(words, foo bar baz)  # 返回值是“3”，如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：$(word $(words &lt;text&gt;),&lt;text&gt; )。</div></div><div><br/></div><div>  文件名操作函数：<span style="font-size: unset; color: unset; font-family: unset;">主要是处理文件名的。每个函数的参数字符串都会被当做一个或是</span><span style="font-size: unset; color: unset; font-family: unset;">一系列的文件名来对待。</span></div><ul><li><div>$(addprefix &lt;prefix&gt;,&lt;names...&gt; )  加前缀函数</div></li></ul><div>功能：把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词（是前面吧？）。</div><div>返回：返回加过前缀的文件名序列。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(addprefix src/,foo bar)返回值是“src/foo src/bar”</div></div><ul><li><div><span style="font-size: unset; color: unset; font-family: unset;">$(addsuffix &lt;suffix&gt;,&lt;names...&gt;) </span> 加后缀函数<span style="font-size: unset; color: unset; font-family: unset;">  </span></div></li></ul><div>功能：把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。</div><div>返回：返回加过后缀的文件名序列。示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。</div><ul><li><div><span style="font-size: unset; color: unset; font-family: unset;">$(basename &lt;names...&gt; )  </span>取前缀函</div></li></ul><div>功能：从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。</div><div>返回：返回文件名序列&lt;names&gt;的前缀序列，如果文件没有前缀，则返回空字串。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”</div></div><ul><li><div><span style="font-size: unset; color: unset; font-family: unset;">$(dir &lt;names...&gt; )  </span>取目录函数</div></li></ul><div>功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之<span style="font-size: unset; color: unset; font-family: unset;">前的部分。如果没有反斜杠，那么返回“./”。</span></div><div>返回：返回文件名序列&lt;names&gt;的目录部分。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(dir src/foo.c hacks)返回值是“src/ ./”。</div></div><ul><li><div>$(join &lt;list1&gt;,&lt;list2&gt; )：连接函数，</div></li></ul><div>功能：把&lt;list2&gt;对应地加到&lt;list1&gt;后面。如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(join aaa bbb , 111 222 333)        #   list中的单词按空格分割，返回连接过后的字符串：“aaa111 bbb222 333”。</div></div><ul><li><div>$(notdir &lt;names...&gt; )   取文件函数</div></li></ul><div>功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”<span style="font-size: unset; color: unset; font-family: unset;">）之后的部分。</span></div><div>返回：返回文件名序列&lt;names&gt;的非目录部分。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(notdir src/foo.c hacks)返回值是“foo.c hacks”。</div></div><ul><li><div><span style="font-size: unset; color: unset; font-family: unset;">$(suffix &lt;names...&gt; )  </span>取后缀函数</div></li></ul><div>功能：从文件名序列&lt;names&gt;中取出各个文件名的后缀。</div><div>返回：返回文件名序列&lt;names&gt;的后缀序列，如果文件没有后缀，则返回空字串。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</div></div></div><div>  打印输出信息</div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(244, 237, 227); color: rgb(73, 73, 73); font-family: Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">info、warning、error三种输出各有不同，其中error输出甚至会中断编译过程。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$(info infotext)</div><div>$(warning warningtext)</div><div>$(error errortext)</div></div><div>    其他特殊函数</div><ul><li><div>$(if &lt;condition&gt;, &lt;then-part&gt;) / $(if &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;)：如果condition为真（非空字符串），执行then-part并作为返回值，否则执行else-part</div></li><li><div>$(foreach &lt;var&gt;, &lt;list&gt;, &lt;text&gt;)：循环，将参数list中的单词逐一取出放到参数var所指定的变量中，然后再执行text所包含的表达式，每一次text会返回一个字符串，循环过程中text所返回的每个字符串会以空格分隔，最后当整个循环结束时text所返回的每个字符串所组成的整个字符串将会是foreach函数的返回值</div></li><li><div>$(call, &lt;expression&gt;, &lt;parm1&gt;, &lt;parm2&gt;...&gt;：调用自定义函数</div></li><li><div>shell：不像其他函数，它的参数就是操作系统shell的命令，它和反引号&quot;`&quot;是相同的功能，如：</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>contents := $(shell cat foo)</div><div>file:= $(shell echo *.c)</div><div># 这个函数会生成新的shell程序来执行命令，所以要注意性能</div></div><div>    自定义函数：</div><ul><li><div>以define开始，以endef结束</div></li></ul><div><br/></div></div><div><br/></div></span>
</div></body></html> 