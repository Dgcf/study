<html>
<head>
  <title>linux函数</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="667"/>
<h1>linux函数</h1>

<div>
<span><div><div><div><span style="font-family: Georgia;">常用的时间类型有6个：time_t, struct timeb, struct timeval, struct timespec, clock_t, struct tm</span></div><ol><li><div><span style="font-family: Georgia;">time_t是一个长整型，一般用来表示1970年以来的秒数，通过</span><span style="font-family: Georgia; color: rgb(65, 0, 125); font-weight: bold;">time</span><span style="font-family: Georgia;">(NULL)获取</span></div></li><li><div><span style="font-family: Georgia;">timeb主要有l两个成员，一个是秒，一个是毫秒，精确度为毫秒，由int</span> <span style="font-family: Georgia; color: rgb(65, 0, 125); font-weight: bold;">ftime</span><span style="font-family: Georgia;">(struct timeb* tp)来获取，成功返回0，失败-1</span></div></li><li><div><span style="font-family: Georgia;">timevaly有两个成员，一个是秒，一个是微妙，由int</span> <span style="font-family: Georgia; color: rgb(28, 51, 135); font-weight: bold;">gettimeofday</span><span style="font-family: Georgia;">(struct timeval* tv, struct timezone* tz)获取</span></div></li><li><div><span style="font-family: Georgia;">timespec有两个成员，一个是秒，另一个是纳秒，一般由long</span> <span style="font-family: Georgia; color: rgb(65, 0, 125); font-weight: bold;">clock_gettime</span><span style="font-family: Georgia;">(clockid_t which_clock, struct timespec* tp)获取特定时钟的时间，目前有6种时钟：</span></div></li><ol><li><div><span style="font-family: Georgia;">CLOCK_REALTIME                统当前时间，从1970年1.1日算起</span></div></li><li><div><span style="font-family: Georgia;">CLOCK_MONOTONIC               系统的启动时间，不能被设置</span></div></li><li><div><span style="font-family: Georgia;">CLOCK_PROCESS_CPUTIME_ID      进程运行时间</span></div></li><li><div><span style="font-family: Georgia;">CLOCK_THREAD_CPUTIME_ID       线程运行时间</span></div></li><li><div><span style="font-family: Georgia;">CLOCK_REALTIME_HR             CLOCK_REALTIME的高精度版本</span></div></li><li><div><span style="font-family: Georgia;">CLOCK_MONOTONIC_HR            CLOCK_MONOTONIC的高精度版本</span></div></li></ol><li><div><span style="font-family: Georgia;">clock_t类型，由clock_t</span> <span style="font-family: Georgia; color: rgb(79, 0, 154); font-weight: bold;">clock</span><span style="font-family: Georgia;">()获取，表示进程占用的CPU时间，精确到微秒</span></div></li><li><div><span style="font-family: Georgia;">struct tm是直观意义上的时间的表示方法，——其实并不是，还需要strftime进行转换</span></div></li><ol><li><div><span style="font-family: Georgia;">struct tm* gmtime(const time_t* timep):返回格林威治时间——UTC时间</span></div></li><li><div><span style="font-family: Georgia;">struct tm* localtime(const time_t *timep)：返回当地时间——UTC时间+8小时</span></div></li><li><div><span style="font-family: Georgia;">time_t mktime(struct tm* tm)</span></div></li></ol></ol><div><span style="font-family: Georgia;">    时间的转换，使用strftime函数</span></div><div><br/></div><div><span style="font-family: Georgia;">时间：</span></div><div><span style="font-family: Georgia;">1.获得当前时间，精度达到微妙，#include&lt;sys/time.h&gt; int gettimeofday(struct timeval* tv, struct timezone* tz)：推荐使用</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia">struct timeval{</font></div><div><font face="Georgia">long tv_sec;     // 秒</font></div><div><font face="Georgia">long tv_usec;    // </font></div><div><font face="Georgia">}</font></div></div><div><br/></div><div><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">定时器</span><span style="font-family: Georgia;">：</span></div><div><span style="font-family: Georgia;">定时函数有以下：</span></div><ul><li><div><span style="font-family: Georgia;">sleep();睡眠s</span></div></li><li><div><span style="font-family: Georgia;">alarm();</span></div></li><li><div><span style="font-family: Georgia;">usleep();睡眠us，1s = 1000*1000us</span></div></li><li><div><span style="font-family: Georgia;">nanosleep();</span></div></li><li><div><span style="font-family: Georgia;">clock_sleep();</span></div></li><li><div><span style="font-family: Georgia;">getitimer()/setitimer();</span></div></li><li><div><span style="font-family: Georgia;">timer_create/timer_settime()/timer_gettime()/timer_deleter()</span></div></li><li><div><span style="font-family: Georgia;">timerfd_create/timerfd_gettime/timerfd_settime</span></div></li></ul><div><span style="font-family: Georgia;">定时器甄选：</span></div><ol><li><div><span style="font-family: Georgia;">sleep/alarm/usleep实现时有可能用了SIGALRM信号，在多线程中处理信号比较麻烦，</span><span style="font-family: Georgia; font-weight: bold;">应避免使用——原因</span><span style="font-family: Georgia;">？</span></div></li><li><div><span style="font-family: Georgia;">nanosleep/clock_nanosleep是线程安全的，但是在多线程编程中不能让线程挂起的方式等待一段时间，正确的做法是注册一个时间回调</span></div></li><li><div><span style="font-family: Georgia;">gettimerh和timer_create也是用deliver超时，在多线程可能会有麻烦——</span><span style="font-family: Georgia; font-weight: bold;">具体什么原因</span><span style="font-family: Georgia;">——？</span></div></li><li><div><span style="font-family: Georgia;">timerfd_create把时间变成一个文件描述符，该文件在定时器超时时可读——</span><span style="font-family: Georgia; font-weight: bold;">推荐使用</span><span style="font-family: Georgia;">——</span></div></li></ol><div><span style="font-family: Georgia;">1.</span><span style="font-family: Georgia; font-weight: bold;">timer_t定时器</span><span style="font-family: Georgia;">的使用，总共有3个函数：timer_create()  timer_settime()  timer_gettime()</span></div><div><span style="font-family: Georgia;">编译链接时需要加 -lrt，而且要放到最后面</span></div><div><span style="font-family: Georgia;">    1.头文件：#include &lt;signal.h&gt;#include &lt;time.h&gt;</span></div><ul><li><div><span style="font-family: Georgia;">int timer_create(clockid_t clockid, struct sigevent *sevp,  timer_t *timerid)</span></div></li><ul><li><div><span style="font-family: Georgia;">功能：创建一个POSIX标准的进程定时器</span></div></li><li><div><span style="font-family: Georgia;">参数：</span></div></li><ul><li><div><span style="font-family: Georgia;">clockid 可选系统系统的宏，比如 CLOCK_REALTIME</span></div></li><li><div><span style="font-family: Georgia;">sevp 环境值，结构体struct sigevent变量的地址</span></div></li><li><div><span style="font-family: Georgia;">timerid 定时器标识符，结构体timer_t变量的地址</span></div></li></ul><li><div><span style="font-family: Georgia;">返回值：0 - 成功；-1 - 失败，errno被设置。</span></div></li></ul></ul><div><span style="font-family: Georgia;">    2.#include &lt;time.h&gt;</span></div><ul><li><div><span style="font-family: Georgia;">int timer_settime(timer_t timerid, int flags, const struct itimerspec *new_value, struct itimerspec *old_value)</span></div></li><li><div><span style="font-family: Georgia;">int timer_gettime(timer_t timerid, struct itimerspec *curr_value)</span></div></li><ul><li><div><span style="font-family: Georgia;">功能：设置或者获得定时器时间值</span></div></li><li><div><span style="font-family: Georgia;">参数:</span></div></li><ul><li><div><span style="font-family: Georgia;">timerid 定时器标识</span></div></li><li><div><span style="font-family: Georgia;">flags 0标识相对时间，1标识绝对时间</span></div></li><li><div><span style="font-family: Georgia;">new_value 定时器的新初始值和间隔，如下面的it</span></div></li><li><div><span style="font-family: Georgia;">old_value 取值通常为0或NULL，若不为NULL，则返回定时器前一个值</span></div></li></ul></ul></ul><div><span style="font-family: Georgia;">2.timer_fd定时器：这个接口基于文件描述符，通过文件描述符的可读事件进行超时通知，所以能被用于select/poll的应用场景</span></div><ul><li><div><span style="font-family: Georgia;">接口：#include&lt;sys/timerfd.h&gt;</span></div></li><ul><li><div><span style="font-family: Georgia;">int timerfd_create(int clockid, int flags)：创建一个定时器描述符</span></div></li><ul><li><div><span style="font-family: Georgia;">参数：</span></div></li><ul><li><div><span style="font-family: Georgia;">clockid：指定时间类型，有两个值：</span></div></li><ul><li><div><span style="font-family: Georgia;">CLOCK_REALTIME：系统范围内的实时时钟</span></div></li><li><div><span style="font-family: Georgia;">CLOCK_MONOTONIC：以固定速率运行，从不进行调整和复位，不受任何系统时钟修改的影响</span></div></li></ul><li><div><span style="font-family: Georgia;">flags：</span><span style="font-family: Georgia; color: rgb(227, 0, 0);">干啥的？</span><span style="font-family: Georgia;">取值为</span></div></li><ul><li><div><span style="font-family: Georgia;">0</span></div></li><li><div><span style="font-family: Georgia;">O_CLOEXEC</span></div></li><li><div><span style="font-family: Georgia;">O_NONBLOCK</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">返回值：文件描述符</span></div></li></ul><li><div><span style="font-family: Georgia;">int timerfd_settime(int fd, int flags, const struct itimerspec* new_value, struct itimerspec* old_value)</span></div></li><ul><li><div><span style="font-family: Georgia;">作用：用来启动或关闭fd指定的定时器</span></div></li><li><div><span style="font-family: Georgia;">参数：</span></div></li><ul><li><div><span style="font-family: Georgia;">fd：timerfd_create()的返回值</span></div></li><li><div><span style="font-family: Georgia;">new_value:指定新的超时时间</span></div></li><li><div><span style="font-family: Georgia;">old_value:</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">int timerfd_gettime(int fd, struct itimerspec* cur_value)</span></div></li><ul><li><div><span style="font-family: Georgia;">作用：用于获得定时器距离下次超时还剩下的时间，如果调用定时器已经到期，并且该定时器处于循环模式则调用该函数后定时器重新开始计时</span></div></li><li><div><span style="font-family: Georgia;">cur_value:</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia">struct timespec {</font></div><div><font face="Georgia">               time_t tv_sec;                /* Seconds */</font></div><div><font face="Georgia">               long   tv_nsec;               /* Nanoseconds */</font></div><div><font face="Georgia">           };</font></div><div><font face="Georgia"><br/></font></div><div><font face="Georgia">struct itimerspec {</font></div><div><font face="Georgia">               struct timespec it_interval;  /* Interval for periodic timer */</font></div><div><font face="Georgia">               struct timespec it_value;     /* Initial expiration */</font></div><div><font face="Georgia">           };</font></div></div><div><span style="font-family: Georgia; font-weight: bold;">alarm定时器</span><span style="font-family: Georgia;">：当定时器超时时产生SIGALRM信号，如果忽略或不捕捉此信号，则默认动作是终止调用该alarm函数的进程</span></div><div><span style="font-family: Georgia;">#include&lt;unistd.h&gt;</span></div><div><span style="font-family: Georgia;">unsigned int alarm(unsigned int seconds)：seconds是产生SIGALRM需要经过的时钟秒数。当这一时刻到达时信号由内核产生，由于进程调度的延迟所以进程得到控制从而能够处理该信号还需要一个时间间隔</span></div><div><span style="font-family: Georgia;">int pause(void)：pause函数使调用进程挂起直至捕捉到一个信号。只执行一个信号处理程序并从其返回时pause才返回，在这种情况下pause返回-1，errno设置为EINTR</span></div><div><br/></div><div>access函数</div><h1 style="box-sizing: border-box; outline: 0px; margin: 0px; padding: 0px; font-weight: bold; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 28px; overflow-wrap: break-word; color: rgb(34, 34, 38); word-break: break-all; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; outline: 0px; font-weight: bold; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 28px; overflow-wrap: break-word; color: rgb(34, 34, 38); word-break: break-all; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">system/WIFEXITED/WEXITSTATUS函数-linux</span></h1><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-family: Georgia;">curses函数库</span></span></div><div><span style="font-size: 18px;"><span style="font-size: 18px; font-family: Georgia;">一 屏幕 </span></span></div><ol><li><div><span style="font-family: Georgia;">输出到屏幕：</span></div></li><ul><li><div><span style="font-family: Georgia;">addch：add系列在光标位置添加字符或字符串</span></div></li><li><div><span style="font-family: Georgia;">addchstr</span></div></li><li><div><span style="font-family: Georgia;">insch/delch：插入一个字符，将已有字符右移/delch相反</span></div></li><li><div><span style="font-family: Georgia;">insertln/deleteln：插入一个空白行，将现有行依次向下移一行/deleteln相反</span></div></li><li><div><span style="font-family: Georgia;">beep：发声</span></div></li><li><div><span style="font-family: Georgia;">flash：使屏幕闪烁，如无法产生闪烁效果则会发出声音</span></div></li><li><div><span style="font-family: Georgia;">refresh：刷新物理屏幕，如果没有这个函数，光标不会显示在使用move设置的坐标处</span></div></li><li><div><span style="font-family: Georgia;">box：围绕一个窗口绘制方框，三个参数：窗口指针，围绕所绘制的chtype字符</span></div></li></ul><li><div><span style="font-family: Georgia;">从屏幕读取：一般不常用</span></div></li><ul><li><div><span style="font-family: Georgia;">inch：返回光标当前位置的字符及其附属信息，返回的不是一个字符而是chtype类型的变量，而下两个函数将返回的内容写到字符数组中</span></div></li><li><div><span style="font-family: Georgia;">instr</span></div></li><li><div><span style="font-family: Georgia;">innstr</span></div></li></ul><li><div><span style="font-family: Georgia;">清除屏幕：</span></div></li><ul><li><div><span style="font-family: Georgia;">erase：使每个屏幕位置上写上空白字符</span></div></li><li><div><span style="font-family: Georgia;">clear</span></div></li><li><div><span style="font-family: Georgia;">clrtobot</span></div></li><li><div><span style="font-family: Georgia;">clrtoeol</span></div></li></ul><li><div><span style="font-family: Georgia;">移动光标：</span></div></li><ul><li><div><span style="font-family: Georgia;">move：用来将逻辑光标的位置移动到指定地点。如果希望物理屏幕上的光标位置在调用move函数后立刻有变化就要立刻调用refresh函数</span></div></li><li><div><span style="font-family: Georgia;">leaveok：</span></div></li></ul><li><div><span style="font-family: Georgia;">字符属性</span></div></li><ul><li><div><span style="font-family: Georgia;">attron/</span> <span style="font-size: 14px; font-family: Georgia;">attroff：在不影响其他属性的前提下启用或关闭指定的属性</span></div></li><li><div><br/></div></li><li><div><span style="font-family: Georgia;">attrset</span></div></li><li><div><span style="font-family: Georgia;">standout</span></div></li><li><div><span style="font-family: Georgia;">standend</span></div></li><li><div><span style="font-family: Georgia;">属性有：</span></div></li><ul><li><div><span style="font-family: Georgia;">A_BOLD：粗体</span></div></li><li><div><span style="font-family: Georgia;">A_STANDOUT：黑色背景</span></div></li><li><div><span style="font-family: Georgia;">A_DIM：</span></div></li></ul></ul></ol><div><span style="font-size: 18px;"><span style="font-size: 18px; font-family: Georgia;">二 键盘</span></span></div><ol><li><div><span style="font-family: Georgia;">键盘模式</span></div></li><ul><li><div><span style="font-family: Georgia;">echo/noecho</span></div></li><li><div><span style="font-family: Georgia;">cbreak/nocbreak：设置为cbreak模式：字符一经输入就被立刻传递给程序（默认模式为先缓存回车后传递给程序），nobreak将输入模式重新设置为cooked模式</span></div></li><li><div><span style="font-family: Georgia;">raw/noraw：关闭特殊字符的处理；noraw同时恢复cooked模式和特殊字符处理功能</span></div></li></ul><li><div><span style="font-family: Georgia;">键盘输入</span></div></li><ul><li><div><span style="font-family: Georgia;">getch</span></div></li><li><div><span style="font-family: Georgia;">getstr/getnstr</span></div></li><li><div><span style="font-family: Georgia;">scanw</span></div></li></ul></ol><div><span style="font-size: 18px;"><span style="font-size: 18px; font-family: Georgia;">三 窗口</span></span></div><ol><li><div><span style="font-family: Georgia;">通用函数：</span></div></li><ul><li><div><span style="font-family: Georgia;">newwin：创建新窗口</span></div></li><li><div><span style="font-family: Georgia;">delwin：删除通过newwin创建的窗口</span></div></li><li><div><span style="font-family: Georgia;">加w：需要在参数表最前面增加一个WINDOW指针参数</span></div></li><li><div><span style="font-family: Georgia;">加mv：需要在参数表最前面增加两个参数纵坐标y和横坐标x</span></div></li><li><div><span style="font-family: Georgia;">加wmv：需要在参数最前面增加三个参数WINDOW*，y，x</span></div></li></ul><li><div><span style="font-family: Georgia;">移动和更新窗口</span></div></li><ul><li><div><span style="font-family: Georgia;">touchwin：通知curses函数库其指针参数指向的窗口内容已经发生变化，这意味着，在下次调用wrefresh时curses必须重新绘制该窗口</span></div></li><li><div><span style="font-family: Georgia;">scrollok：这两个函数控制窗口卷屏，默认是不卷屏</span></div></li><li><div><span style="font-family: Georgia;">scroll：把窗口内容上卷一行</span></div></li></ul></ol><div><span style="font-size: 18px;"><span style="font-size: 18px; font-family: Georgia;">四 子窗口</span></span></div></div><div><span style="font-size: 18px;"><br/></span></div><div><span style="font-size: 18px;"><span style="font-size: 18px; font-family: Georgia;">IO:</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">在I/O标准库中与低层文件描述符对应的是流，被实现为指向结构FILE的指针</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">在启动程序时，有三个文件流是自动打开的，stdin，stdout，stderr，与底层描述符0，1，2相对应</span></span></div><ul><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fopen，fclose</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fread，fwrite</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fflush</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fseek</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fgetc，getc，getchar</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fputc，putc，putchar</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fgets，gets：从指定的文件流中读取一行或指定个数的字符</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">feof：检测是否到了文件尾</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">printf，fprintf，sprintf</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">scanf，fscanf，sscanf</span></span></div></li></ul><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">格式化输入输出：</span></span></div><ul><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">printf</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fprintf</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">sprintf：</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">scanf</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fscanf</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">sscanf：int sscanf（const char *str,const char *format,……）：将字符串str按format指定的格式输出到后接buf中</span></span></div></li></ul><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">其他流函数：</span></span></div><ul><li><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fgetpos：获取文件流的当前读写位置</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">fsetpos：设置文件流的当前读写位置</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">ftell：返回文件流当前读写位置的偏移值</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">rewind：重置文件流中的读写位置</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">freopen：重新使用一个文件流</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">setvbuf：设置文件流的缓冲机制</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">remove：相当于unlink函数，</span></span></div></li></ul><div><br/></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">FILE *fopen（const char *filename，const char *mode）：打开filename指定的参数，并与一个文件流关联起来，mode参数指定文件的打开方式，取值如下（b表示文件是二进制文件而不是文本文件）：</span></span></div><ul><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">r/rb：以只读方式打开</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">w/wb：以写方式打开，并将文件截短为0</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">a/ab：以写方式打开，新内容追加在文件尾</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">r+/rb+/r+b：以读写方式打开</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">w+/wb+/w+b：以读写方式打开，并将文件截短为0</span></span></div></li><li style="font-size: 15px;"><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">a+/ab+/a+b：以读写方式打开，在文件尾追加内容</span></span></div></li></ul><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;"> 返回值：成功时返回非空FILE指针，失败时返回NULL</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">size_t fread(void *ptr，size_t size, size_t nitems, FILE *stream)：数据从stream读取到ptr指向的数据缓冲区</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">size_t fwrite(const void *ptr, size_t size, size_t nitems, FILE *stream)：</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int fclose（FILE *stream）</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int fflush（FILE *stream）：将文件流中所有未写出的数据立刻写出</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int fseek（FILE *stream，long int offset，int whenc）：为文件流中下一次读写操作指定位置</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int fgetc（FILE *stream）：从文件流中读取下一个字节并将其作为一个字符返回。当到达文件尾或出错时返回EOF</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int getc（FILE *stream）：</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int getchar()：相当于getc（stdin）：从标准输入中读取下一个字符</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int fputc（int c，FILE *stream）：</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int putc（int c，FILE *stream）：</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int putchar（int c）</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int printf</span></span></div><div><span style="font-size: 15px;"><span style="font-size: 15px; font-family: Georgia;">int sprintf（char *s，const char *format，……）：</span></span></div><div><span style="font-size: 18px;"><br/></span></div><div><span style="font-size: 18px;"><br/></span></div></div><div><br/></div></span>
</div></body></html> 