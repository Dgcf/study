<html>
<head>
  <title>调试</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="697"/>
<h1>调试</h1>

<div>
<span><div><div><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">基本调试</span><span style="font-size: unset; color: unset; font-family: unset;">：编译时加上 -g，添加调试信息</span></div><ul><li><div>断点操作：</div></li><ul><li><div>设置断点：</div></li><ul><li><div>b function：在函数function的入口处设置断点，C++中可以使用<span style="color: rgb(65, 173, 28);">class::function</span>或function(type,type)来指定函数名</div></li><li><div>b line_number：在<span style="color: rgb(65, 173, 28);">当前活动源代码文件</span>的line_number处设置断点</div></li><li><div>b filename:line_number：在源代码文件filename的line_number处设置断点，文件可以使用相对或者绝对路径</div></li><li><div>b filename:function：在文件filename中的function入口处设置断点。会在所有重载函数或同名静态函数上设置断点</div></li><li><div>b *address在程序运行的内存地址处停住。</div></li><li><div>条件断点：break <span style="font-style: italic;">break-args</span> if (<span style="font-style: italic;">condition </span>)</div></li><ul><li><div>break-args是可以指定断点位置的任何参数，如上所示</div></li><li><div>condition括号可选，condition表达式具有布尔值就行可以</div></li><li><div>条件可以使用：和有效的C语句差不多：</div></li><ul><li><div>相等/不相等/逻辑：&lt;, &lt;=, ==, !=, &gt;, &gt;=, &amp;&amp;, ||</div></li><li><div>按位和移位运算符：&amp;，|， ^, &gt;&gt;, &lt;&lt;</div></li><li><div>算术运算符：+， -，x， /，% </div></li><li><div>自己的函数，只要它们被链接到程序中</div></li><li><div>库函数，只要该库被链接到程序中——<span style="color: rgb(227, 0, 0); font-weight: bold;">库函数还在哪种情况下可以使用，printf可以使用</span></div></li></ul></ul><li><div>对正常断点设置条件以将他们转变为条件断点，使用cond【ition】，如cond 3 i==3，如果要删除条件但保持该断点，只要输入cond 3即可（这个3是断点的序号，可以用info b查看），在程序运行到断点处设置</div></li><li><div>临时断点tb【reak】的命令设置和break相同，有效性只到第一次到达指定行为止</div></li><li><div>如果是虚函数，如下打断点会出现多个：</div></li></ul></ul></ul><div><img src="调试_files/Image.png" type="image/png" data-filename="Image.png"/></div><ul><ul><li><div>删除断点：</div></li><ul><li><div>d breakpoint_list：删除断点使用数值标识符，如delete 2删除第二个断点，delete 2 4删除第2，4个断点</div></li><li><div>d：删除所有断点</div></li><li><div>clear：清除GDB将执行的下一个指令处的断点——<span style="color: rgb(227, 0, 0);">实测为清除执行所在行的断点</span></div></li><li><div>clear function，clear fliename:function，clear line_number和clear filename:line_number,这几个命令的工作方式和break对应的命令相似</div></li></ul><li><div>禁用断点：</div></li><ul><li><div>enable/disable breakpoint-list:禁用断点：其中breakpoint_list是使用空格分隔的列表,如enable 15，</div></li><li><div>enable/disable不带任何参数将启用/禁用现有所有断点</div></li><li><div>enable once breakpoint-list：在断点下次引起GDB暂停执行后被禁用</div></li></ul><li><div>查看断点：info b【reakpoints】，各属性：</div></li><ul><li><div>Num：断点的唯一标识符</div></li><li><div>type：指出该断点是断点，监视点还是捕获点</div></li><li><div>Disp(部署)：指示断点下次引起GDB暂停程序执行后该断点上会发生什么事情，可能的部署有三种：</div></li><ul><li><div>keep(保持)：默认部署，下次断点到达后不改变断点</div></li><li><div>del(删除):下次到达后删除断点，使用tbreak创建的任何断点都是这样的断点</div></li><li><div>dis(禁用)：下次到达断点时会禁用该断点，这是使用enable once命令设置的断点</div></li></ul><li><div>Enb(启用状态)：这个字段说明断点当前是启用还是禁用</div></li><li><div>Address(地址)：内存中设置断点的位置</div></li><li><div>What(位置)：显示断点所在文件和行号</div></li></ul></ul><li><div>执行：</div></li><ul><li><div>step和next都可以单步调试，都有一个可选的参数，如next 3效果和三次next相同；next(单步越过函数)会执行下一行，step(单步进入函数)类似，但在函数调用时，step会进入函数，而next导致程序执行的暂停出现在下次调用函数时 </div></li><li><div>c：程序执行到下一个断点处或程序结束；可以接受一个可选整数参数n，表示要忽略下面n个断点</div></li><li><div>fin：恢复程序执行，直到恰好在当前栈帧完成之后为止，即退出当前函数，进入调用他的函数</div></li><li><div>u：恢复程序执行，通常用在不进一步在循环中暂停的情况下完成正在执行的循环;可以接受源代码中的位置作为参数,会执行到该处：——<span style="color: rgb(227, 0, 0);">并不能执行完循环体？好像不起作用，多执行几次u才会退出循环体，这和代码和机器指令不同有关</span></div></li><ul><li><div>u 17</div></li><li><div>u function</div></li><li><div>u filename:line_number</div></li><li><div>u filename:function</div></li></ul></ul><li><div>检查和设置变量：print和display允许指定可选的格式</div></li><ul><li><div>p：打印，如果要打印指向结构体指针的各成员，使用p *tmp；p $1：打印已经打印过的变量</div></li><li><div>disp  x：GDB在每次暂停时都会打印该变量x（在这个变量的作用域内打印，出了作用域就不打印了）</div></li><li><div>dis disp x：临时禁用某个显示项</div></li><li><div>enable disp x：重新启用</div></li><li><div>完全删除显示的条目，使用 undisp【lay】 xxx</div></li><li><div>p和disp允许指定可选的格式：</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>p/x var  # 以十六进制显示</div><div>其他常用的格式如c表示字符，s表示字符串，f表示浮点</div></div><ul><li><div>监视点：值改变时就暂停执行，只能监视存在且在作用域内的变量，一旦变量不存在于调用栈的任何帧中，gdb会自动删除监视点</div></li><ul><li><div>watch X：每当X值发生变化gdb都会暂停执行——<span style="color: rgb(227, 0, 0); font-weight: bold;">会自动删除监视点，那怎么监视</span></div></li><li><div>基于条件表达式监视：如 watch (z&gt;28),表达式为true时gdb暂停执行</div></li><li><div>查看和删除监视点同断点</div></li></ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">上下移动调用栈</span></div></li><ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">frame命令：当前执行的函数的栈帧编号为0，其父帧被编号为1，以此类推</span></div></li><ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">up命令进入上一个父帧（</span><span style="color: rgb(227, 0, 0); font-family: Georgia;">怎样查看上一个栈中的某些变量的信息？</span><span style="color: rgb(51, 51, 51); font-family: Georgia;">）</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">down：反方向</span></div></li></ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">bt：会显示整个栈，即当前存在的所有帧的集合</span></div></li></ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">显示源码（文件名可以忽略，表示当前文件）：</span></div></li><ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">l【ist】 main.c:main：显示main.c文件中main函数附近的源码（具体是多附近？）</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">l【ist】 main.c:2,20：显示main.c中第2到20行的源码</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">单独l显示当前代码，显示10行</span></div></li></ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">其他调试信息：</span></span></div></li><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">查看变量类型：whatis X</span></span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">ptype：查看类或结构的成员（不是查看值）</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">info locals：得到当前栈帧（函数栈）中所有局部变量的值列表</span></div></li><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">重新开始调试：r</span></div></li><li><div><span style="color: rgb(227, 0, 0); font-family: Georgia;">查看内存：x</span></div></li></ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">断点命令列表，使用commands命令设置命令列表，在断点执行到这里的时候会自动执行commands。格式如下：</span></div></li><ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">这样进行输出的时候会打印断点信息如cpp文件，行号等，使用silent避免打印这些，只输出commands中指定输出的内容</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">如果命令列表中的最后一个命令（end之前）是continue，GDB在完成命令列表中的命令后继续自动执行程序</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">怎样取消这个命令？重新定义一个空集合来取消</span></div></li><li><div><span style="font-size: unset; color: unset; font-family: unset;">commands命令中可以使用if/else之类的逻辑控制，</span><span style="color: rgb(227, 0, 0); font-family: Georgia;">命令列表和条件中断合并使用威力巨大</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>commands breakpoint-number</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">silent</span></div><div>commands  // 用新行分隔的任何有效GDB命令</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">. . .</span></div><div>end</div></div><ul><ul><li><div>define命令创建宏：可以作为commands中的一条命令</div></li><ul><li><div>宏可以使用参数</div></li><li><div>使用show user可以看到所有的宏列表</div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>define CMD</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">/*command*/</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">end</span></div></div><div><br/></div><div><span style="font-weight: bold;">检查和设置变量</span>：</div><ul><li><div>其他命令：</div></li><ul><li><div>printf：类似C中的printf，格式控制输出</div></li><li><div>call：调用程序中的函数</div></li></ul><li><div>检查动态数组：如果是字符串类型还是可以打印出来的，如果是其他类型直接用p x打印不了，一般形式为 *pointer@number_of_elememts；表示打印这个指针的前number_of_elememts个元素</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 代码为：</div><div>int *a = new int[32];</div><div>a[3] = 10;</div><div>gdb: p *a@3</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">显示：$1={0,0,10}</span></div></div><ul><li><div>GDB还允许适当的时候使用强制类型转换</div></li><li><div>GDB中的表达式：</div></li><ul><li><div>GDB变量</div></li><li><div>程序中任何在作用域内的变量</div></li><li><div>任何种类的字符串，数值或字符常量</div></li><li><div>预处理宏</div></li><li><div>条件，函数调用，类型强制转换和所用语言的运算符</div></li></ul><li><div>在GDB中设置变量：——<span style="color: rgb(227, 0, 0); font-weight: bold;">有什么用还没探索出来</span></div></li><ul><li><div>set args 命令设置命令行参数，但这种方法并没有啥优势——？</div></li><li><div>info args：检查当前函数参数</div></li></ul><li><div>GDB自己的变量</div></li><ul><li><div>值历史：诸如 $1, $2等</div></li><li><div>方便变量——？<span style="color: rgb(227, 0, 0); font-weight: bold;">也没看懂</span></div></li></ul><li><div><span style="color: rgb(227, 0, 0); font-weight: bold;">handle命令告诉gdb不要停止或发出警告信息</span></div></li></ul><div><span style="font-weight: bold;">程序崩溃处理</span>：</div><ul><li><div>core文件：使用ulimit命令控制核心文件的创建 ulimit -c n：n是核心文件的最大大小，以kb为单位；ulimit -c unlimited 不限大小；经实测，ulimit只在当前目录下生效；frame n：移动到第n个栈帧中</div></li><li><div><span style="font-size: unset; color: unset; font-family: unset;">调试流程：</span></div></li><ul><li><div>gdb 【应用程序名称】 core</div></li><li><div>backtrace查看崩溃的堆栈：bt</div></li><li><div>frame x：进入x栈帧</div></li></ul><li><div>调试会话期间不退出GDB</div></li><ul><li><div>vim窗口中直接make可以调用同目录下的makefile</div></li><li><div>vim中的autowrite</div></li></ul></ul><div><span style="font-weight: bold;">多线程调试</span>：</div><ul><li><div>info threads:给出当前所有线程的信息，&quot;*&quot;表示当前位于哪个线程；</div></li><li><div>bt查看堆栈</div></li><li><div>thread n，n为info threads中线程前面的编号，切换到n线程</div></li><li><div>break m thread n：当线程n到达源码第88行时停止</div></li><li><div>break xx.cpp:123 thread all：在所有线程中相应的行上设置断点</div></li><li><div>break m thread n if x==y：当钱程n到达源码第m行，并且变量x和y相等时停止执行</div></li><li><div>thread apply ID1 ID2 command：让线程ID1和ID2执行GDB命令command</div></li><li><div>thread apply all command：让所有被调试线程执行GDB命令command</div></li><li><div>set scheduler-locking off|on|step：使用step或continue命令调试当前被调试线程的时候其他线程也是同时执行的。</div></li><ul><li><div>off：不锁定任何线程，也就是所有线程都执行，默认值</div></li><li><div>on：只有被调试线程执行</div></li><li><div>step：在单步的时候，除了next过一个函数之外，只有当前线程会被执行</div></li></ul><li><div>怎样知道其他线程在干什么？thread x切换到其他线程然后执行bt查看该线程的栈</div></li></ul><div><span style="font-weight: bold;">其他调试：</span></div><ul><li><div>调试运行进程：</div></li><ol><li><div>启动gdb时链接目标进程：-p指定目标进程，就可以进入调试状态；c命令继续，不一定是r</div></li><li><div>gdb中链接目标进程：(gdb)attach &lt;PID&gt;</div></li><li><div>断开链接：detach</div></li></ol><li><div>源文件在多个目录下，<span style="font-size: unset; font-family: unset;">dir的用法：</span></div></li><ul><li><div>dir：清除所有自定义源文件搜索路径信息</div></li><li><div>dir xxx：添加一个源文件路径，如果要添加多个，使用&quot;:&quot;；gdb调试时有时会出现找不到源代码文件只有行号的情况，用dir指定源码路径，如果指定到具体文件是不行的（亲测）</div></li><li><div>show dir：显示定义了的源文件的搜索路径</div></li></ul><li><div><span style="font-size: unset; color: unset; font-family: unset;">文件焦点：GDB相关操作都是在具有焦点的文件上进行操作，这个文件默认是包含main函数的文件，当如下动作发生时，焦点会转移：</span></div></li><ul><li><div>向不同的源文件应用list命令——list swap就进入到swapper.c文件中（swap是swapper.c中的函数）</div></li><li><div>进入位于不同的源代码文件中的代码</div></li><li><div>当在不同的源代码文件中执行代码时GDB遇到断点——？</div></li></ul><li><div>调试宏：在gcc编译时加上-ggdb3就可以调试宏了</div></li><ul><li><div>info macro：查看这个宏在哪些文件中被引用了，已经宏定义是什么样的</div></li><li><div>macro：查看宏展开的样子</div></li></ul></ul><div><span style="font-weight: bold;">.gdbinit文件：</span>放在用户主目录下，GDB启动时自动加载</div><ul><li><div>参考：<a href="https://www.cnblogs.com/jiu0821/p/6244324.html">https://www.cnblogs.com/jiu0821/p/6244324.html</a>，格式遵守<span style="font-weight: bold;">：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>define &lt;command&gt;        ## 调用该宏命令执行</div><div>&lt;command&gt;</div><div>end</div><div>document &lt;command&gt;      ## help command可以显示出来</div><div>&lt;help text&gt;</div><div>end</div></div><ul><li><div>show user：可以查看自定义的命令</div></li></ul><div><span style="font-weight: bold;">其他工具</span>：</div><ul><li><div>strace：</div></li><li><div>ltrace：</div></li><li><div>pstack：linux下打印输出此进程的堆栈信息，可以输出所有线程的调用关系栈</div></li></ul><div><span style="font-weight: bold;">调试总结</span>：</div><ul><li><div>某个线程停止（可能是死锁或者消息接收超时）：使用gcore pid（调试进程的pid号）手动生成core文件，再使用<span style="font-weight: bold;">pstack</span>查看堆栈</div></li></ul><div><span style="color: rgb(227, 0, 0); font-weight: bold;">问题总结：</span></div><ol><li><div><span style="color: rgb(227, 0, 0); font-weight: bold;">怎么显示list中的内容？</span></div></li><li><div><span style="color: rgb(227, 0, 0); font-weight: bold;">如果想一直监视而不是每次进入堆栈就watch一次怎么操作？</span></div></li><li><div><span style="color: rgb(227, 0, 0); font-weight: bold;">gdb调试多线程</span></div></li><li><div><span style="color: rgb(227, 0, 0);"><b>带参数的进程怎么调试</b></span></div></li><li><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">GDB不退出重新编译后run报段错误，是什么原因？</span></div></li><li><div>怎样用b一次打多个断点？</div></li></ol></div><div><br/></div><div>简写汇总：</div><div>break：b；delete：d；continue：c；finish：fin；until：u；print：p；backtrace：bt</div><div><br/></div><div><span style="color: rgb(0, 0, 0);">GDB调试：</span></div><div><a href="https://blog.csdn.net/gongmin856/article/details/79192259">https://blog.csdn.net/gongmin856/article/details/79192259</a></div><div><span style="color: rgb(0, 0, 0);">Linux中共提供了三个函数用于打印调用堆栈：</span></div><div><span style="color: rgb(0, 128, 0);">/*</span></div><div><span style="color: rgb(0, 128, 0);">* 函数说明： 取得当前函数的调用堆栈</span></div><div><span style="color: rgb(0, 128, 0);">* 参数：</span></div><div><span style="color: rgb(0, 128, 0);">* buffer：用于存储函数地址的数组</span></div><div><span style="color: rgb(0, 128, 0);">* size：buffer数组的长度</span></div><div><span style="color: rgb(0, 128, 0);">* 返回值：</span></div><div><span style="color: rgb(0, 128, 0);">* 存储到数组中的函数个数</span></div><div><span style="color: rgb(0, 128, 0);">*/</span></div><div><span style="color: rgb(0, 0, 255);">int</span> backtrace(<span style="color: rgb(0, 0, 255);">void</span> **buffer, <span style="color: rgb(0, 0, 255);">int</span> <span style="color: rgb(0, 0, 0);">size);</span></div><div><span style="color: rgb(0, 128, 0);">/*</span></div><div><span style="color: rgb(0, 128, 0);">*</span></div><div><span style="color: rgb(0, 128, 0);">* 函数说明：将一组函数地址转换为字符串</span></div><div><span style="color: rgb(0, 128, 0);">* 参数:</span></div><div><span style="color: rgb(0, 128, 0);">* buffer: 经由backtrace得到的函数地址</span></div><div><span style="color: rgb(0, 128, 0);">* size: buffer数组的长度</span></div><div><span style="color: rgb(0, 128, 0);">* 返回值:</span></div><div><span style="color: rgb(0, 128, 0);">* 函数在系统中对应用字符串</span></div><div><span style="color: rgb(0, 128, 0);">*/</span></div><div><span style="color: rgb(0, 0, 255);">char</span> **backtrace_symbols(<span style="color: rgb(0, 0, 255);">void</span> *<span style="color: rgb(0, 0, 255);">const</span> *buffer, <span style="color: rgb(0, 0, 255);">int</span> <span style="color: rgb(0, 0, 0);">size);</span></div><div><span style="color: rgb(0, 128, 0);">/*</span></div><div><span style="color: rgb(0, 128, 0);">* 函数说明：将一组函数地址转换为字符串</span></div><div><span style="color: rgb(0, 128, 0);">* 参数:</span></div><div><span style="color: rgb(0, 128, 0);">* buffer: 经由backtrace得到的函数地址</span></div><div><span style="color: rgb(0, 128, 0);">* size: buffer数组的长度</span></div><div><span style="color: rgb(0, 128, 0);">* fd: 输出结果文件描述符</span></div><div><span style="color: rgb(0, 128, 0);">*/</span></div><div><span style="color: rgb(0, 0, 255);">void</span> backtrace_symbols_fd(<span style="color: rgb(0, 0, 255);">void</span> *<span style="color: rgb(0, 0, 255);">const</span> *buffer, <span style="color: rgb(0, 0, 255);">int</span> size, <span style="color: rgb(0, 0, 255);">int</span> fd);</div></span>
</div></body></html> 