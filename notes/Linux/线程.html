<html>
<head>
  <title>线程</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="741"/>
<h1>线程</h1>

<div>
<span><div><div><div><div>一.  必须定义宏：_REENTRANT，通过该宏告诉编译器需要<span style="font-weight: bold;">可重入功能</span>；头文件：pthread.h；在编译时需用选项-pthread来链接线程库</div><div>宏_REENTRANT的作用：</div><ol><li><div>会对部分函数重新定义他们的可安全重入版本</div></li><li><div>stdio.h以宏的形式实现的函数将变成可安全重入的函数</div></li><li><div>errno成为一个函数调用，能够以多线程安全的方式来获取errno值</div></li></ol><div>二.  可重入函数：一个函数要成为可重入的，必须具有以下几个特点：</div><ol><li><div>不使用任何静态或全局的非const变量</div></li><li><div>不返会任何静态或全局的非const变量的指针</div></li><li><div>仅依赖于调用方提供的参数</div></li><li><div>不依赖任何单个资源的锁（如mutex等）——<span style="color: rgb(255, 0, 0);">什么意思</span>？</div></li><li><div>不调用任何不可重入的函数</div></li></ol><div>    一般不要频繁的启动和终止线程，最好在程序启动的时候创建线程，在服务运行期不创建</div><div>三.  线程销毁的方式：</div><ul><li><div>自然死亡：从线程函数返回，线程退出——正常退出</div></li><li><div>非正常死亡：从线程函数抛出异常或线程触发segfault信号等非法信号</div></li><li><div>自杀：在线程中调用pthread_exit来立刻退出线程</div></li><li><div>他杀：其他线程调用pthread_cancel强制终止某个线程</div></li><li><div>注意：只有自然死亡才是正常的，其他都是错的，如果非要终止一个线程，最好用fork再开一个进程，而且用文件描述符来通信，不要共享内存</div></li></ul><div>四.  获取线程ID</div><div>getid()和pthread_self()的区别:linux内核并没有实现线程，而是glibc实现的posix线程库，</div><ul><li><div>getid()是linux内核实现的函数，返回的是内核管理的轻量级进程的进程ID，类型pid_t</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">pid_t tid = syscall(SYS_gettid)</span></div></div><ul><li><div>pthread_self：该id由线程库维护，其id在各个进程间独立(即不同的进程中可能有相同的线程ID)，所以gettid()是内核给线程（轻量级进程）分配的进程id，全局（所有进程中）唯一；pthread_self()是在用户态实现的，获取的id实际上是主线程分配给子线程的线程描述符的地址而已，只是在当前进程空间中是唯一的，类型：pthread_t</div></li><ul><li><div>返回值类型是pthread_t,不一定是一个数值，也有可能是一个结构体，所以专门提供了pthread_equal来对比两个线程标识符是否相等</div></li></ul></ul><div>五.  线程相关函数：成功返回0，失败返回错误码</div><ul><li><div>int pthread_equal(pthread_t tid1, pthread_t tid2):线程ID是用pthread_t的数据类型来表示的，可移植的操作系统实现不能把它作为整数处理，因此必须使用一个函数来对两个线程ID进行比较</div></li><li><div>pthread_t pthread_self(void)：可以通过该函数获得线程自身的ID</div></li><li><div>int pthread_create(pthread_t *thread, pthread_attr_t *attr,  void*(*start_routine)(void*),  void *arg)：创建线程</div></li><ul><li><div>参数：</div></li><ul><li><div>thread：线程被创建时这个指针指向的变量中将被写入一个标识符，我们用该标识符来引用新线程</div></li><li><div>attr：用于设置线程属性，一般不需要特殊的属性，所以只需要设置该参数为NULL</div></li><li><div>最后两个参数告诉线程将要启动执行的函数和传递给该函数的参数</div></li></ul><li><div>返回值：调用成功时返回0，失败则返回错误代码</div></li></ul><li><div>pthread_exit()：终止调用他的线程并返回一个指向某个对象的指针——线程可以终止吗</div></li><li><div>pthread_join(pthread_t th, void **thread_return)：类似于wait函数, 第一个参数指定了将要等待的线程，一般是pthread_create的返回的标识符; 第二个参数是一个指针，它指向另外一个指针，而后者指向线程的返回值, 调用成功返回0</div></li><li><div>pthread_cancel：用于请求一个线程终止的函数</div></li><li><div>pthread_setcancelstate：设置自己的取消状态</div></li><li><div>pthread_setcanceltype：如果取消请求被接受了，线程就可以进入第二个控制层次，即使用该函数设置取消类型</div></li></ul><div>同步：</div><ul><li><div>信号量：#include&lt;semaphore.h&gt;，函数以sem_开头；一般被用来保护一段代码；使其每次只能被一个线程运行使用二进制信号量；允许有限数目的线程执行一段代码，需要用到计数信号量；计数信号量不常用</div></li><ul><li><div>通过sem_init(sem_t *sem, int pshared, unsigned int value)创建，创建时指定信号量初始值</div></li><ul><li><div>sem指定信号量对象</div></li><li><div>pshared控制信号量类型，如果值为0表示当前进程的局部信号量,否则这个信号量就可以在多个进程之间共享</div></li><li><div>value为信号量的初始值</div></li><li><div>返回值：成功则返回0,错误返回-1</div></li></ul><li><div>sem_post(sem_t *sem)：参数指针指向的对象是sem_init调用初始化的信号量；以原子操作的方式给信号量的值加1</div></li><li><div>sem_wait(sem_t *sem)：以原子操作的方式给信号量的值减1，会一直等待直到信号量有非零值才开始减法操作;因此，如果对值为2的信号量调用sem_wait,线程将继续执行，如果对值为0的信号量调用，这个函数就会等待，直到有其他线程增加了该信号量的值使其不为0</div></li><li><div>sem_trywait：是sem_wait的非阻塞版本</div></li><li><div>sem_destroy(sem_t *sem)：清理资源</div></li></ul><li><div>互斥量：#include&lt;pthread.h&gt;；成功时返回0，失败时返回错误码，但这些函数并不设置errno，必须对函数的返回码进行检查</div></li><ul><li><div>函数：</div></li><ul><li><div>int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* mutexattr)：</div></li><ul><li><div>属性类型默认为fast，缺点：如果程序试图对一个已经加了锁的互斥量调用pthread_mutex_lock,程序就会阻塞，而又引用拥有互斥量的这个线程正是这个被阻塞的线程，所以互斥量永远不会被解锁</div></li></ul><li><div>int pthread_mutex_lock(pthread_mutex_t * mutex):</div></li><li><div>int pthread_mutex_unlock(pthread_mutex_t mutex):</div></li><li><div>int pthread_mutex_destroy(pthread_mutex_t *mutex)：</div></li><li><div>pthread_mutex_trylock:不会被阻塞住,会返回一个异常值；如果没被锁住，就去锁定之，在成功完成之后会返回零。其他任何返回值都表示出现了错误</div></li></ul><li><div>注意：</div><div><br clear="none"/></div></li></ul><li><div>条件变量：</div></li><ul><li><div>特点：条件变量是用来等待线程而不是上锁的，条件变量通常和互斥锁一起使用。条件变量之所以要和互斥锁一起使用，主要是因为互斥锁的一个明显的特点就是它只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足，所以互斥锁和条件变量通常一起使用。相较于mutex而言，条件变量可以减少竞争。如果仅仅是mutex，那么，不管共享资源里有没数据，生产者及所有消费都全一窝蜂的去抢锁，会造成资源的浪费。</div></li><li><div>函数：</div></li><ul><li><div>pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr)：初始化一个条件变量</div></li><ul><li><div>cond：条件变量，调用时应传&amp;cond给该函数</div></li><li><div>attr：条件变量属性，通常传NULL，表示使用默认属性，也可以使用静态初始化的方法，初始化条件变量：pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</div></li></ul><li><div>pthread_cond_destroy(pthread_cond_t *cond)：销毁一个条件变量</div></li><li><div>pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)：阻塞等待一个条件变量。具体而言有以下三个作用：</div></li><ul><li><div>阻塞等待条件变量cond（参1）满足；</div></li><li><div>释放已掌握的互斥锁mutex（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex)</div></li><li><div>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁</div></li></ul><li><div>pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime)：限时等待一个条件变量</div></li><ul><li><div>参数说明：第三个参数struct timespec结构体，可以在man sem_timedwait中查看。结构体原型如下：</div></li></ul></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct timespec {</div><div>time_t tv_sec;/* seconds */ 秒</div><div>long tv_nsec;/* nanosecondes*/ 纳秒</div><div>}</div><div>struct timespec定义的形参abstime是个绝对时间。什么是绝对时间？2018年10月1日10:10:00，这就是一个绝对时间。什么是相对时间？给洗衣机定时30分钟洗衣服，就是一个相对时间，也就是说从当时时间开始计算30分钟，诸如此类。</div><div>正确用法：</div><div>time_t cur = time(NULL); 获取当前时间。</div><div>struct timespec t;定义timespec 结构体变量t</div><div>t.tv_sec = cur+1; 定时1秒</div><div>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参</div></div><ul><ul><ul><li><div>pthread_cond_signal(pthread_cond_t *cond)：唤醒至少一个阻塞在条件变量上的线程</div></li><li><div>pthread_cond_broadcast(pthread_cond_t *cond)：唤醒全部阻塞在条件变量上的线程</div></li></ul></ul></ul><div>销毁线程的三种方法：linux线程并不是在首次调用的线程main函数返回时自动销毁，所以由如下两种方法加以明确，否则由线程创建的内存空间一直存在</div><ol><li><div>pthread_join:不仅会等待线程终止，还会引导线程销毁，但是在线程终止前调用该函数的线程将进入阻塞状态</div></li><li><div>pthread_detach：不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间</div></li></ol><div>线程属性：</div><div>     涉及到的函数如下，返回值都是：成功返回0， 失败直接返回错误号</div><ul><li><div>pthread_attr_init(pthread_attr_t* attr)：初始化一个线程属性对象</div></li><li><div>pthread_attr_destroy：对属性对象进行清理和回收.一旦对象被回收了，除非它被重新初始化，否则就不能被再次使用</div></li><li><div>pthread_attr_setdetachstate（pthread_attr_t* attr， int detachstate）：</div></li><li><div>pthread_attr_getdetachstate(pthread_attr_t* attr, int *detachstate)：</div></li><li><div>pthread_attr_setschedpolicy(pthread_attr_t* attr, int policy)：控制线程的调度方式</div></li><li><div>pthread_attr_setschedparam()</div></li><li><div>...</div></li></ul><div>脱离线程的概念</div></div><div>取消一个线程：</div><ul><li><div>pthread_cancel(pthread_t thread)：取消一个线程</div></li><li><div>int  pthread_setcancelstate(int state, int* oldstate)：通过这个函数设置自己的取消方法</div></li></ul><div><br/></div><div>原子操作：</div><ul><li><div>type __sync_fetch_and_add (type *ptr, type value, ...)：将value加到*ptr上，结果更新到*ptr，并返回操作之前*ptr的值</div></li><li><div>type __sync_fetch_and_sub (type *ptr, type value, ...)：从*ptr减去value，结果更新到*ptr，并返回操作之前*ptr的值</div></li><li><div>type __sync_fetch_and_or (type *ptr, type value, ...)：将*ptr与value相或，结果更新到*ptr， 并返回操作之前*ptr的值</div></li><li><div>type __sync_fetch_and_and (type *ptr, type value, ...)：将*ptr与value相与，结果更新到*ptr，并返回操作之前*ptr的值</div></li><li><div>type __sync_fetch_and_xor (type *ptr, type value, ...)：将*ptr与value异或，结果更新到*ptr，并返回操作之前*ptr的值</div></li><li><div>type __sync_fetch_and_nand (type *ptr, type value, ...)：将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之前*ptr的值</div></li><li><div>type __sync_add_and_fetch (type *ptr, type value, ...)：将value加到*ptr上，结果更新到*ptr，并返回操作之后新*ptr的值</div></li><li><div>type __sync_sub_and_fetch (type *ptr, type value, ...)：从*ptr减去value，结果更新到*ptr，并返回操作之后新*ptr的值</div></li><li><div>type __sync_or_and_fetch (type *ptr, type value, ...)：将*ptr与value相或， 结果更新到*ptr，并返回操作之后新*ptr的值</div></li><li><div>type __sync_and_and_fetch (type *ptr, type value, ...)：将*ptr与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</div></li><li><div>type __sync_xor_and_fetch (type *ptr, type value, ...)：将*ptr与value异或，结果更新到*ptr，并返回操作之后新*ptr的值</div></li><li><div>type __sync_nand_and_fetch (type *ptr, type value, ...)：将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</div></li><li><div>bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)：比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</div></li><li><div>type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)：比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回操作之前*ptr的值</div></li><li><div>__sync_synchronize (...)：发出完整内存栅栏</div></li><li><div>type __sync_lock_test_and_set (type *ptr, type value, ...)：将value写入*ptr，对*ptr加锁，并返回操作之前*ptr的值。即，try spinlock语义</div></li><li><div>void __sync_lock_release (type *ptr, ...)：将0写入到*ptr，并对*ptr解锁。即，unlock spinlock语义</div></li></ul><div>另一波：</div><ul><li><div><br/></div></li></ul><div>其他：</div></div><ul><li><div>善用__thread关键字：__thread是GCC内置的线程局部存储设施，实现非常高效；只能修饰POD类型，修饰全局变量和函数内的静态类型，不能修饰函数内的局部变量或class的普通成员，不能修饰class，无法自动调用构造和析构；__thread的初始化只能用编译器常量</div></li></ul><div><br/></div></div><div><br/></div></span>
</div></body></html> 