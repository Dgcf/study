<html>
<head>
  <title>类</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="561"/>
<h1>类</h1>

<div>
<span><div><ol><li><div><font face="Georgia">在3.0以上版本中没有旧式类，所有类都会隐式地成为object子类，类继承自type和继承自object有什么区别？<span style="color: rgb(255, 0, 0);">暂时理解为type是object的子类, 类的本质也是一个对象，所以可以进行拷贝，增加属性，动态创建</span></font></div></li><li><div><font face="Georgia">想要查看一个类是否是另一个类的子类，使用内建函数<span style="font-weight: bold;">issubclass</span>，两个参数：第一个参数指定子类，第二个参数指定超类</font></div></li><li><div><font face="Georgia">如果想要知道已知类的基类（们），可以直接使用他们的特殊属性：__base__</font></div></li><li><div><font face="Georgia">使用 <span style="font-weight: bold;">isinstance</span> 方法检查一个对象是否是一个类的实例，但是用该方法并不是个好习惯，应当使用<span style="color: rgb(227, 0, 0);">多态</span></font></div></li><li><div><font face="Georgia">如果想知道一个对象属于哪个类，可以使用__class__属性</font></div></li><li><div><font face="Georgia">python没有提供机制来跟踪一个类有多少个实例被创建了。可以用一个静态成员来记录实例的个数</font></div></li><li><div><font face="Georgia">默认参数应当是不变的对象</font></div></li></ol><div><font face="Georgia"><span style="font-weight: bold;">元类</span>：Python中的类也是对象。元类就是用来创建这些类（对象）的，元类就是类的类，用来定制类的；metaclass的值为可以创建一个类的东西：返回type，或者任何使用到type或者子类化type的东西都可以，所以可以是函数，可以是类(在__new__方法中返回)</font></div><ul><li><div><font face="Georgia">一个基本元类通常是继承自 type 并重定义它的 __new__() 方法 或者是 __init__() 方法, 为了使用这个元类，通常要将它放到到一个顶级父类定义中，然后其他的类继承这个顶级父类。一旦某个元类被指定给了某个类，那么就会被继承到所有子类中去</font></div></li><li><div><font face="Georgia">在元类中选择重新定义 __new__() 方法还是 __init__() 方法取决于想怎样使用结果类。__new__() 方法在类创建之前被调用，通常用于通过某种方式（比如通过改变类字典的内容）修改类的定义。 而 __init__() 方法是在类被创建之后被调用，当需要完整构建类对象的时候会很有用。</font></div></li><li><div><font face="Georgia">metaclass=Singleton #在代码执行到这里的时候，元类中的__new__方法和__init__方法其实已经被执行了，而不是在类实例化的时候执行。</font></div><div><font face="Georgia">且仅会执行一次。</font></div></li><li><div><font face="Georgia">给一个元类添加可选关键字参数需要你完全弄懂类创建的所有步骤， 因为这些参数会被传递给每一个相关的方法。__prepare__() 方法在所有类定义开始执行前首先被调用，用来创建类命名空间。 通常来讲，这个方法只是简单的返回一个字典或其他映射对象。 __new__() 方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。 __init__() 方法最后被调用，用来执行其他的一些初始化工作。</font></div></li><li><div><font face="Georgia">在自定义元类中我们还可以提供其他的关键字参数，为了使元类支持这些关键字参数，必须确保在 __prepare__() , __new__() 和 __init__() 方法中 都使用强制关键字参数，当我们构造元类的时候，通常只需要定义一个 __new__() 或 __init__() 方法，但不是两个都定义。 但是，如果需要接受其他的关键字参数的话，这两个方法就要同时提供，并且都要提供对应的参数签名。 默认的 __prepare__() 方法接受任意的关键字参数，但是会忽略它们， 所以只有当这些额外的参数可能会影响到类命名空间的创建时你才需要去定义 __prepare__() 方法。参考cookbook9.15</font></div></li><li><div><font face="Georgia">使用场合：</font></div><div><font face="Georgia">在类定义时就执行初始化或设置操作是元类的一个典型应用场景。本质上讲，一个元类会在定义时被触发， 这时候你可以执行一些额外的操作。</font></div><div><font face="Georgia">如果你想监控类的定义，通常可以通过定义一个元类, 元类的一个关键特点是它允许你在定义的时候检查类的内容</font></div></li><li><div><font face="Georgia">问题：</font></div></li><ul><li><div><font face="Georgia">什么时候用init，什么时候用new？</font></div></li></ul><li><div><font face="Georgia">元类：https://www.cnblogs.com/tkqasn/p/6524879.html</font></div></li></ul><div><font face="Georgia"><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">类变量和实例变量</span></span>：</font></div><ul><li><div><font face="Georgia">一个独特的特性：类属性可用于为实例属性提供默认值</font></div></li><li><div><font face="Georgia">当用实例对象访问一个属性时，先从实例属性中查找；如果查找不到就到类变量中查找；</font></div></li><li><div><font face="Georgia">经验证，使用类字典不能改变类变量值：MyClass.__dict__['class_var']=1 报错：‘mappingproxy’ object does not support item assignment；但可以通过setattr修改</font></div></li><li><div><font face="Georgia">可变属性：类命名空间中的变量是可变的话，通过类的实例改变了变量，类变量也会发生改变</font></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">class Service(object):</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     data = []</font></span></div><div><font face="Georgia"><span style="font-size: 9pt; color: rgb(51, 51, 51);">  def __init__(self, other_data)</span><span style="font-size: 9pt; color: rgb(51, 51, 51);">:</span></font></div><div><font face="Georgia"><span style="font-size: 9pt; color: rgb(51, 51, 51);">     self</span><span style="font-size: 9pt; color: rgb(51, 51, 51);">.other_data = other_data</span></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">s1.data.append(1)  # 这种方式直接修改的是类变量data</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">s1.data = [1]  # 这种方式是给实例s1新增属性列表data，这两种方式为什么效果不一样？</font></span></div></div><div><ul><li><div><font face="Georgia"><br clear="none"/></font></div></li></ul></div><div><font face="Georgia">一种有趣的技术可以避免伸缩构造器的问题：__init__入参是**kwargs, 使用self.__dict__.update(kwargs)；可以动态添加属性；</font></div><div><font face="Georgia"><span style="font-size: 11pt; font-weight: bold;">继承</span>：</font></div><div><font face="Georgia">1.  抽象基类：本质就是几个特殊方法</font></div><ul><li><div><font face="Georgia">注册虚拟子类的方式是在抽象基类上调用register方法，注册的类就成了抽象基类的虚拟子类，而且issubclass和isinstance等函数都能识别，但注册的类都不会从抽象基类中继承任何方法或属性，而且也不检查是否符合抽象基类的接口，即便在实例化时也不检查，为了避免运行时错误虚拟子类要实现所需的全部方法 </font></div></li></ul><div><font face="Georgia">2. 继承顺序：按方法解析顺序继承，类中有一个__mro__属性，值是一个元组，按照方法解析顺序列出各个超类</font></div><div><font face="Georgia">直接在类上调用实例方法时，必须显式传入self参数，因为这样的访问是未绑定方法；所以使用super()最安全，会遵守方法解析顺序；方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序</font></div><div><font face="Georgia">1. 调用父类方法：</font></div><ul><li><div><font face="Georgia">使用内建函数super()可以调用父类的函数，常用的两种场合：</font></div></li><li><div><font face="Georgia">类变量可以通过实例来访问，且类变量可以继承</font></div></li><li><div><font face="Georgia">当自定义类覆盖了特殊方法时，可以调用原始的特殊方法</font></div></li><li><div><font face="Georgia">属性修饰：</font></div></li><li><div><font face="Georgia">以单个下划线开头的字段应该视为protected字段，以双下划线打头的为private字段；</font></div></li><li><div><font face="Georgia">子类可以访问以单个下划线开头的字段，但是不能访问父类的私有属性；</font></div></li><li><div><font face="Georgia">因为私有字段会发生名称重整，规则为：类A有一个私有字段__a, 访问私有属性时名称会变成：_A__a(经测试)，子类之所以无法访问父类的私有属性，仅仅</font></div></li><li><div><font face="Georgia">变换后的属性名和与待访问的属性名不同而已。但访问改变后的名称还是可以访问到的，不受制于&quot;__&quot;(private属性的访问权限(effective Python 27))；</font></div></li><li><div><font face="Georgia">这样的属性不能通过继承而被覆盖(cookbook 8.5)，恰当的做法是，宁可叫子类更多地访问超类protected属性，也不要把这些属性设置为private</font></div></li><li><div><font face="Georgia">Python编译器无法严格保证private字段的私密性，应该多用protected属性，但python解释器不会对单个下划线的属性名做特殊处理，不过这是很多python程序员严格遵守的约定</font></div></li><li><div><font face="Georgia">只有当子类不受自己控制时，才可以考虑使用private属性来避免名称冲突——没怎么明白</font></div></li><li><div><font face="Georgia">创建可管理的属性：property装饰器：全部意义在于设置属性时可以进行类型检查，所以只有当确实需要在访问属性时完成一些额外的处理任务时才应该使用property，如果不需要的话用property并不会带来好处</font></div><div><font face="Georgia">     @property默认就是getter</font></div><div><font face="Georgia">     重点强调：除非first_name已经通过@property的方式定义为了property，否则不能定义@first_name.setter, @first_name.deleter；如果只定义了@property而没有@xx.setter，则为只读属性，在访问的时候会抛出异常</font></div><div><font face="Georgia">     例子中初始化方法_init_()中first_name，但后面是_first_name，原因：在初始化的时候也可以进行类型检查，这就是运用名称的微妙之处；如果不是_first_name而是first_name，赋值的时候就会<span style="font-weight: bold;">递归调用</span>setter，这也是名称为什么不一致的原因</font></div><div><font face="Georgia">     如果需要更多对属性访问控制的操作需要使用描述符</font></div><div><font face="Georgia">怎样在子类中扩展property属性？</font></div></li><li><div><font face="Georgia">还能在已经存在get和set方法的基础上定义特性property</font></div></li><li><div><font face="Georgia">参看如下代码(cookbook8.6)：</font></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">class Person:</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">     def __init__(self, first_name):</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">          self.first_name = first_name</font></span></div><div><font face="Georgia"><br clear="none"/></font></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">     @property</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">     def first_name(self):</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">          return self._first_name</font></span></div><div><font face="Georgia"><br clear="none"/></font></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">     @first_name.setter</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">     def first_name(self, value):</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">        if not isinstance(value, str):</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">            raise TypeError('Expected a string')</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">         self._first_name = value</font></span></div><div><font face="Georgia"><br clear="none"/></font></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">     @first_name.deleter</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">     def first_name(self):</font></span></div><div><span style="color: rgb(51, 51, 51); font-size: 9pt;"><font face="Georgia">          raise AttributeError(&quot;Can't delete attribute&quot;)</font></span></div></div><ul><li><div><font face="Georgia">属性描述符也可用在函数中，这种情况常出现在避免重复的属性方法：要深入体会和运用。cookbook9.21</font></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">def typed_property(name, expected_type):</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     storage_name = '_' + name</font></span></div><div><font face="Georgia"><br clear="none" style="font-size: 9pt; color: rgb(51, 51, 51);"/></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">@property</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">def prop(self):</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     return getattr(self, storage_name)</font></span></div><div><font face="Georgia"><br clear="none" style="font-size: 9pt; color: rgb(51, 51, 51);"/></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">@prop.setter</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">def prop(self, value):          # self是谁？什么时候给传递的？</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     if not isinstance(value, expected_type):</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">         raise TypeError('{} must be a {}'.format(name, expected_type))</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     setattr(self, storage_name, value)</font></span></div><div><font face="Georgia"><br clear="none" style="font-size: 9pt; color: rgb(51, 51, 51);"/></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     return prop</font></span></div><div><font face="Georgia"><br clear="none" style="font-size: 9pt; color: rgb(51, 51, 51);"/></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia"># Example use</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">class Person:</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     name = typed_property('name', str)</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     age = typed_property('age', int)</font></span></div><div><font face="Georgia"><br clear="none" style="font-size: 9pt; color: rgb(51, 51, 51);"/></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">def __init__(self, name, age):</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     self.name = name</font></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51);"><font face="Georgia">     self.age = age</font></span></div></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;"><font face="Georgia">问题：为什么给类Person的实例name属性赋值时执行了类属性name？</font></span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;"><font face="Georgia">类Person的类属性这时候是Property object</font></span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;"><font face="Georgia">函数typed_property 所做的仅仅就是生成属性并返回这个属性对象,因此，当在一个类中使用它的时候，效果跟将它里面的代码放到类定义中去是一样的</font></span></div><ul><li><div><font face="Georgia">注意事项：</font></div></li><ul><li><div><font face="Georgia">在子类中扩展属性：property属性在子类中重写(cookbook8.8)</font></div></li><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;"><font face="Georgia">一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法__call__()</font></span></div></li></ul><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">静态方法：静态方法就是普通方法，只是在类的定义体而不是模块层中定义，反倒使用模块层函数更简便</font></div></li><ul><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">在创建时被装入staticmethod类型，定义没有self参数，</font></div></li><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">能够被类本身直接调用，也可以被类的实例调用</font></div></li><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">可以修改类变量</font></div></li><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">以下代码：</font></div></li></ul></ul><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia">class Parent(object):</font></div><div><font face="Georgia">   x = 1</font></div><div><font face="Georgia"><br clear="none"/></font></div><div><font face="Georgia">class Child1(Parent):</font></div><div><font face="Georgia">   pass</font></div><div><font face="Georgia"><br clear="none"/></font></div><div><font face="Georgia">class Child2(Parent):</font></div><div><font face="Georgia">   pass</font></div><div><font face="Georgia"><br clear="none"/></font></div><div><font face="Georgia">print Parent.x, Child1.x, Child2.x</font></div><div><font face="Georgia">Child1.x = 2</font></div><div><font face="Georgia">print Parent.x, Child1.x, Child2.x</font></div><div><font face="Georgia">Parent.x = 3</font></div><div><font face="Georgia">print Parent.x, Child1.x, Child2.x</font></div></div><div><font face="Georgia">        原因：如果父类的属性被子类修改，这个值只在子类中被修改，不影响父类</font></div></div><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"></div><div><font face="Georgia"><br clear="none"/></font></div><ul><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">类方法：</font></div></li><ul><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">定义时需要名为cls的类似与self的参数，但cls参数一定是类对象，是自动被绑定到类的</font></div></li><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">类方法的一个关键特性就是把类作为其接收的第一个参数</font></div></li><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">类方法可以直接用类的具体对象调用，也可以用类名调用, 可以修改类变量</font></div></li><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">用途：</font></div></li><ul><li><div style="margin: 0px; padding: 0px; text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; widows: 1; -webkit-text-stroke-width: 0px;"><font face="Georgia">最常见的用途是定义其他备选的构造函数，作用类似于c++中的委托构造函数，用类方法的cls返回后调用init方法；当定义一个有着多个构造函数的类时，应该让init函数尽可能简单——除了给属性赋值外什么都不做。</font></div></li></ul></ul><li><div><font face="Georgia">抽象基类：核心特征是不能被直接实例化，抽象类就是为了让其他类继承，主要用途就是强制规定所需的编程接口</font></div></li><ul><li><div><font face="Georgia">抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口：</font></div></li><li><div><font face="Georgia">除了继承这种方式外，还可以通过注册方式来让某个类实现抽象基类：</font></div></li><li><div><font face="Georgia">直接从抽象基类派生子类，除非子类完全抽象基类的抽象方法，否则子类不能实例化</font></div></li><li><div><font face="Georgia">尽管具体子类必须实现抽象类中的所有抽象方法，但是，抽象类中也可以包含具体方法。在子类中可以通过super()来调用。</font></div></li><li><div><font face="Georgia">标准库中已经定义好了一些抽象基类，可以使用这些预定义好的抽象基类来执行一般化的类型检查：if isinstance(x, collections.Sequence):...</font></div></li><li><div><font face="Georgia">collections模块中定义了多个和容器还有迭代器相关的抽象基类，numbers中定义了和数值对象相关的抽象基类；io库中定义了和I/O相关的抽象基类(cookbook 8.12)</font></div></li></ul><li><div><span style="border: 0px currentcolor; text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; white-space: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); -webkit-text-stroke-width: 0px; color: rgb(46, 46, 46);"><font style="font-family: Georgia; font-size: 10pt;">Python内置装饰器：</font></span><span style="font-family: Georgia; font-size: 10pt; color: rgb(46, 46, 46);">有三个内置的装饰器，都是跟class相关的：staticmethod、classmethod 和property。</span></div></li><ul><li><div><span style="font-family: Georgia; color: rgb(46, 46, 46);"><font style="font-size: 10pt;">property 是属性的意思，表示可以通过通过类实例直接访问的信息</font></span></div></li></ul></ul><div><span style="color: rgb(46, 46, 46);"><font style="font-family: Georgia; font-size: 10pt;">Mixin:当需要对类进行定制化处理时可能会用到，这种类存在的意义就是要和其他映射类型通过多重继承的方式混合在一起使用</font></span></div><div><font face="Georgia"><span style="font-size: 18px;"><span style="font-size: 18px; font-weight: bold;"><br/></span></span></font></div><div><font face="Georgia"><span style="font-size: 18px;"><span style="font-size: 18px; font-weight: bold;">静态方法和类方法有什么区别？</span></span>？</font></div><div><font face="Georgia">classMethod最常见的用途是定义备选构造函数</font></div><div><font face="Georgia">静态方法就是普通函数，只是碰巧在类的定义体中而不是模块层定义</font></div></div><div><br clear="none"/></div></span>
</div></body></html> 