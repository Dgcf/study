<html>
<head>
  <title>operator</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="566"/>
<h1>operator</h1>

<div>
<span><div><span style="font-family: georgia, palatina, serif;">下面的三个方法类似，创建的是访问器函数(会自行构建函数)，</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">itemgetter(item)/itemgetter(*items)：<span>用于获取对象的哪些维的数据，</span>返回一个可调用的对象作用于操作对象返回结果，如果多个item指定，则返回一个元组，这个方法据说是针对字典，示例(文档手册)(比lambda表达式稍快)：</span></div></li><li><span style="font-family: georgia, palatina, serif;"><span>要注意，</span></span><ul><li><span style="font-family: georgia, palatina, serif;"><span>operator.itemgetter函数获取的不是值，而是定义了一个函数，通过该函数作用到对象上才能获取值。</span><br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;"><span>itemgetter使用[]运算符，因此不仅支持序列，还支持映射和任何实现__getitem__方法的类（fluent 5.10）</span></span></li></ul></li></ul><div style="box-sizing: border-box; padding: 8px; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">itemgetter(1)('ABCDEF')</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;"># 返回：</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">'B'</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">itemgetter(1,3,5)('ABCDEF')</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">#返回：</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">('B','D','F')</span></span></div><div><br clear="none"/></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">inventory = [('apple',3),('banana',2),('pear',5),('orange',1)]</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">getcount = itemgetter(1)</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">list(map(getcount, inventory))</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;"># 输出</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333;">[3,2,5,1]</span></span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">attrgetter(item)/attrgetter(*item)：返回一个可调用对象，用来获取操作对象的item属性，如果指定多个item，返回一个元组</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div><span style="font-family: georgia, palatina, serif;">调用f = attrgetter('name')，调用f(a),返回a.name</span></div><div><span style="font-family: georgia, palatina, serif;">调用f = attrgetter('name','data'), 调用f(a), 返回：(a.name, a.data)</span></div></div><div><ul><li><div><span style="list-style: none;"><span style="font-family: georgia, palatina, serif;">上面这两个方法和lambda表达式类似，但上面的方法性能更好，且据说attrgetter可以支持多个属性值，但好像lambda也可以支持多个值？？</span></span></div></li></ul></div><ul><li><div><span style="font-family: georgia, palatina, serif;">methodcaller(name[, args...])：创建了一个可调用对象，而且把所需要的参数提供给了被调用的方法，所要做的就是提供恰当的self参数(实例)</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">f = methodcaller('name')，b是有name实例方法的类的实例，调用f(b)返回b.name()；f=methodcaller('name','foo',bar=1):调用f(b)返回                            b.name('foo',bar=1)</span></div></li><li><div><span style="font-family: georgia;">注意区别于getter</span></div></li></ul><ul><li><br clear="none"/></li><li><div><span style="font-family: georgia, palatina, serif;">sub(a-b): a-b</span></div></li><li><span style="font-family: georgia, palatina, serif;">lt(a, b)/__lt__(a, b): less than, 相当于&lt;</span></li><li><span style="font-family: georgia, palatina, serif;">le(a, b)/__le__(a, b): less or equal, 相当于&lt;=</span></li><li><span style="font-family: georgia, palatina, serif;">eq(a, b)/ __eq__(a, b): equal, 等于</span></li><li><span style="font-family: georgia, palatina, serif;">ne(a, b)/ __ne__(a, b): not equal 不等于 </span></li><li><div><span style="font-family: georgia, palatina, serif;">gt(a, b)/__gt__(a, b): great than，大于，返回值为True/False</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">ge(a, b)/__ge__(a, b): great or equal, 大于等于</span></div></li><li><span style="font-family: georgia, palatina, serif;">not(obj)/__not__(obj): </span></li><li><span style="font-family: georgia, palatina, serif;">truth(obj)/__truth__(obj): 如果obj是True返回真</span></li><li><span style="font-family: georgia, palatina, serif;">is_(a, b): 返回 a is b</span></li><li><span style="font-family: georgia, palatina, serif;">is_not(a, b): 返回a is not b</span></li><li><div><span style="font-family: georgia, palatina, serif;">abs(obj)/__abs__(obj): 取绝对值</span></div></li><li><span style="font-family: georgia, palatina, serif;">add(a, b)/__add__(a, b): 相当于a+b，返回和<br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">sub(a, b) / __sub__(a, b): a - b</span></li><li><span style="font-family: georgia, palatina, serif;">mul(a, b) / __mul__(a, b): a * b</span></li><li><span style="font-family: georgia, palatina, serif;">matmul(a, b)/ __matmul__(a, b): 相当于a@b，矩阵乘，<span style="color: #ff0000;">但不知道是什么鬼</span></span></li><li><span style="font-family: georgia, palatina, serif;">neg(obj) / __neg__(obj): 取反，obj是数字</span></li><li><span style="font-family: georgia, palatina, serif;">and_(a, b)/__and__(a, b): 按位与，相当于 &amp;</span></li><li><span style="font-family: georgia, palatina, serif;">or_(a, b) / __or__(a, b): 按位或，相当于 |</span></li><li><span style="font-family: georgia, palatina, serif;">xor(a, b) / __xor__(a, b): 按位异或 a^b</span></li><li><span style="font-family: georgia, palatina, serif;">floordiv(a, b)/ __floordiv__(a, b): 相当于 // ，a除以b只取整数部分(不会四舍五入)</span></li><li><span style="font-family: georgia, palatina, serif;">truediv(a, b) / __truediv__(a, b): a除以b后可以取到小数部分而不会忽略，大概取到16位了</span></li><li><span style="font-family: georgia, palatina, serif;">mod(a, b) / __mod__(a, b): a % b</span><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">index(a) / __index__(a): 相当于a.__index__,  返回整数a，不知道这个方法有什么用<span style="color: #ff0000;"></span></span></li><li><span style="font-family: georgia, palatina, serif;">inv(obj)/invert(obj)/__inv__(obj)/__invert__(obj): ~obj，相当于取反</span></li><li><span style="font-family: georgia, palatina, serif;">pos(obj) / __pos__(obj): 去正，<span style="color: #ff0000;">不知道什么意思</span></span></li><li><span style="font-family: georgia, palatina, serif;">lshift(a, b)/__lshift__(a, b): 按位左移, a&lt;&lt;b</span></li><li><span style="font-family: georgia, palatina, serif;">rshift(a, b)/ __rshift__(a, b): 按位右移， a&gt;&gt;b</span></li><li><span style="font-family: georgia, palatina, serif;">pow(a, b) / __pow__(a, b): a**b, a的b次方</span><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></li></ul><div><span style="font-family: georgia, palatina, serif;">以下的操作应用于序列：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">concat(a, b)/__concat__(a, b): 序列a与b相加</span></li><li><span style="font-family: georgia, palatina, serif;">contains(a, b) / __contains__(a, b): 返回 b in a的结果，返回值True或False</span></li><li><span style="font-family: georgia, palatina, serif;">countOf(a, b): 返回b在a中出现的次数，b可以是序列</span></li><li><span style="font-family: georgia, palatina, serif;">delitem(a, b) / __delitem__(a, b): 删除a中下标为b的元素</span></li><li><span style="font-family: georgia, palatina, serif;">getitem(a, b) / __getitem__(a, b): 获取序列a中下标为b的元素</span></li><li><span style="font-family: georgia, palatina, serif;">setitem(a, b, c) / __setitem__(a, b, c): 在序列a中，把下标为b处值设为c；下标b长度不能超过序列长，否则抛出异常</span><br clear="none"/></li><li><span style="font-family: georgia, palatina, serif;">indexOf(a, b): 返回b在序列a中第一次出现时的下标</span><br clear="none"/></li><li><span style="font-family: georgia, palatina, serif;">length_hint(obj, default=0):</span><br clear="none"/></li></ul><div><span style="font-family: georgia, palatina, serif;">inplace operators:</span></div><ul><li><span style="font-family: georgia, palatina, serif;">iadd(a, b)/ __iadd(a, b)__: 相当于a+=b</span></li><li><span style="font-family: georgia, palatina, serif;">iand(a, b) / __iand__(a, b): 相当于 a &amp;= b</span></li><li><span style="font-family: georgia, palatina, serif;">iconcat(a, b) / __iconcat__(a, b): 经验证，序列a和b相加，重复的内容只保留一个，和concat的区别就是concat会把所有内容无保留相加</span></li><li><span style="font-family: georgia, palatina, serif;">ifloordiv(a, b) / __ifloordiv__(a, b): 相当于 a //= b</span></li><li><span style="font-family: georgia, palatina, serif;">ilshift(a, b) / __ilshift__(a, b):  a &lt;&lt;= b</span></li><li><span style="font-family: georgia, palatina, serif;">irshift(a, b) / __irshift(a, b): a &gt;&gt;= b</span></li><li><span style="font-family: georgia, palatina, serif;">imod(a, b) / __imod__(a, b): a %= b</span></li><li><span style="font-family: georgia, palatina, serif;">imul(a, b) / __imul__(a, b): a *= b</span></li><li><span style="font-family: georgia, palatina, serif;">imatmul(a, b) / __imatmul__(a, b): <a href="mailto:a@=" shape="rect" target="_blank">a@=</a> b</span></li><li><span style="font-family: georgia, palatina, serif;">以下为py3.5中新增<br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">ior(a, b) / __ior(a, b)__: a |= b </span></li><li><span style="font-family: georgia, palatina, serif;">ipow(a, b) / __ipow__(a, b):  a**= b</span></li><li><span style="font-family: georgia, palatina, serif;">isub(a, b) / __isub__(a, b): a -= b</span></li><li><span style="font-family: georgia, palatina, serif;">itruediv(a, b) / __itruediv__(a, b): <span style="color: #ff0000;">虽然文档上写着是a /= b，但实际操作发现和truediv没有区别？</span></span></li><li><span style="color: #000000; font-family: georgia, palatina, serif;">ixor(a, b) / __ixor__(a, b): a ^= b</span></li></ul></span>
</div></body></html> 