<html>
<head>
  <title>公共部分</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="548"/>
<h1>公共部分</h1>

<div>
<span><div><div>一等对象的条件：</div><ul><li><div><span style="font-size: 11pt; font-family: georgia;">运行时创建</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">能赋值给变量或数据结构中的元素</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">能作为参数传给函数</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">能作为函数的返回结果</span></div></li></ul><div><span style="font-size: 11pt; font-family: georgia;">在python中，所有的函数都是一等对象</span></div><div><span style="font-size: 11pt; font-family: georgia;">可调用对象（7种）(调用运算符为 ())：</span></div><ul><li><div><span style="font-size: 11pt; font-family: georgia;">用户自定义函数</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">内置函数</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">内置方法，如dict.get</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">方法，在类的定义体中定义的函数</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">类，</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">类的实例：<span style="font-size: 11pt; font-family: georgia; color: rgb(255, 0, 0);">如果类定义了__call__方法，那么它的实例可以像函数一样调用</span></span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">生成器函数</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">注：不仅python函数是真正的对象，任何python对象都可以表现的像函数，为此，只需实现实例的__call__方法</span></div></li></ul><div><span style="font-size: 11pt; font-family: georgia;">规避GIL带来的限制(cookbook12.9)：</span></div><ul><li><div><span style="font-size: 11pt; font-family: georgia;">使用multiprocessing创建一个进程池，把它当作协处理器使用</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">把重点放在C语言扩展编程上，主要思想就是将计算密集型的任务转移到C语言中，在C代码中释放GIL</span></div></li><li><div><span style="font-size: 14.6667px; font-family: georgia;">用C实现python</span></div></li><li><div><span style="font-size: 14.6667px; font-family: georgia;">用ctypes封装C代码</span></div></li><li><div><span style="font-size: 14.6667px; font-family: georgia;">其他</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">1.全局变量：</span></div><div><span style="font-family: georgia, palatina, serif;">在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:</span></div><ol><li><div><span style="font-family: georgia, palatina, serif;">global 声明全局变量</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">全局变量是可变类型数据的时候可以修改</span></div></li></ol><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">global用法</span>：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">局部作用域可以读取外部作用域的变量，但如果改写就会抛出异常</span></div></li><li><div><span style="color: rgb(0, 0, 0); font-family: georgia, palatina, serif;">经测试，只要在用到外部变量的地方都需要使用global来声明</span></div></li><li><div><span style="color: rgb(0, 0, 0); font-family: georgia, palatina, serif;">在闭包中使用很不同，在外函数声明的变量，在内部使用global，在做修改，还是会报错</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">列表推导式和生成器表达式除了能筛选数据之外，还可以用新值替换不满足标准的值，条件判断分别放在前后即可满足这两个功能</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">mylist = [1,4,-5,10,-7,2,3,-1]</span></div><div><span style="font-family: georgia, palatina, serif;">clip = [n if n &gt; 0 else 0 for n in mylist]</span></div><div><span style="font-family: georgia, palatina, serif;">## clip值为：</span></div><div><span style="font-family: georgia, palatina, serif;">[1,4,0,10,0,2,3,0]</span></div><div><span style="font-family: georgia, palatina, serif;">clip2 = [n for n in mylist if n &gt; 0]</span></div><div><span style="font-family: georgia, palatina, serif;">## 输出为：</span></div><div><span style="font-family: georgia, palatina, serif;">[1,4,10,2,3]</span></div></div><div><br clear="none"/></div><div><span style="font-size: 14px; font-family: georgia, palatina, serif; font-weight: bold;">2.迭代器和生成器：</span><span style="font-size: 14px; font-family: georgia, palatina, serif;">所有的生成器都是迭代器，因为生成器完全实现了迭代器接口</span></div><ul><li><div><span style="font-size: 14px; font-family: georgia, palatina, serif;">一个自定义的容器对象内部持有一个列表或元组等其他可迭代对象，想让自己的新容器完成迭代操作可实现委托迭代</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco;"> def __iter__(self):</span></div><div><span style="font-family: Monaco;">    iter(self._inter_list)    # self._inter_list is a list</span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif;">StopIteration</span> 用来指示迭代的结尾</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生成器只有在响应迭代操作(next)时才会运行</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果想编写生成器用来把其他的生成器当做子例程调用，可以选择yield from见cookbook4.14；yield from的作用？</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">想在自己的类中实现生成器，需要实现__iter__并在其中实现逻辑</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可迭代对象和迭代器之间的关系：python从可迭代对象中获取迭代器</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">在python语言内部，迭代器用于支持：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">for循环</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">构建和扩展集合类型——如将该可迭代对象传递给list函数构建一个列表等</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">逐行遍历文本文件</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">列表推导，字典推导，和集合推导</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">元组拆包</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">调用函数时，使用*拆包实参</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可迭代对象与迭代器之间的关系：python从可迭代对象中获取迭代器</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">标准的迭代器对象实现两个方法：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"> __next__: 返回下一个可用元素，如果没有元素了，抛出StopIteration异常</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__iter__:返回self, ——</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">构建可迭代对象和迭代器时经常会出现错误：混淆二者：要知道可迭代对象有个__iter__,每次实例化一个新的迭代器；而迭代器要实现__next__方法,返回单个元素，此外还要实现__iter__方法，返回迭代器本身；可迭代的对象一定不能是自身的迭代器，也就是说，可迭代对象要实现__iter__,但不能实现__next__：这么做是有原因的，所以必须这么做——fluent14.3; 当然有替代方式，那就是fluent14.4，用生成器代替迭代器，在可迭代对象的__iter__中操作生成器，不用再单独定义一个迭代器</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">*可以用来处理可迭代对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生成器：函数中只要出现了yield语句就是一个生成器函数，调用生成器函数会返回一个生成器对象，也就是说，生成器函数是生成器工厂</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生成器函数的定义体中通常都有循环，不过不是必要条件</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可以用生成器创建新的迭代模式</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">和普通函数不同的是，生成器只能用于迭代操作——是不是只能用于for循环迭代？——不是，也可以用于next方法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生成器函数的定义体执行完毕后，生成器对象会抛出StopIteration异常</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生成器表达式可以理解为列表推导的懒惰版本</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">yield from iterable本质上等于for item in iterable: yield item的缩写版；除了代替循环外，yield from还会创建通道，把内层生成器直接和外层生成器的客户端联系起来</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">标准库中的生成器函数：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">用于过滤的生成器函数：从输入的可迭代对象中产生元素的子集，但不修改元素本身</span></div></li></ul><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">3.协程</span>：是一个过程，这个过程与调用方协作，产出由调用方提供的值</div><ul><li><div>定义：使用生成器函数定义：定义体中有yield关键字</div></li><li><div>yield在表达式中的应用：如果协程只需从客户那里接收数据，那么产出的值是None，这个值是隐式指定，因为yield关键字右边没有表达式</div></li><li><div>与创建生成器函数一样，调用函数得到生成器函数</div></li><li><div><span style="font-family: georgia, palatina, serif;">使用协程的步骤：</span></div></li><ul><li><div><span style="font-family: georgia, palatina, serif;">预激：使用next(xx)或者x.send(None)（x为协程对象）</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">给协程发送：x.send(y), 这个方法使生成器前进到下一个yield语句；还允许使用生成器的客户把数据发给自己，即不管传给.send()方法什么参数，那个参数都会成为生成器函数定义体中对应的yield表达式的值——这个值给yield表达式=左边的变量值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">关闭协程：x.close()</span></div></li></ul><li><div><span style="font-family: georgia, palatina, serif;">注意：使用yield from句法调用协程时会自动预激</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">终止协程和异常处理</span></div></li><ul><li><div><span style="font-family: georgia, palatina, serif;">throw(exc_type[, exc_value, [, traceback]]):致使生成器在暂停的yield表达式处抛出指定的异常，如果生成器处理了异常，代码会向前执行到下一个yield表达式，而产出的值会成为调用throw方法得到的返回值(经实测)，如果不处理异常，会在调用端抛出异常，协程终止，状态为GEN_CLOSED</span></div></li></ul><li><div><span style="font-family: georgia, palatina, serif;">yield from：会在内部自动捕获StopIterable异常</span></div></li><ul><li><div><span style="font-family: georgia, palatina, serif;">yield from链条必须由客户驱动，在最外层委派器上调用next函数或send方法，也可以隐式调用如for循环</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数</span></div></li></ul><li><div><span style="font-family: georgia, palatina, serif;">协程的状态(四个状态)，当前状态可以使用inspect.getgeneratorstate()函数确定</span></div></li><ul><li><div><br clear="none"/></div></li></ul></ul><div><br clear="none"/></div><div><span style="font-size: 14px; font-family: georgia, palatina, serif;"><span style="font-size: 14px; font-family: georgia, palatina, serif; font-weight: bold;">4.函数</span>：python中的函数是一等对象</span></div><ul><li><div><span style="font-size: 11pt; font-family: georgia;">高阶函数：接受函数为参数，或者把函数作为结果返回的函数是高阶函数 </span></div></li><li><div><span style="font-family: georgia, palatina, serif;">参数中*和**的作用</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">接受任意数量的位置参数使用以*开头的参数，接受任意数量的关键字参数，这个</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">参数的类型实际上是元组，会被存入到元组中；</span><span style="font-family: georgia, palatina, serif;">以*开头的参数只能作为最后一个位置参数出现，而以**开头的参数只能作为最后一个参数出现，</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">参数类型是字典，就是说，这个键值会被存入到字典中</span><span style="font-family: georgia, palatina, serif;">。(cookbook 7.1,7.2)：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">def a(x, *args, y):</span></div><div><span style="font-family: georgia, palatina, serif;">     pass</span></div><div><span style="font-family: georgia, palatina, serif;">def b(x, *<em>args, y, *kwargs):</em></span></div><div><span style="font-family: georgia, palatina, serif;"><em>     pass</em></span></div><div><span style="font-family: georgia, palatina, serif;"><em>## y只能作为关键字参数使用</em></span></div><div><span style="font-family: georgia, palatina, serif;"><em>## </em>所以，要编写只通过关键字的形式接受特定的参数，可以将关键字参数放置在以*打头的参数或者单独一个*之后<em>：</em></span></div><div><span style="font-family: georgia, palatina, serif;"><em>def recv(maxsize, *, block):     # 不代表任何参数，只用来表示其后的参数为关键字参数</em></span></div><div><span style="font-family: georgia, palatina, serif;"><em>     pass</em></span></div></div><div><ul><li><div><span style="color: rgb(255, 0, 0); font-family: georgia, palatina, serif;">在变量前加单星号表示将元组（列表，集合）拆分为单个元素</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-family: georgia, palatina, serif;">字典前加单星号可以得到“键”</span></div></li></ul></div><ul><li><div><span style="font-family: georgia, palatina, serif;">函数注解：函数注解只会保存在函数的</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">__annotations__</span><span style="font-family: georgia, palatina, serif;">属性中(cookbook 7.3):这个函数注解只是参数类型，默认值，返回值类型，添加字符串说明并不会出现在.__annotations__中</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可以利用函数注解实现函数重载：cookbook9.20</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">在：之后增加注解表达式；如果参数有默认值，注解放在参数名和=之间</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">注解最常用的类型是类和字符串</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">注解不会做任何处理，不检查，不强制，不验证</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: georgia, palatina, serif;">&gt;&gt;&gt;def add(x:int, y:str)-&gt;int:</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: georgia, palatina, serif;">     return x+y</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: georgia, palatina, serif;">&gt;&gt;&gt;add.__annotations__</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: georgia, palatina, serif;">{'x':&lt;class 'int'&gt;, 'b':&lt;class 'str'&gt;, 'return':&lt;class 'int'&gt;}</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: georgia, palatina, serif;">&gt;&gt;&gt;def func(x:int, y:'int &gt; 20'=30)-&gt;int</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: georgia, palatina, serif;">    return x+y</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: georgia, palatina, serif;">{'x':&lt;class 'int'&gt;, 'y': 'int &gt; 20', 'return': &lt;class 'int'&gt;}     </span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">函数中返回多个值：只需要返回一个元组即可</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">定义带有默认参数的函数：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">确保默认参数在最后出现</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">不存在值传递，唯一支持共享传参(引用传递)；传进去的值都会改变</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对默认参数的赋值只会在函数定义的时候绑定一次，如(cookbook7.5)：——和lambda表达式不同，一个是在定义时绑定，一个是在运行时绑定</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">默认参数是否可以这这样理解：如果传入的默认参数是列表，默认列表只在函数被定义的那一刻创建一次（在函数定义时就已经分配好地址了），后面的改动都只是在这个可变对象上做改动，其他对象也都是用同一个列表；如果默认为None，在实例化其他对象时总是会重新创建一个列表，不担心会互相影响——默认值在定义函数时计算（通常在加载模块时）—<span style="font-family: georgia, palatina, serif; color: rgb(255, 0, 0);">—类的init的方法中的默认值还没有执行怎么确定下来的？</span></span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x = 42</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; def spam(a, b=x):</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt;      print(a,b)</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; spam(1)</span></div><div><span style="font-family: georgia, palatina, serif;">1 42</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x = 23</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; spam(1)</span></div><div><span style="font-family: georgia, palatina, serif;">1 42     ## 值没有改变</span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">如果默认值是可变容器如列表，集合或字典，应该使用None作为默认值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; text-decoration: underline;">给默认参数的赋值的应该总是不可变对象，如None,True/False，数字或者字符串，因为默认值如果在函数体外被修改了，这种修改会在之后的函数调用中对参数的默认值产生持续影响</span>（cookbook7.5）：</span></div></li><li><div><span style="font-family: georgia;">如果要避免这种情况，就将默认参数设置为None，在函数体中给这个参数给一个列表</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; def spam(a, b=[]):</span></div><div><span style="font-family: georgia, palatina, serif;">         print(b)</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x = spam(1)</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x</span></div><div><span style="font-family: georgia, palatina, serif;">[   ]</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x.append(99)</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x.append('yow')</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x</span></div><div><span style="font-family: georgia, palatina, serif;">[99, 'yow']</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; spam(2)</span></div><div><span style="font-family: georgia, palatina, serif;">[99, 'yow']          # <span style="color: #ff0000;">这个例子就是因为列表是可变对象才出现这样的问题吗？</span></span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">lambda表达式：</span><span style="font-family: georgia, palatina, serif;">表达式的计算结果就是返回值</span></div></li><li><div><span style="font-family: georgia;">最适合使用的场合：参数列表中；除了作为参数传给高阶函数之外，python很少使用匿名函数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">在运行时绑定而不是定义时绑定,如果想在定义的时候绑定就将该值作为默认参数（cookbook7.7）</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">(这个例子是定义时就绑定了)</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x=10</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; a=lambda y,x=x:x+y——lambda表达式已经运行了？</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; x=20</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; b=lambda y,x=x:x+y</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; a(10)</span></div><div><span style="font-family: georgia, palatina, serif;">20</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; b(10)</span></div><div><span style="font-family: georgia, palatina, serif;">30</span></div><div><span style="font-family: georgia, palatina, serif;">## 高级应用：通过列表推导创建一系列lambda表达式</span></div><div><span style="font-family: georgia, palatina, serif;">funcs = [lambda x:x+n for n in range(5)]————<span style="color: #ff0000;"><strong>？？</strong></span></span></div><div><span style="font-family: georgia, palatina, serif;">funcs = [lambda x,n=n:x+n for n in range(5)]</span></div><div><span style="font-family: georgia, palatina, serif;">for i in funcs:</span></div><div><span style="font-family: georgia, palatina, serif;">     print(i(0))     # 打印结果不同</span></div></div><ul><li><div><span style="font-family: georgia;">看这段代码的输出结果：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def multipliers():</div><div>    return [lambda x : i * x for i in range(4)]</div><div><br clear="none"/></div><div>print [m(2) for m in multipliers()]</div><div>输出的结果是[6,6,6,6]而不是[0,2,4,6]</div></div><div><span style="font-family: georgia;">                    <span style="font-family: georgia; color: rgb(255, 0, 0);">怎样解决这个问题？</span></span></div><ul><li><div><span style="font-family: georgia;">使用生成器：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def multipliers():</div><div>    for i in range(4): yield lambda x : i * x</div></div><ul><li><div><span style="font-family: georgia;">使用闭包，利用默认函数绑定</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def multipliers():</div><div>    return [lambda x, i=i : i * x for i in range(4)]</div></div><ul><li><div><span style="font-family: georgia;">第三种方案是使用偏函数</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from functools import partial</div><div>from operator import mul</div><div><br clear="none"/></div><div>def multipliers():</div><div>    return [partial(mul, i) for i in range(4)]</div></div><div><br clear="none"/></div><ul><li><div><span style="font-family: georgia, palatina, serif;">函数有多个参数，但要求只能带少数个参数，可以使用functools中的partial</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">闭包：延伸了作用域的函数。闭包的一个作用就是可以记住额外的变量后续使用，例子见cookbook7.9；</span></div></li><ul><li><div><span style="font-family: georgia, palatina, serif;">为什么闭包可以访问外面函数定义的局部变量？——调用闭包后局部变量已经初始化，外面的函数返回了，本地作用域一去不返了，这个局部变量就成了自由变量了，自由变量是指未在本地作用域中绑定的变量</span></div></li></ul><li><div><span style="font-family: georgia, palatina, serif;">可以使用闭包代替只有一个方法（不包含init）的类</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">无论何时，在编写代码中遇到需要附加额外的状态给函数时考虑使用闭包</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">访问定义在闭包内的变量：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">nonlocal声明</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">编写存取函数，并将它们</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">作为函数属性</span><span style="font-family: georgia, palatina, serif;">附加到闭包上来提供对内层变量的访问支持</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">def sample():</span></div><div><span style="font-family: georgia, palatina, serif;">     n = 0</span></div><div><span style="font-family: georgia, palatina, serif;">     def func():</span></div><div><span style="font-family: georgia, palatina, serif;">          print('n=', n)</span></div><div><span style="font-family: georgia, palatina, serif;">     def get_n():</span></div><div><span style="font-family: georgia, palatina, serif;">          return n</span></div><div><span style="font-family: georgia, palatina, serif;">     def set_n(value):</span></div><div><span style="font-family: georgia, palatina, serif;">          nonlocal n</span></div><div><span style="font-family: georgia, palatina, serif;">          n = value</span></div><div><span style="font-family: georgia, palatina, serif;">    <span style="color: #ff0000;"> func.get_n = get_n</span>     # 函数也可以有属性</span></div><div><span style="font-family: georgia, palatina, serif;">     <span style="color: #ff0000;">func.set_n = set_n</span></span></div><div><span style="font-family: georgia, palatina, serif;">     return func</span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">尽量用异常来表示特殊情况，不要返回None</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">与用户定义的常规类一样，函数使用__dict__属性存储赋予它的用户属性</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__defaults__属性：值为元组，保存着位置参数和关键字参数的默认值；仅限关键字参数的默认值在__kwdefaults__属性中；参数的名称在__code__属性中</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果一个函数或方法对对象进行的是就地改动，就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">函数注解：</span></div></li><li><div><br clear="none"/></div></li></ul><div><span style="font-size: 14px;"><span style="font-size: 14px; font-family: georgia, palatina, serif; font-weight: bold;">5.</span></span><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">特殊变量</span><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">：</span></div><div style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff;"><ul><li><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">__file__：表示显示文件的当前位置，但是：</span></div></li><li><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">如果当前文件包含在sys.path里，返回一个相对路径</span></div></li><li><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">如果不包含在sys.path里，返回绝对路径</span></div></li></ul><div><span style="font-size: 14px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">6.文件操作：打开的文件是不是可迭代对象？</span></div><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">open(file, mode='r', buffer=-1, enocding=None, erros=None, newline=None, closefd=True, opener=None)：打开文件，返回对应的文件对象，默认打开方式为只读；</span></div><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">打开文件时应当始终明确传入encoding=参数，因为不同设备使用的默认编码可能不同</span></div><ul><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">参数：</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">mode：指定打开文件的方式，默认为‘r'表示以只读的方式打开，具体有以下几种方式：</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">‘r’: 只读</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">‘w'：写，如果有内容会直接截断</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">‘a’：写，如果文件已存在会追加内容</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">'x':——未知</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">'b': 二进制方式</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">’t': 文本模式(默认该模式)</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">‘+’: 打开更新一个disk file（读和写）</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">‘U’：——未知</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">'r+' == r+w（可读可写，文件若不存在就报错(IOError)）</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">'w+' == w+r（可读可写，文件若不存在就创建），使用w模式在打开文件前就已经清空文件内容了</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">'a+' ==a+r（可追加可写，文件若不存在就创建）</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">对应的，如果是二进制文件，就都加一个b就好了：'rb'/'wb'/'ab'/'rb+'/'wb+'/'ab+'</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">如果打不开文件，抛出OSError(py3)</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">如果打开的是一个二进制文件，返回的是没有任何decode的的bytes对象</span></div></li><li><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">打不开文件：抛出OSError(py3)</span></div></li><li><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">打开之后的操作：</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">f.readline():只读一行，用\n分割;如果到达结尾EOF，一个空字符串返回</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">f.read(n)：如果不带参数读出从当前位置到文件尾的所有内容，以string或bytes的方式返回，带参则返回从当前位置开始的n个字节</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">f.tell()：返回文件当前位置距离文件头的字节数</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">f.seek(n)：跳到文件从头开始的第n个字节处</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">f.write(s)：将s写到文件，返回写入的字节数</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">f.close()：关闭文件，释放资源</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">遇到的问题：</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">a或a+模式修改文件指针对于文件的写入没有影响，都会在结尾追加写入</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">对文件的某一行添加内容单纯靠文件操作貌似行不通，只能通过将文件内容读入某种类型操作完后再整体写入文件</span></div></li></ul><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;"><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">7.写脚本方面的总结</span>：</span></div><ul><li><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">让自己的程序在终止时向标准错误输出打印一条消息并返回一个非零的状态码，可以发出一个SystemExit的异常：raise SystemExit('It failed'), 这条信息会被打印到sys.stderr上，且程序的退出状态码为1——<span style="font-size: 15px; color: rgb(255, 0, 255); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">返回状态码为1有什么用？</span></span></div></li><li><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;">在运行时提供密码输入：使用标准库中的getpass模块，有两个方法，一个异常：</span></div><div><span style="font-size: 11pt; color: rgb(46, 46, 46); font-family: georgia, palatina, serif;">getpass.getpass(prompt='Password', stream=None): 默认提示为'Password'，输入的内容在命令行是看不到的；在Windows下stream默认是忽略的</span></div><div><span style="font-size: 11pt; color: rgb(46, 46, 46); font-family: georgia, palatina, serif;">getpass.getuser(): 返回的是默认的用户名</span></div><div><span style="font-size: 11pt; color: rgb(46, 46, 46); font-family: georgia, palatina, serif;">execption getpass.GetPassWarning：</span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0); font-family: georgia, palatina, serif;">这个异常是在什么情况下抛出</span></span><span style="font-size: 11pt; color: rgb(46, 46, 46); font-family: georgia, palatina, serif;">？</span></div></li><li><div><span style="font-size: 11pt; color: rgb(46, 46, 46); font-family: georgia, palatina, serif;">在脚本中打开浏览器：使用模块webbrowser</span></div></li></ul><div><br clear="none"/></div><div><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal;"><span style="font-size: 15px; color: rgb(46, 46, 46); font-family: georgia, palatina, serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">8.规避GIL</span>：</span></div><ol><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">使用multiprocessing模块创建进程池</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">C语言扩展编程上，将计算密集型任务转移到C语言中，使其独立于python，在C代码中释放GIL。具体怎么实现？cookbook12.9；使用其他工具如ctypes或Cython可能不需要做处理，ctypes默认会在调用c代码时自动释放GIL</span></div></li></ol><div><span style="font-size: 15px; font-family: georgia, palatina, serif;"><span style="font-size: 15px; font-family: georgia, palatina, serif; font-weight: bold;">9.拷贝操作</span>：</span></div><ol><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">‘=’：是引用，一个改变会引起其他的改变</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif; text-decoration: line-through;">列表切片操作是一个深拷贝，复制后的新对象为一个独立存在，不会相互影响  </span> <span style="font-size: 15px; font-family: georgia, palatina, serif;">   ——列表的构造方法和切片操作都是浅拷贝</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">copy模块：两个方法copy和deepcopy和一个异常copy.error</span></div></li></ol><ul><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">copy(x):浅拷贝，拷贝父对象，不会拷贝对象内部的子对象；构造一个新的复合对象后，会尽可能的在原始对象中找到对象的引用插入新对象中</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">deepcopy(x):深拷贝；构造一个复合对象后，会递归地将在原始对象中找到的对象的副本插入新对象中</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">注意：</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">对于简单对象来说，深拷贝和浅拷贝并没什么区别，改变原始队列，赋值队列并不会改变；但是对于嵌套队列来说，改变了子对象的值，浅拷贝会改变，深拷贝不会变；但问题是，</span><span style="font-size: 15px; color: rgb(255, 0, 0); font-family: georgia, palatina, serif;">简单对象和复杂对象怎么区分</span><span style="font-size: 15px; font-family: georgia, palatina, serif;">？——包含其他序列</span></div></li></ul></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">10.命名空间：</span>名称到对象的映射。命名空间是一个字典的实现，键为变量名，值是变量对应的值。各个命名空间是独立没有关系的，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响。</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">分类：</span><span style="font-family: georgia, palatina, serif; font-weight: bold;"> python程序执行期间会有2个或3个活动的命名空间（函数调用时有3个，函数调用结束后2个）。</span><span style="font-family: georgia, palatina, serif;">按照变量定义的位置，可以划分为以下3类</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">Local</span>，局部命名空间，每个函数所拥有的命名空间，记录了函数中定义的所有变量，包括函数的入参、内部定义的局部变量</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">Global</span>，全局命名空间，每个模块加载执行时创建的，记录了模块中定义的变量，包括模块中定义的函数、类、其他导入的模块、模块级的变量与常量。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">Built-in</span>，python自带的内建命名空间，任何模块均可以访问，放着内置的函数和异常。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生命周期：各命名空间创建顺序：python解释器启动 -&gt;创建内建命名空间 -&gt; 加载模块 -&gt; 创建全局命名空间 -&gt;函数被调用 -&gt;创建局部命名空间</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"> Local（局部命名空间）在函数被调用时才被创建，但函数返回结果或抛出异常时被删除。（每一个递归函数都拥有自己的命名空间）。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">Global（全局命名空间）在模块被加载时创建，通常一直保留直到python解释器退出。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"> Built-in（内建命名空间）在python解释器启动时创建，一直保留直到解释器退出。</span></div></li><li><div><br clear="none"/></div></li><li><div><span style="font-family: georgia, palatina, serif;">各命名空间销毁顺序：函数调用结束 -&gt; 销毁函数对应的局部命名空间 -&gt; python虚拟机（解释器）退出 -&gt;销毁全局命名空间 -&gt;销毁内建命名空间</span></div></li><li><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">python解释器加载阶段会创建出内建命名空间、模块的全局命名空间，局部命名空间是在运行阶段函数被调用时动态创建出来的，函数调用结束动态的销毁的。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">module的一些内置属性：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__name__：直接运行本文件时这个值为&quot;__main__&quot;，在其他程序中导入这个文件时__name__值为该文件名。因此通过判断__name__值就可以区分py文件是直接被运行的还是被引入到其他文件中</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__file__ : 当前module的绝对路径</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__dict__</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__doc__ </span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__package__</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__path__</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">11 else语句块：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">if/else</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">for/else: 仅当for循环运行完毕时（for循环没有被break语句中止）才运行else块</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">while/else: 仅当while循环因为条件为假值（没有被break中止）而退出才运行else块</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">try/else: 仅当try中没有异常抛出时才运行else</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">12. 多线程</span>：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">actor：一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。作为对这些消息的响应，actor会决定是否要对其他的actor发送进一步的消息。actor任务之间的通信是单向而且异步的，因此，消息的发送者并不知道消息何时才会实际传递，当消息已经处理完毕时也不会接收到响应或者确认。</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">13.可调用对象：可以使用调用运算符('()')的对象, 可以使用callable()判断对象是否可以调用</span></div><ol><li><div><span style="font-family: georgia, palatina, serif;">用户自定义函数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">内置函数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">内置方法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">类的定义体中定义的函数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">类：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">类的实例：如果类定义了__call__，它的实例可以作为函数调用</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生成器函数：使用yield关键字的函数或方法，调用生成器函数返回的生成器对象</span></div></li></ol><div><span style="font-family: georgia, palatina, serif;">14：</span></div><div><span style="font-family: georgia, palatina, serif;">鸭子类型：</span></div><div><span style="font-family: georgia, palatina, serif;">白鹅类型：只要cls是抽象基类，即cls的元类是abc.ABCMeta，就可以使用isinstance(obj, cls)——没理解</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">. 其他信息</span>：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">nonlocal用法（py3中引入，不是局部变量，也不是全局变量）：作用是把变量标记为自由变量；闭包外的变量如果直接用是可以的，但要修改值就不行了(可变类型如list是可以的，数字，字符串，元组等不可变类型只能读取不能更新)，需要使用nonlocal</span>表明：<span style="font-family: georgia, palatina, serif;">如果在闭包内给该变量赋值，修改的是闭包外的那个作用域中的变量</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"> 建议：只在简单的函数中使用这种机制，副作用很难追踪，如果复杂，就将相关的状态封装成辅助类辅助类：参考effective Python p33</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">因为：python不要求声明变量，但是假定在函数体中赋值的变量是局部变量</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果有多个变量，可以连续使用 如：nonlocal a, b</span></div></li><li><div><span style="font-family: georgia;">注意：仅仅是用在闭包中，如果不是在闭包中而是在函数中修改全局变量，需要使用global</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">global：如果在函数中赋值时想让解释器把局部变量当成全局变量，就使用global声明；global的作用就是把局部变量提升为全局变量</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">关于ASCII编码的错误，前加：#--coding:utf-8 --，这样就在脚本中使用了unicode UTF-8编码</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">将单引号或双引号转义（可以打印出来）使用转义符“\&quot;，或者使用三引号，可以在一组三引号之间放入任意多行字符串。三个双引号可以用三个单引号替代</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">单斜线除法执行正常的除法，双斜线除法取整数</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">==和is的区别：</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;"> is判断的是id值，比较对象的标识</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">==：比较两个对象的值</span></div></li><li><div>看以下示例：</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class WTF：</div><div>    pass</div><div>&gt;&gt;&gt;WTF()==WTF()</div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">False</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;WTF() is WTF()</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">False</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;hash(WTF())==hash(WTF())</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">True</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;id(WTF())==id(WTF())</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">True</span></div></div><div><span style="font-size: 11pt; font-family: georgia;">                这是为什么？</span></div><ul style="margin: 0px 8px; padding: 0px 0px 0px 2.2em; max-width: 100%; font-size: 17px; letter-spacing: 0.544px; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff; box-sizing: border-box !important; word-wrap: break-word !important;"><li style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><div style="margin: 16px 0px; padding: 0px; max-width: 100%; box-sizing: border-box; clear: both; min-height: 1em; text-align: left; word-wrap: break-word !important;"><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;">当调用 </span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; border-radius: 3px; background-color: rgba(27, 31, 35, 0.047); letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-variant: normal; line-height: 1.75em;">id</span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;"> 函数时, Python 创建了一个 </span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; border-radius: 3px; background-color: rgba(27, 31, 35, 0.047); letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-variant: normal; line-height: 1.75em;">WTF</span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;"> 类的对象并传给 </span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; border-radius: 3px; background-color: rgba(27, 31, 35, 0.047); letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-variant: normal; line-height: 1.75em;">id</span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;"> 函数。然后 </span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; border-radius: 3px; background-color: rgba(27, 31, 35, 0.047); letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-variant: normal; line-height: 1.75em;">id</span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;"> 函数获取其id值 (也就是内存地址), 然后丢弃该对象。该对象就被销毁了。</span></div></li><li style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><div style="margin: 16px 0px; padding: 0px; max-width: 100%; box-sizing: border-box; clear: both; min-height: 1em; text-align: left; word-wrap: break-word !important;"><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;">当我们连续两次进行这个操作时, Python会将相同的内存地址分配给第二个对象。因为 (在CPython中) </span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; border-radius: 3px; background-color: rgba(27, 31, 35, 0.047); letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-variant: normal; line-height: 1.75em;">id</span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;"> 函数使用对象的内存地址作为对象的id值, 所以两个对象的id值是相同的。</span></div></li><li style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><div style="margin: 16px 0px; padding: 0px; max-width: 100%; box-sizing: border-box; clear: both; min-height: 1em; text-align: left; word-wrap: break-word !important;"><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 1.75em;">综上, 对象的id值仅仅在对象的生命周期内唯一. 在对象被销毁之后, 或被创建之前, 其他对象可以具有相同的id值。</span></div></li></ul><div style="margin: 16px 0px; padding: 0px; max-width: 100%; box-sizing: border-box; clear: both; min-height: 1em; text-align: left; word-wrap: break-word !important;"><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; line-height: 1.75em;">那为什么 </span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; border-radius: 3px; background-color: rgba(27, 31, 35, 0.047); letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; line-height: 1.75em;">is</span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; line-height: 1.75em;"> 操作的结果为 </span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; border-radius: 3px; background-color: rgba(27, 31, 35, 0.047); letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; line-height: 1.75em;">False</span><span style="max-width: 100%; clear: both; min-height: 1em; font-size: 15px; letter-spacing: 0.5px; box-sizing: border-box !important; word-wrap: break-word !important; line-height: 1.75em;"> 呢? 让我们看看这段代码。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class WTF(object):</div><div>  def __init__(self): print(&quot;I&quot;)</div><div>  def __del__(self): print(&quot;D&quot;)</div><div>&gt;&gt;&gt; WTF() is WTF()</div><div>I</div><div>I</div><div>D</div><div>D</div><div>False</div><div>&gt;&gt;&gt; id(WTF()) == id(WTF())</div><div>I</div><div>D</div><div>I</div><div>D</div><div>True</div></div><div><span style="font-size: 11pt; font-family: georgia;">        </span> <span style="font-size: 15px; letter-spacing: 0.5px; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(36, 41, 46); font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-variant: normal; line-height: 29.75px;">正如你所看到的, 对象销毁的顺序是造成所有不同之处的原因</span></div><ul><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">三引号（三个单引号或三双引号）可以实现长字符串跨多行</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">运算符：</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">/：除法，会取到小数点</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">//：除法，只取整数部分</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">在控制台操作中，未命名的可以用‘_’代替，默认赋值给_</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">需要在可迭代对象中分解出n个元素，但这个对象的长度可能超过n，这时候使用 *表达式可用在首，中间，尾，是一个</span><span style="font-size: 15px; font-family: georgia, palatina, serif; font-weight: bold;">列表</span><span style="font-size: 15px; font-family: georgia, palatina, serif;">；</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">测试程序性能：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">轻量级：linux下可以使用 time python3 somepragram.py</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">重量级：需要详细报告，可以使用cProfile模块</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">介于这两者之间：写装饰器包装函数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">使用上下文管理器？——cookbook14.13</span></div></li></ul><div><br clear="none"/></div></div><div><br clear="none"/></div></span>
</div></body></html> 