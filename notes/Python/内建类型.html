<html>
<head>
  <title>内建类型</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="562"/>
<h1>内建类型</h1>

<div>
<span><div><div><div>+和*操作：遵循的规律：不修改原有对象，创建一个全新序列</div><div>一般来说用户自定义的类型都是可哈希的，哈希值就是id值；<span style="color: #ff0000;">如果一个对象实现了__eq__方法，并且在方法中用到了对象的内部状态的话，只有当这些内部状态是不可变的情况下这些对象才是可哈希的。</span></div><div>不要子类化内置类型：直接子类化内置类型容易出错，因为内置类型的方法会忽略用户覆盖的方法，用户应该继承collections模块</div><div>可以替换列表的使用策略：<br clear="none"/></div><ol><li><div><span style="font-family: georgia, palatina, serif;">如果需要一个只包含数字的列表，array的效率高很多</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果要频繁的先进先出操作，deque首选</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">包含操作(比如检查一个元素是否出现在另一个集合中)很频繁，应该是用set，因为set专为检查元素是否存在做过优化</span></div></li></ol><ul><li><div><span style="font-family: georgia, palatina, serif;">列表推导[]：通常只用列表推导来创建新的列表</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">字典推导{}：可以从任何以键值对作为元素的可迭代对象中构建出字典</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">集合推导：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">生成器表达式(): 遵守了迭代器协议，可以逐个产出元素；生成器表达式和列表推导式差不多，只不过把方括号改成圆括号；如果生成器表达式是一个函数调用过程中的唯一参数，则不需要额外再用括号</span></div></li></ul><div><span style="font-family: Georgia;">可迭代元素拆包(fluent2.3)：</span></div><ul><li><div><span style="font-family: Georgia;">平行赋值</span></div></li><li><div><span style="font-family: Georgia;">不使用中间变量交换两个变量的值：a, b = b, a</span></div></li><li><div><span style="font-family: Georgia;">使用*把一个可迭代对象拆开作为函数的参数</span></div></li><li><div><span style="font-family: Georgia;">如果不总是对元组中的所有数据感兴趣，_占位符能帮助处理这种情况</span></div></li><li><div><span style="font-family: Georgia;">在平行赋值中，*只能用在一个变量名前，但这个变量可以出现在赋值表达式的任意位置，如：a, b, *rest = range(5); rest的值为[2,3,4]</span></div></li><li><div><span style="font-family: Georgia;">嵌套元组拆包</span></div></li></ul><div><span style="font-family: Georgia;">对序列使用+和*操作</span></div><div><span style="font-family: georgia, palatina, serif;">使用if或while语句判断真假(True/False):</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">None</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">False</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">0</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">任意空序列，如()或[]</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">任意空字典，如{}</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">自定义类，实现了__bool__()或__len__(), 其返回0或者bool类型的False </span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">Boolean 操作符(和c++有点不一样)：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">x or y：如果x为False，返回y；如果y为False，返回x</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">x and y：如果x为False，返回x，否则返回y</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">not x：如果x为False，返回True，否则返回False</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">安慰操作运算符：仅仅对</span><span style="font-family: georgia, palatina, serif; font-weight: bold; text-decoration: underline;">整数</span><span style="font-family: georgia, palatina, serif;">有意义——字典的</span><span style="font-family: georgia, palatina, serif; text-decoration: underline;">键</span><span style="font-family: georgia, palatina, serif;">，</span><span style="font-family: georgia, palatina, serif; text-decoration: underline;">键值对</span><span style="font-family: georgia, palatina, serif;">也是支持集合操作如|，&amp;，-的</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">按位或：x | y</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">按位与：x &amp; y</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">按位异或: x ^ y: 相同位如果相同为0，不同为1</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">左移/右移：x&lt;&lt;n / x &gt;&gt; n</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">取反：~x</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">分类：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">是否可变：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">可变序列：list，bytearray，memoryview，(其他标准库中的如array.array, collections.deque0)</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">不可变序列：tuple，str，bytes, 数字</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">内存布置：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">容器序列：存放的是所包含的任意类型的对象的引用，list, tuple, collections.deque，存放的可以是不同类型</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">扁平序列：存放的是值而不是引用，str, bytes, bytearray, memoryview, array.array，只能容纳一种类型</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">所有序列支持的方法(x是元素，s为序列)：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">x in s/x not in s</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">+操作</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">切片操作,如果切片最大值超过上限，会取最大值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">len(s)：对字典，返回的是键值对</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">max(s)/min(s)：返回序列中的最大或最小值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.index(): 返回参数指定的元素的下标值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.count(x)：返回x在s中的个数</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">可变序列支持的方法：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">del s[]</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.append(x)：将x添加到序列s<span style="font-family: georgia, palatina, serif; font-weight: bold;">的尾部，原地操作，不返回值</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.clear()：删除序列s中的所有值，相当于<span style="font-family: georgia, palatina, serif; font-weight: bold;">del s[:]</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.remove(x)：删除s中的</span><span style="font-family: georgia, palatina, serif; font-weight: bold; text-decoration: underline;">第一个</span><span style="font-family: georgia, palatina, serif;">x元素，原地操作不返回任何值，如果没有x，该操作抛出ValueError异常，注：字符串不是可变序列，不支持该操作，如果没有x元素则抛出ValueError异常</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.pop([i])：返回并删除位于位置i的元素，和remove的区别很明显：1.pop的参数一个是要删除的元素，remove的参数是下标值；2.返回被删除的值; 默认i=-1, 即删除最后一个元素；原地操作，s为修改后的序列</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.insert(i, x)：在下标值i处插入x元素</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s.reverse()：将序列中的元素反转，<span style="font-family: georgia, palatina, serif; font-weight: bold;">原地操作不返回值</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">s*=n: 将s重复n次，原地修改</span></div></li></ul><div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">切片操作</span>：[start: stop: step], 适用于所有的Python内建类型：切片会返回改变后的序列，原序列并不变</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">[start : end)：取start在内到end但不包括end的范围，start&lt;end的前提是step为正，若为负数，start可以小于end,不管是否为正数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">正向索引从0开始，反向索引最后一个为-1，往前递减</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可以正反同用，start为正向开始，end为反向开始</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果end不写，取到最后一个元素，如果是[-1:]只取最后一个</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">切片操作不会计较start和end索引是否越界</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对list赋值的时候如果使用切片操作，就会把远列表中处在相关范围内的值替换成新值，即使长度不同也可以替换</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;l = list(range(10))</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;l[2:5] = [20, 30]</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;l</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">[0,1,20,30,4,5,6,7,8,9]</span></div></div><ul><li><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">用切片可以复制和反转列表：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>nums = [1,2,3], copy_nums=nums[ : : ], copy_nums=[1, 2, 3]</div><div>copy_nums = nums[::-1], copy_nums=[3, 2, 1]</div></div><ul><li><div><span style="font-family: georgia;">step为负就是反向取值</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>&gt;&gt;&gt;s = 'bicycle'</div><div>&gt;&gt;&gt;s[::-1]</div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">'elcycib'</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;s[ : : -2]</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">'eccb'</span></div></div><ol><li><div><span style="font-family: georgia, palatina, serif;">建议：同一个切片操作内不要使用start，end，stride，如果确实需要：</span></div></li></ol><ol><li><div><span style="font-family: georgia, palatina, serif;">拆解为两条赋值语句，一个做范围切割，另一个做步进切割</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">考虑使用itertools中的slice</span></div></li></ol><div><span style="font-family: georgia, palatina, serif;">大小比较：</span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">列表和元组的比较是按元素顺序比较</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">字典：</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">类型之间的转换：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">list-&gt;dict: 如果list中由两个元素组成的元组(a,b)组成，可以直接dict(list)，否则会报错，其他情况没有试</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">注意事项：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">对元组t来说，t[:]不创建副本，而是返回了一个对象的引用；tuple(t)获得的也是同一个元组的引用，str，bytes，fronzenset也是这种情况(fronzenset实例不是序列，不能使用切片)</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">驻留：字符串和整数如果值相同的话，is值为True，指向同一个地方，是一种优化措施，所以比较字符串或整数是否相等时应该使用==而不是is</span></div></li></ul><ul><li><div><span style="font-family: georgia;">字符串中只包含字母，数字，下划线时会驻留，包含特殊字符如'!'不会驻留</span></div></li></ul><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">NoneType类型</span>：<span style="font-family: georgia, palatina, serif;">type(None)为NoneType</span></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">tuple</span>: 元组的不可变性其实是☞tuple的数据结构的物理内容不可变，与引用的对象无关，即元组的值会随着引用的可变对象的变化而变化，元组中不可变的是元素的标识; 元组的第一特点是记录元素顺序；第二个特点是用作 不可变列表</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">元组没有__reversed__方法</span></div></li><li><span style="font-family: georgia, palatina, serif;">一个问题</span><span style="font-family: georgia, palatina, serif;">：</span></li><li><span style="font-family: georgia, palatina, serif;"><br clear="none"/>a=(1,2,[3,4])</span></li><li><span style="font-family: georgia, palatina, serif;">a[2]+=[5,6] 运行后结果如何？抛出异常但a[2]=[3,4,5,6];得出一个结论：不要在元组中使用列表等可变序列</span></li><li><span style="font-family: georgia, palatina, serif;"> </span><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">t[:]不创建副本，而是返回同一个对象的引用，tuple(t)获得的也是同一个元组的引用</span></li></ul><div><br clear="none"/></div><div><span style="font-size: 18px;"><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">str</span></span><span style="font-family: georgia, palatina, serif;">：字符串</span></div><ul><li><div><span style="font-family: georgia;">str.capitalize(): 返回字符串的副本，以大写字母开头，其余字符小写</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.replace(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">old</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">new</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">count</span><span style="font-family: georgia, palatina, serif;">])：old是str中得一个子字符串，被new替代，count则表示替代得个数，返回新的字符串，原字符串</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">不变</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.find(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">sub</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">start</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">end</span><span style="font-family: georgia, palatina, serif;">]])：如果没有找到返回-1, 找到则返回最近的一个的下标</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.lower()：大写字符转换成小写并返回，非字符不变，返回的是一个拷贝值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.upper():返回的字符串都是大写的，非字符不变，<span style="font-family: georgia, palatina, serif; font-weight: bold;">str本身不变</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.swapcase():大写字母转成小写，小写转成大写</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.join(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">iterable</span><span style="font-family: georgia, palatina, serif;">)：这个方法的目的是把参数指定的序列或可迭代对象按指定的分割字符连接在一起，iteratable中的值都</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">必须是str类型, 可以使用生成器表达式,如果你准备编写构建大量小字符串的输出代码， 你最好考虑下使用生成器函数，利用yield语句产生输出片段；另外，相比于'+',join方法更好用，因为每次加都会申请一块新的内存，然后复制内容；join在计算时会先计算需要多大内存，然后一次性申请并将内容复制过去</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">&gt;&gt;&gt; parts=['Is', 'Chicago', 'Not', 'Chicago']</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">&gt;&gt;&gt; ' '.join(parts)</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">'Is Chicago Not Chicago'</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">&gt;&gt;&gt; ','.join(parts)</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">'Is,Chicago,Not,Chicago'</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;"># 生成器表达式</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">&gt;&gt;&gt; data = ['ACME', 50, 91.1]</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">&gt;&gt;&gt; ','.join(str(i) for i in data)</span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">str.startswith(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">prefix</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">start</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">end</span><span style="font-family: georgia, palatina, serif;">]])：以prefix字符串/元组中的值 开头则返回True，否则返回False</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.endswith(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">suffix</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">start</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">end</span><span style="font-family: georgia, palatina, serif;">]])：类似上</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">import os</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">filenames = os.listdir('.')</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">## filenames输出为当前文件夹下文件，比如：1.txt, 2.py, 3.js</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">[name for name in filenames if name.endswith(('txt', 'py'))</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">&gt;&gt;&gt;['1.txt', '2.py']</span></div><div><br clear="none"/></div></div></div><ul><li><div><br clear="none"/></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.format(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">*args</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">**kwargs</span><span style="font-family: georgia, palatina, serif;">)：参数替代str中'{}'出现的地方, format的格式比较多,所有的示例在6.1.3.2中都有:</span></div><div><span style="font-family: georgia, palatina, serif;">str.format_map(mapping)：直接用mapping而不是字典作为参数？参数可以是一个字典或字典的子类，str中{xx}的xx会映射到mapping中的xx</span></div></li><li><div>输出：</div><div><span style="font-family: georgia, palatina, serif;">格式控制：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">通过位置参数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">通过关键字参数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">通过对象属性</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">通过下标</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">使用&quot;!r&quot;和&quot;!s&quot;替代%r和%s, %r(用repr()方法处理)</span></div></li><li><div><br clear="none"/></div></li><li><div><span style="font-family: georgia, palatina, serif;">替代&quot;%d&quot;,&quot;%x&quot;等输出2/8/10/16进制的数据</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; class Default(dict):</span></div><div><span style="font-family: georgia, palatina, serif;">          def _missing_(self, key):</span></div><div><span style="font-family: georgia, palatina, serif;">               return key</span></div><div><span style="font-family: georgia, palatina, serif;">&gt;&gt;&gt; '{name} is born in {country}'.format_map(Default(name='Guido'))</span></div><div><span style="font-family: georgia, palatina, serif;">'Guido is born in country'</span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">删除：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.strip</span>([<span style="font-family: georgia, palatina, serif; font-style: italic;">chars</span><span style="font-family: georgia, palatina, serif;">])：从头尾删除，如果没有参数则删除空格；这个方法会从两边删除参数包含的字符直到第一个没有包括在参数中的字符，不会对字符串中间的任何文本起作用，返回删除后的字符串</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.rstrip</span>([<span style="font-family: georgia, palatina, serif; font-style: italic;">chars</span><span style="font-family: georgia, palatina, serif;">])：从右边删除</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.lstrip</span>([<span style="font-family: georgia, palatina, serif; font-style: italic;">chars</span><span style="font-family: georgia, palatina, serif;">])：从左边删除集合中包含的字符，如果左边第一个不是参数指定的字符，删除不了，例如：‘abcdefg’.lstrip('ba')是可以删除a和b的，但‘abcdefg’.lstrip('bc')删除不了，返回改变后的字符串，原字符串不变</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对齐：应该优先使用format</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.ljust</span>(<span style="font-family: georgia, palatina, serif; font-style: italic;">width</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">fillchar</span><span style="font-family: georgia, palatina, serif;">])：返回按所给定的长度width按fillchar指定的字符从左对齐的字符串，fillchar默认为空格，如果width小于str则返回原长度的字符串</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.rjust</span>(<span style="font-family: georgia, palatina, serif; font-style: italic;">width</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">fillchar</span><span style="font-family: georgia, palatina, serif;">])：同上，从右对齐</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.center</span>(<span style="font-family: georgia, palatina, serif; font-style: italic;">width</span><span style="font-family: georgia, palatina, serif;">[,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">fillchar</span><span style="font-family: georgia, palatina, serif;">])：字符串会居中，两边以默认的空格或给定的字符填充</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.split(sep=NONE, maxsplit=-1)：join的逆方法，按sep分割，默认为空格，以列表形式返回，maxsplit为要分割的个数。这个方法不支持多个分隔符的情况，如多分割符，应用re.split</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.title():返回的字符串中的第一个字母大写，<span style="font-family: georgia, palatina, serif; font-weight: bold;">通过空格，数字等非字符区分字符串的开始</span></span></div></li><li><div><span style="font-size: 14px; font-family: georgia, palatina, serif;">str.isalpha():不为空且所有的字符都是字母返回真</span></div></li><li><div><span style="font-size: 14px; font-family: georgia, palatina, serif;">str.isallnum(): ??</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.isdigit():不为空且所有字符都是数字返回真，否则为false</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.islower()/isupper():不为空且所有字符都是小写/大写，否则为false</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.isspace():不为空且所有字符都是空的</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">static str.maketrans(x,[,y[,z]])：这个方法返回一个转换表给str.translate()使用。</span></div><div><span style="font-family: georgia, palatina, serif;">str.translate(table)：按给定的转换表table转换字符串，返回拷贝值。目前table可以是maketrans的返回值，字典没有效果，sequence也没测试。<span style="font-size: 15px; font-family: georgia, palatina, serif;">类似于replace，不同的是，replace只处理单个字符，translate的优势在于可以同时进行多个替换；先使用string模块中的maketrans完成转换表，转换表中是以某字符替换某字符的对应关系，再使用translate进行转换；maketrans函数接受两个参数：两个等长的字符串，第二个字符串替换第一个字符串</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">一个参数：必须是一个字典，返回转换成ascii的映射</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">两个参数：必须是两个相等的字符串，会转换成ascii映射的字典</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">三个参数：必须都是字符串，前两个同上，第三个映射值为None</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">str.</span><span style="font-family: georgia, palatina, serif;">encode</span><span style="font-family: georgia, palatina, serif;">(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">encoding=&quot;utf-8&quot;</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">errors=&quot;strict&quot;</span><span style="font-family: georgia, palatina, serif;">)：返回一个bytes类型的对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">其他操作：如果想在源码中把两个字面字符串合并起来都不需要+，只需要放在一起。如‘hello''world'会成为'helloworld'</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">在需要比较字符串的操作中使用字符的多种表示会产生问题，可以使用unicodedata模块先将文本标准化：unicodedata.normalize(form, unistr)</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">注意：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">使用‘+’连接大量字符串时是非常低效的，因为加号会引起内存复制及垃圾回收操作。最好是先收集所有的字符串片段然后再将它们连接起来；使用join会比较好，最好是用生成器表达式</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">参数：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">errors：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">ignore：处理方式为跳过无法编码的字符</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">replace：把无法编码的字符替换成了‘？’</span><span style="font-family: georgia, palatina, serif;">     </span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">异常：编码错误抛出UnicodeEncodeError</span></div></li><li><div><span style="font-family: georgia;">技巧：</span></div></li></ul><ul><li><div><span style="font-family: georgia;">字符串格式化：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>&gt;&gt;&gt; lang = 'python'</div><div>&gt;&gt;&gt; f'{lang} is most popular language in the world'</div><div>'python is most popular language in the world'</div></div><div><div><span style="font-family: georgia, palatina, serif;"><span style="font-size: 18px;"><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">bytes</span></span>：字节类型，二进制对象，bytes或bytearray对象的各个元素是介于0-255之间的整数</span></div><div><span style="font-family: georgia, palatina, serif;">说明：</span></div><ol><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff; float: none; color: #333333; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">Bytes 对象是由单个字节作为基本元素（8位，取值范围 0-255）组成的序列，为不可变对象。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">Python3中最重要的特性就是将文本和二进制数据做了更清晰的区分，文本总是以str表示, str为Unicode格式，二进制数据总是以bytes表示</span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff; float: none; color: #333333; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">在python3中，不能以任何隐式方式将str和bytes类型二者混合使用。</span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff; float: none; color: #333333; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">Bytes 对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff; float: none; color: #333333; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">编码是一种用二进制数据表示抽象字符的方式</span></div></li><li><div><span style="background-color: #ffffff; color: #333333; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">字符串和字节符之间划分界线是必然的。</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff; float: none; color: #333333; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">str可以被编码(encode)成字bytes,bytes也可以解码(decode)成strings</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">内建函数bytes可以将str类型转换成bytes类型，需要指明参数encoding的值；如果要把bytes类型转换成str，需要使用方法encode，返回一个str</span></div></li></ol><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; letter-spacing: normal; margin: 0px; min-height: auto; orphans: 2; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; text-indent: 0px; text-transform: none; top: auto; vertical-align: baseline; -webkit-text-stroke-width: 0px; white-space: nowrap; widows: 2; width: auto; word-spacing: 0px; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">&gt;&gt;&gt; s </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; letter-spacing: normal; margin: 0px; min-height: auto; orphans: 2; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; text-indent: 0px; text-transform: none; top: auto; vertical-align: baseline; -webkit-text-stroke-width: 0px; white-space: nowrap; widows: 2; width: auto; word-spacing: 0px; background-color: #fbfaf8; bottom: auto; color: #006699; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">=</span><span style="font-size: 12px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgba(234, 239, 242, 0.247); float: none; color: #333333; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;"> </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; letter-spacing: normal; margin: 0px; min-height: auto; orphans: 2; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; text-indent: 0px; text-transform: none; top: auto; vertical-align: baseline; -webkit-text-stroke-width: 0px; white-space: nowrap; widows: 2; width: auto; word-spacing: 0px; background-color: #fbfaf8; bottom: auto; color: blue; font-family: georgia, palatina, serif; font-style: normal; font-weight: 400;">&quot;中文&quot;</span></div><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&gt;&gt;&gt; </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #ff1493; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">type</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">(s)</span></div><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&lt;</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #006699; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">class</span><span style="font-size: 12px; background-color: #fbfaf8; color: #333333; font-family: georgia, palatina, serif;"> </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: blue; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">'str'</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&gt;</span></div><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&gt;&gt;&gt; b </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #006699; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">=</span><span style="font-size: 12px; background-color: #fbfaf8; color: #333333; font-family: georgia, palatina, serif;"> </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">bytes(s, encoding</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #006699; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">=</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: blue; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">'utf-8'</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">)</span></div><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&gt;&gt;&gt;b</span></div><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">b</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: blue; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">'\xe4\xb8\xad\xe6\x96\x87'     ## 使用utf-8编码后一个汉字三个字节</span></div><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&gt;&gt;&gt; </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #ff1493; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">type</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">(b)</span></div><div><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&lt;</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #006699; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">class</span><span style="font-size: 12px; background-color: #fbfaf8; color: #333333; font-family: georgia, palatina, serif;"> </span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: blue; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">'bytes'</span><span style="font-size: 12px; background-image: none; border: 0px; border-radius: 0px; box-sizing: content-box; float: none; height: auto; left: auto; margin: 0px; min-height: auto; outline: 0px; overflow: visible; padding: 0px; position: static; right: auto; text-align: left; top: auto; vertical-align: baseline; white-space: nowrap; width: auto; background-color: #fbfaf8; bottom: auto; color: #000000; font-family: georgia, palatina, serif; font-style: normal; font-weight: normal;">&gt;</span></div></div><div><span style="font-family: georgia, palatina, serif;">    7. 字节字符串支持大部分和文本字符串一样的内置操作如拆分，搜索，替换字节串都支持，但如果用到了正则表达式，正则表达式本身也必须是字节串，且用'b'替换成‘r’，如下：</span></div><div><span style="font-family: georgia, palatina, serif;">         data = b'FOO:BAR,SPAM'</span></div><div><span style="font-family: georgia, palatina, serif;">          import re</span></div><div><span style="font-family: georgia, palatina, serif;">          re.split('[:,]', data)     # 这样会报错</span></div><div><span style="font-family: georgia, palatina, serif;">          re.split(b'[:,]', data)     # 这样就可以</span></div><div><span style="font-family: georgia, palatina, serif;">  但也有一些需要注意的地方：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">字节串的索引操作返回整数而不是单独的字符串</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">要想把字节串打印出来显示成文本串需要解码decode</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">不存在适用于字节串的格式化操作，要想格式化，先解码，在编码encode成字节串</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">方法：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;):如果解码错误，抛出异常UnicodeDecodeError</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">errors:ignore; replace</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">疑问：</span></div><ol><li><div><span style="font-family: georgia, palatina, serif;">网络传输的时候为什么必须是字节？</span></div></li></ol><div><span style="font-family: georgia, palatina, serif;"><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">bytearray</span>：没有字面量句法，而是以bytearray()和字节序列字面量</span></div><div><span style="font-family: georgia, palatina, serif;">bytearray对象的切片还是bytearray对象</span></div><div><div><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">list：列表</span></div><div style="font-size: 16px;"><span style="font-size: 16px; font-family: georgia, palatina, serif;">class list([iterable])</span></div><ul style="font-size: 16px;"><li><div><span style="font-size: 16px; font-family: georgia, palatina, serif;">sort(</span><span style="font-size: 16px; font-family: georgia, palatina, serif; font-style: italic;">*</span><span style="font-size: 16px; font-family: georgia, palatina, serif;">,</span> <span style="font-size: 16px; font-family: georgia, palatina, serif; font-style: italic;">key=None</span><span style="font-size: 16px; font-family: georgia, palatina, serif;">,</span> <span style="font-size: 16px; font-family: georgia, palatina, serif; font-style: italic;">reverse=None</span><span style="font-size: 16px; font-family: georgia, palatina, serif;">)：直接在原处进行修改而不返回任何值，不同于内建函数sorted会返回值而原值不变</span></div></li><li><div><span style="font-size: 16px; font-family: georgia, palatina, serif;">key参数可以是带一个参数的函数，该函数作用于列表中的每一个函数</span></div></li><li><div><span style="font-size: 16px; font-family: georgia, palatina, serif;">copy()：对列表进行浅复制</span></div></li><li><div><span style="font-size: 16px; font-family: georgia, palatina, serif;">可以直接进行相加操作</span></div></li><li><div><span style="font-size: 12pt; font-family: georgia;">建立由列表组成的列表，看下面两种情况有什么不同——？：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div># 第一种情况</div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;board=[ ['_'] * 3 for i in range(3) ]</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;board</span></div><div>[ [  '_',  '_',  '_' ], [ '_', '_', '_'], [ '_', '_', '_']]</div><div>&gt;&gt;&gt;board[1][2] = 'x'</div><div>[ [  '_',  '_',  '_' ], [ '_', '_', 'x'], [ '_', '_', '_']]</div><div># 第二种情况</div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;weird = [ [ ' _' * 3 ] ] * 3</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">&gt;&gt;&gt;weird</span></div><div>[ [  '_',  '_',  '_' ], [ '_', '_', '_'], [ '_', '_', '_']]</div><div>&gt;&gt;&gt;weird[1][2] = 'x'</div><div>[ [  '_',  '_',  'x' ], [ '_', '_', 'x'], [ '_', '_', 'x']]</div><div><br clear="none"/></div><div>第一种情况相当于：没次迭代中都创建一个新的列表添加到board中</div><div>board=[]</div><div>for i in range(3):</div><div>    row = ['_']*3</div><div>    board.append(row)</div><div>第二种情况相当于：追加同一行的对象到列表中</div><div>board = []</div><div>row = ['_']*3</div><div>for i in range(3):</div><div>    board.append(row)</div></div><div style="font-size: 16px;"><span style="font-size: 16px; font-family: georgia, palatina, serif;">    <span>    解释如下：</span></span></div><div style="font-size: 16px;"><span style="font-size: 16px; font-family: georgia, palatina, serif;"><span><span>    </span><span>    weird中不是创建一个包含三个'_'的列表，而是创建了一个包含对同一个列表三次引用的列表，所以只对其中一个改变其他的也会改变</span><br clear="none"/></span></span></div><div style="font-size: 16px;"><span style="font-size: 16px; font-family: georgia, palatina, serif;"><span>    </span>注：</span></div></div><ol><li><div><span style="font-family: georgia, palatina, serif;">列表不支持find方法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">在闭包中能操作列表但不能操作数字类型变量是因为列表是可变的对象（FluentPython7.6）</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">删除列表的第一个元素或者在第一个位置处添加元素是很耗时的，因为要移动整个列表里的元素，这种情况下可以选择collections中的deque</span></div></li><li><span style="font-family: georgia, palatina, serif;">构造方法或[:]做的是浅复制</span></li></ol><div><br clear="none"/></div><div><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">dict</span><span style="font-family: georgia, palatina, serif;">：</span><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典是python唯一内建的映射序列；</span><span style="font-family: georgia, palatina, serif;">字典也支持集合操作；</span></div><div><span style="font-family: georgia, palatina, serif;">字典的特点：</span></div><ol><li><span style="font-family: georgia, palatina, serif;">键必须是可哈希的</span></li><li><span style="font-family: georgia, palatina, serif;">字典在内存上开销巨大，所以用元组或具名元组代替；在自定义类型中，__slots__属性可以改变实例属性的存储方式，由dict变成tuple</span></li><li><span style="font-family: georgia, palatina, serif;">键查询很快，dict的实现是典型的空间换时间，提供了无视数据量大小的快速访问</span></li><li><span style="font-family: georgia, palatina, serif;">往字典中添加新键可能会改变已有键的顺序，由此可知，不要对字典同时进行迭代和修改</span></li></ol><div><span style="font-family: georgia, palatina, serif;">keys()：返回字典的key,返回的是dict_keys的可迭代类型</span></div><div><span style="font-family: georgia, palatina, serif;">values()：（</span><span style="font-family: georgia, palatina, serif; text-decoration: line-through;">以列表形式）</span><span style="font-family: georgia, palatina, serif;">返回字典的所有value，返回的是dict_value的类型</span></div></div><div><span style="font-family: georgia, palatina, serif;">items()：以(key, value)的形式返回字典对，即以列表形式返回元组对</span></div><div><span style="font-family: georgia, palatina, serif;">特殊方法：__missing__：会设置由key对应的默认的value，defaultdict会使用到这个属性——如果某个键在映射里不存在，但希望通过这个键能获取到一个默认值的话，有两个途径达到这个目标：使用default；定义一个dict子类，在子类中实现__missing__方法</span></div><div><span style="font-family: georgia, palatina, serif;">如果要自定义映射类型，最合适的策略是继承Collections.UserDict</span></div><div><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典函数：</span></div><ol><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">dict：使用该方法通过其他映射或（键，值）这样的序列建立字典；也可以使用关键字参数来创建字典</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">len（d）：返回字典中的项（键值对）的数量</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">d[k]：返回关联到键k上的值</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">d[k]=v：将值v关联到键k上</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">del d[k]：删除键为k的项（整个键值对都删除）</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">key in d/key not in d：检查d中是否有键为key的项（查找的是键而不是值）</span></div></li></ol><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典方法：</span></div><ul><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">clear()：清楚字典中的所有项，原地操作无返回值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">copy：返回一个具有相同键值对的新字典——这一方法实现的是浅复制，值本身是相同的，</span><span style="font-family: georgia, palatina, serif; font-style: italic; text-decoration: underline;">而不是副本</span><span style="font-family: georgia, palatina, serif;">。当在副本中替换值的时候原始字典不受影响；但如果修改了某个值，原始字典也会改变，避免这个问题的一种方法就是深复制-deepcopy方法来完成。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; color: #e30000;">deepcopy</span>：该函数为copy模块，from copy import deepcopy</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">fromkeys(seq[,value])：这是字典的class method，使用给定的键（在序列seq中）建立新的字典，如果不提供默认值value，每个键默认对应的值为None；返回一个由seq为key的新的字典，注意这个方法的参数，元组和列表使用方式不同，字典键值不同.</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">value值貌似是单一的，即所有的key只能对应一个value，参考下例：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">## 在给定的已存在item的字典中再加入是不成功的</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">a={'a':1,'b':2}</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">b={'c':3,'d':4}</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">a.fromkeys(b.keys(),b.values())</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;"># a的值没有变化，但返回为{'c':dict_values([3,4]),'d':dict_values([3,4])}</span></div></div></div><div><br clear="none"/></div><ul><li><div><span style="font-family: georgia, palatina, serif;">get(key[,default])：更宽松的访问字典的方法：访问一个不存在的键时得到None值，还可以自定义默认值替换None；并不是处理找不到的键的最好的方法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">items()：该方法将所有字典项以列表中(key, value)元组的形式返回，这些列表项中的每一项都来自于（键，值），但是项在返回时并没有特殊顺序</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; color: #4f009a;">iteritems</span>：在python3中去掉了。与items作用大致相同，但会返回一个迭代器对象而不是列表；在很多情况下使用该方法更有效</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">keys和</span><span style="color: #4f009a; font-family: georgia, palatina, serif;">iterkeys</span><span style="font-family: georgia, palatina, serif;">：keys将字典中的键以dict_keys（也不是列表，暂时不清楚是什么类型）的形式返回，iterkeys在python3中去掉了。本返回针对键的迭代器</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">pop(key[, default])：返回参数指定键的值，然后将这个键值对从字典中删除; 如果不存在key返回default值；如果key不存在，default又没有指定，抛出KeyError</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">popitem：删除字典的随机项，并将此键，值对作为</span><span style="font-family: georgia, palatina, serif; text-decoration: underline;">元组</span><span style="font-family: georgia, palatina, serif;">返回</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">dict.setdefault(key,[,default])：如果key存在于dict中，不做任何操作直接返回对应于key的value，如果不存在，则插入key，对应于key的值为default，default默认为None，</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">返回default（可以在返回值上做操作）</span><span style="font-family: georgia, palatina, serif;">。如果key中有重复的字符或数字，</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">只取一个</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; color: #000000;">update([other])</span>：利用一个字典项更新另外一个字典，</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">参数可以是一个字典，也可以是一个key/values的键值对</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">重写已存在的key</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">返回为None</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">values / itervalues：将字典中的值以dict_values的</span><span style="font-family: georgia, palatina, serif; text-decoration: underline;">列表</span><span style="font-family: georgia, palatina, serif;">形式返回，python3中无itervalues</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">提供的字典中的项会被添加到旧的字典中，若有相同的键则会将其值覆盖；注意覆盖后的顺序</span></div></li><li><div><span style="color: #0000ff; font-family: georgia, palatina, serif;">参数还可以是一个可迭代对象</span><span style="font-family: georgia, palatina, serif;">，</span><span style="font-family: georgia, palatina, serif; text-decoration: underline;">但只在用列表元组成员的时候才成功过，直接使用元组抛出异常</span><span style="font-family: georgia, palatina, serif;">？</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">参数类似为：d={'c':3} d.update(a=1, b=2) 后，d={'a':1, 'b':2, 'c':3}</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">注意与collections中ChainMap的区别：ChainMap不修改原来的字典但在原子典中做修改；update会更新原字典</span></div></li></ul><div><div style="font-size: 14px;"><span style="font-size: 15px; font-family: georgia, palatina, serif;">其他：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">关于字典的</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">键</span><span style="font-family: georgia, palatina, serif;">有一个很少人知道的属性，那就是支持常见的集合操作：交集，并集，差集，items也是支持的，但values()不支持。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果尝试在字典上执行常见数据操作，会发现只处理键不处理值，可以利用内建函数zip倒转，然后进行操作</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">prices = {'ACME':45.23,</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">          'AAPL':612.78,</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">          'IBM':205.55,</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">          'HPQ':37.30,</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">          'FB':10.75 }</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;"># 通过价格value找出最小</span></div><div><span style="background-color: #fbfaf8; font-size: 12px; color: #333333; font-family: georgia, palatina, serif;">min_price = min(zip(prices.values(), prices.keys())</span></div></div><ul><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典可以将值关联到空字典的新创建的键上</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">迭代for循环默认迭代key值序列</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典是可变的，可以添加或删除键值对</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典的键不能修改</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">键可以为任何不可变类型（可哈希的）：数字，字符串，甚至是元组，使用元组做字典的键要加以限制：元组中只能包含数字和字符串这样的不可变参数</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典中的键是唯一的，而值不是唯一的；</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典中没有顺序的概念</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">字典的格式化字符串：在每个转换说明符的%字符后面，加上圆括号括起来的键，后面再跟上其他说明元素，可以得到对应键的值</span></div></li><li><div><span style="font-size: 15px; font-family: georgia, palatina, serif;">在字典中检查键的成员资格比在列表中检查值得成员资格更高效</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">使用技巧：</span></div></li></ul><ul><li><div><span style="font-size: 11pt; font-family: georgia;">合并两个字典：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>x={'a':1,'b':2}</div><div>y={'c':3,'d':4}</div><div>z = {**x, **y}</div><div>z的值为{'a': 1, 'b': 2, 'c': 3, 'd': 4}</div></div><ul><li><div>用字典代替if else：</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>def fun(x):</div><div>   if x == 'a':</div><div>       return 1</div><div>   elif x == 'b':</div><div>       return 2</div><div>   else:</div><div>       return None</div><div><br clear="none"/></div><div>def fun(x):</div><div>   return {&quot;a&quot;: 1, &quot;b&quot;: 2}.get(x)</div></div><ul><li><div><span style="font-size: 11pt; font-family: georgia, palatina, serif;">使用以下代码：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div>&gt;&gt;&gt;some_dict={}</div><div>&gt;&gt;&gt;some_dict[5.0]='java'</div><div>&gt;&gt;&gt;some_dict[5]='python'</div><div>&gt;&gt;&gt;some_dict[5.0]</div><div>'python'</div></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">    </span><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">    </span><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">    </span><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">   </span> <span style="font-size: 11pt; font-family: georgia, palatina, serif;">这是为什么？</span></span></div><ul><li><div><span style="font-size: 11pt; font-family: georgia, palatina, serif;">python字典通过检查键值是否相等和比较</span><span style="font-size: 11pt; font-family: georgia, palatina, serif; font-weight: bold;">哈希值</span><span style="font-size: 11pt; font-family: georgia, palatina, serif;">来确定两个键是否相等</span></div></li><li><div><span style="font-size: 11pt; font-family: georgia;">具有相同的l两个不可变对象在python中始终j具有相同的哈希值：hash(5.0)==hash(5)</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-size: 18px;"><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">set/frozenset(可变/不可变)</span></span>：集合，集合的特点是集合中的元素都是唯一的，因此集合可以用于去重；集合中的元素必须是可哈希的；不可变集合是无序排列的可哈希的值(可变集合不是)，集合成员可以做字典中的键；集合用{}表示</span></div><div><span style="font-family: georgia, palatina, serif;">集合操作符及内建方法：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">in/not in</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">==/!=/&gt;/&gt;=/&lt;/&lt;=：集合的等价和不等价与集合类型及集合成员的顺序无关</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">add(elem)：将元素elem添加到</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">discard(elem): 如果元素存在就从集合中删除</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">clear(): 清除集合中的元素</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">update(*other)：更新set，从other中添加元素到set。这个方法和add有什么区别？</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">注意：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">集合被创建的唯一方法：set/frozenset，如果写成{}就是空字典</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">因为集合本身是无序的，所以不可以为集合创建索引或切片操作</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">不关心元素的顺序</span></div></li><li><span style="font-family: georgia, palatina, serif;">frozenset只接受可哈希类型</span></li></ul><div><span style="font-family: georgia, palatina, serif;">使用场景：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">去重（如：列表去重）</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">关系测试（如：取交集、取并集、取差集等）如集合a，b，a|b返回的是合集，a&amp;b得到的是交集，a-b得到的是差集</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">特点：</span></div><ol><li><span style="font-family: georgia, palatina, serif;">集合中的元素必须是可哈希的</span></li><li><span style="font-family: georgia, palatina, serif;">集合很消耗内存</span></li><li><span style="font-family: georgia, palatina, serif;">可以很高效的判断元素是否存在于集合中</span></li><li><span style="font-family: georgia, palatina, serif;">元素的次序取决于被添加到集合里的次序</span></li><li><span style="font-family: georgia, palatina, serif;">往集合中添加元素可能会改变集合里已有元素的次序</span></li></ol><div><span style="font-family: georgia, palatina, serif;"><span style="font-size: 18px; font-family: georgia, palatina, serif; font-weight: bold;">问题集合</span>：</span></div><ol><li><div><span style="font-family: georgia, palatina, serif;">如果想让一个序列不包含另一个序列的所有元素，该怎么处理？如a=[1,2,3,4,5],b=[2,3,0,9],a中去掉包含b的元素</span></div></li></ol></div><div><br clear="none"/></div></div><div><br clear="none"/></div></span>
</div></body></html> 