<html>
<head>
  <title>HTTP简介</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="772"/>
<h1>HTTP简介</h1>

<div>
<span><h1><span style="font-size: 14px;">HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</span><br clear="none"/></h1><div><p><span>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</span></p><p><span>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</span></p><p><span>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</span></p><div><span><img src="HTTP简介_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg"/></span><br clear="none"/><div><span>http请求-响应模型.jpg</span></div></div><h1><span>主要特点</span></h1><p><span>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</span></p><p><span>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</span></p><p><span>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</span></p><p><span>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</span><br clear="none"/><span>5、支持B/S及C/S模式。</span></p><h1><span>HTTP之URL</span></h1><p><span>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</span></p><p><span>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</span></p><h4><span><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" shape="rect" target="_blank">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></span></h4><p><span>从上面的URL可以看出，一个完整的URL包括以下几部分：</span><br clear="none"/><span>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</span></p><p><span>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</span></p><p><span>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</span></p><p><span>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</span></p><p><span>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</span></p><p><span>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</span></p><p><span>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</span></p><p><span>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219" shape="rect" target="_blank">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</span></p><h1><span>URI和URL的区别</span></h1><h5><span>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</span></h5><p><span>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</span><br clear="none"/><span>URI一般由三部组成：</span><br clear="none"/><span>①访问资源的命名机制</span><br clear="none"/><span>②存放资源的主机名</span><br clear="none"/><span>③资源自身的名称，由路径表示，着重强调于资源。</span></p><h5><span>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</span></h5><p><span>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</span><br clear="none"/><span>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</span><br clear="none"/><span>①协议(或称为服务方式)</span><br clear="none"/><span>②存有该资源的主机IP地址(有时也包括端口号)</span><br clear="none"/><span>③主机资源的具体地址。如目录和文件名等</span></p><h5><span>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</span></h5><p><span>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</span></p><p><span>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</span><br clear="none"/><span>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。</span><br clear="none"/><span>相反的是，URL类可以打开一个到达资源的流。</span></p><h1><span>HTTP之请求消息Request</span></h1><p><span>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</span></p><h5><span>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</span></h5><p><br clear="none"/><br clear="none"/></p><div><span><img src="HTTP简介_files/Image.png" type="image/png" data-filename="Image.png"/></span><br clear="none"/><div><span>Http请求消息结构.png</span></div></div><ul><li><span>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</span></li></ul><h5><span>Get请求例子，使用Charles抓取的request：</span></h5><pre xml:space="preserve"><span><code>GET /<span>562f25980001b1b106000338.jpg HTTP/<span>1.1
Host    img.mukewang.com
User-Agent    Mozilla/<span>5.0 (Windows NT <span>10.0; WOW64) AppleWebKit/<span>537.36 (KHTML, like Gecko) Chrome/<span>51.0<span>.2704<span>.106 Safari/<span>537.36
Accept    image/webp,image<span>/*,*/*;q=<span>0.8
Referer    http:<span>//www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=<span>0.8</span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><h5><span>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</span></h5><p><span>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</span></p><h5><span>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</span></h5><p><span>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</span></p><h5><span>第三部分：空行，请求头部后面的空行是必须的</span></h5><p><span>即使第四部分的请求数据为空，也必须有空行。</span></p><h5><span>第四部分：请求数据也叫主体，可以添加任意的其他数据。</span></h5><p><span>这个例子的请求数据为空。</span></p><h5><span>POST请求例子，使用Charles抓取的request：</span></h5><pre xml:space="preserve"><span><code>POST / HTTP1<span>.1
Host:www.wrox.com
User-Agent:Mozilla/<span>4.0 (compatible; MSIE <span>6.0; Windows NT <span>5.1; SV1; .NET CLR <span>2.0<span>.50727; .NET CLR <span>3.0<span>.04506<span>.648; .NET CLR <span>3.5<span>.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:<span>40
Connection: Keep-Alive

name=Professional%<span>20Ajax&amp;publisher=Wiley</span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><p><span>第一部分：请求行，第一行明了是post请求，以及http1.1版本。</span><br clear="none"/><span>第二部分：请求头部，第二行至第六行。</span><br clear="none"/><span>第三部分：空行，第七行的空行。</span><br clear="none"/><span>第四部分：请求数据，第八行。</span></p><h1><span>HTTP之响应消息Response</span></h1><p><span>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</span></p><h5><span>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</span></h5><p><span> </span></p><div><span><img src="HTTP简介_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg"/></span><br clear="none"/><div><span>http响应消息格式.jpg</span></div></div><p><span><strong>例子</strong></span></p><pre xml:space="preserve"><span><code>HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<span>&lt;<span>html&gt;
      <span>&lt;<span>head&gt;<span>&lt;/<span>head&gt;
      <span>&lt;<span>body&gt;
            <span>&lt;!--body goes here--&gt;
      <span>&lt;/<span>body&gt;
<span>&lt;/<span>html&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><h5><span>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</span></h5><p><span>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</span></p><h5><span>第二部分：消息报头，用来说明客户端要使用的一些附加信息</span></h5><p><span>第二行和第三行为消息报头，</span><br clear="none"/><span>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</span></p><h5><span>第三部分：空行，消息报头后面的空行是必须的</span></h5><h5><span>第四部分：响应正文，服务器返回给客户端的文本信息。</span></h5><p><span>空行后面的html部分为响应正文。</span></p><h1><span>HTTP之状态码</span></h1><p><span>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</span></p><h6><span>1xx：指示信息--表示请求已接收，继续处理</span></h6><h6><span>2xx：成功--表示请求已被成功接收、理解、接受</span></h6><h6><span>3xx：重定向--要完成请求必须进行更进一步的操作</span></h6><h6><span>4xx：客户端错误--请求有语法错误或请求无法实现</span></h6><h6><span>5xx：服务器端错误--服务器未能实现合法的请求</span></h6><p><span>常见状态码：</span></p><pre xml:space="preserve"><span><code><span>200 OK                        <span>//客户端请求成功
<span>400 Bad Request               <span>//客户端请求有语法错误，不能被服务器所理解
<span>401 Unauthorized              <span>//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
<span>403 Forbidden                 <span>//服务器收到请求，但是拒绝提供服务
<span>404 Not Found                 <span>//请求资源不存在，eg：输入了错误的URL
<span>500 Internal Server Error     <span>//服务器发生不可预期的错误
<span>503 Server Unavailable        <span>//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><p><span>更多状态码<a href="http://www.runoob.com/http/http-status-codes.html" shape="rect" target="_blank">http://www.runoob.com/http/http-status-codes.html</a></span></p><h1><span>HTTP请求方法</span></h1><p><span>根据HTTP标准，HTTP请求可以使用多种请求方法。</span><br clear="none"/><span>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br clear="none"/><span>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span></p><pre xml:space="preserve"><span><code>GET     通过URL网址传递信息，可以直接在URL中写上要传递的信息，也可以由表单进行传递，如果使用表单进行传递，表单中的信息会自动转换为URL地址中的数据。
HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。
<span><span>DELETE      请求服务器删除指定的页面。
<span>CONNECT     <span>HTTP/<span>1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS     允许客户端查看服务器的性能。
<span>TRACE     回显服务器收到的请求，主要用于测试或诊断。</span></span></span></span></span></span></code></span></pre><h1><span>HTTP工作原理</span></h1><p><span>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</span></p><p><span>以下是 HTTP 请求/响应的步骤：</span></p><h6><span>1、客户端连接到Web服务器</span></h6><p><span>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./" shape="rect" target="_blank">http://www.oakcms.cn。</a></span></p><h6><span>2、发送HTTP请求</span></h6><p><span>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</span></p><h6><span>3、服务器接受请求并返回HTTP响应</span></h6><p><span>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</span></p><h6><span>4、释放连接<a href="http://www.jianshu.com/p/ef892323e68f" shape="rect" target="_blank">TCP连接</a></span></h6><p><span>若connection 模式为close，则服务器主动关闭<a href="http://www.jianshu.com/p/ef892323e68f" shape="rect" target="_blank">TCP连接</a>，客户端被动关闭连接，释放<a href="http://www.jianshu.com/p/ef892323e68f" shape="rect" target="_blank">TCP连接</a>;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</span></p><h6><span>5、客户端浏览器解析HTML内容</span></h6><p><span>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</span></p><p><span>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</span></p><p><span>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</span></p><p><span>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立<a href="http://www.jianshu.com/p/ef892323e68f" shape="rect" target="_blank">TCP连接</a>;</span></p><p><span>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 <a href="http://www.jianshu.com/p/ef892323e68f" shape="rect" target="_blank">TCP 三次握手</a>的第三个报文的数据发送给服务器;</span></p><p><span>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</span></p><p><span>5、释放 <a href="http://www.jianshu.com/p/ef892323e68f" shape="rect" target="_blank">TCP连接</a>;</span></p><p><span>6、浏览器将该 html 文本并显示内容; 　　</span></p><h1><span>GET和POST请求的区别</span></h1><h6><span>GET请求</span></h6><pre xml:space="preserve"><span><code>GET /books/?sex=man&amp;name=Professional HTTP/<span>1.1
Host: www.wrox.com
User-Agent: Mozilla/<span>5.0 (Windows; U; Windows NT <span>5.1; en-US; rv:<span>1.7<span>.6)
Gecko/<span>20050225 Firefox/<span>1.0<span>.1
Connection: Keep-Alive</span></span></span></span></span></span></span></span></code></span></pre><p><span>注意最后一行是空行</span></p><h6><span>POST请求</span></h6><pre xml:space="preserve"><span><code>POST / HTTP/<span>1.1
Host: www.wrox.com
User-Agent: Mozilla/<span>5.0 (Windows; U; Windows NT <span>5.1; en-US; rv:<span>1.7<span>.6)
Gecko/<span>20050225 Firefox/<span>1.0<span>.1
Content-Type: application/x-www-form-urlencoded
Content-Length: <span>40
Connection: Keep-Alive

name=Professional%<span>20Ajax&amp;publisher=Wiley</span></span></span></span></span></span></span></span></span></span></code></span></pre><p><span>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</span></p><p><span>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</span></p><h6><span>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</span></h6><p><span>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</span></p><p><span>而在实际开发中存在的限制主要有：</span></p><p><span><strong>GET</strong>:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</span></p><p><span>因此对于GET提交时，传输数据就会受到URL长度的 限制。</span></p><p><span><strong>POST</strong>:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</span></p><p><span>3、安全性</span></p><p><span>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</span></p><p><span>4、Http get,post,soap协议都是在http上运行的</span></p><p><span>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的</span><br clear="none"/><span>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</span></p><p><span>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。</span><br clear="none"/><span>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</span></p><p><span>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式</span><br clear="none"/><span>Content-type设置为: text/xml 任何数据都可以xml化。</span></p><p><span>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</span></p><p><span>我们看看GET和POST的区别</span></p><ol><li><p><span>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</span></p></li><li><p><span>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</span></p></li><li><p><span>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</span></p></li><li><p><span>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</span></p></li></ol><div><span><br clear="none"/></span></div><div><span>HTTP详细错误码</span></div><div><table cellpadding="0" cellspacing="0" width="100%"><tr><th colspan="1" rowspan="1" width="60px;">状态码</th><th colspan="1" rowspan="1">含义</th></tr><tr><td colspan="1" rowspan="1">100</td><td colspan="1" rowspan="1">客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td colspan="1" rowspan="1">101</td><td colspan="1" rowspan="1">服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td colspan="1" rowspan="1">102</td><td colspan="1" rowspan="1">由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td colspan="1" rowspan="1">200</td><td colspan="1" rowspan="1">请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td colspan="1" rowspan="1">201</td><td colspan="1" rowspan="1">请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。</td></tr><tr><td colspan="1" rowspan="1">202</td><td colspan="1" rowspan="1">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td colspan="1" rowspan="1">203</td><td colspan="1" rowspan="1">服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td colspan="1" rowspan="1">204</td><td colspan="1" rowspan="1">服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td colspan="1" rowspan="1">205</td><td colspan="1" rowspan="1">服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td colspan="1" rowspan="1">206</td><td colspan="1" rowspan="1">服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td colspan="1" rowspan="1">207</td><td colspan="1" rowspan="1">由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td colspan="1" rowspan="1">300</td><td colspan="1" rowspan="1">被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td colspan="1" rowspan="1">301</td><td colspan="1" rowspan="1">被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td colspan="1" rowspan="1">302</td><td colspan="1" rowspan="1">请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td colspan="1" rowspan="1">303</td><td colspan="1" rowspan="1">对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td colspan="1" rowspan="1">304</td><td colspan="1" rowspan="1">如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td colspan="1" rowspan="1">305</td><td colspan="1" rowspan="1">被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td colspan="1" rowspan="1">306</td><td colspan="1" rowspan="1">在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td colspan="1" rowspan="1">307</td><td colspan="1" rowspan="1">请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td colspan="1" rowspan="1">400</td><td colspan="1" rowspan="1">1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</td></tr><tr><td colspan="1" rowspan="1">401</td><td colspan="1" rowspan="1">当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td colspan="1" rowspan="1">402</td><td colspan="1" rowspan="1">该状态码是为了将来可能的需求而预留的。</td></tr><tr><td colspan="1" rowspan="1">403</td><td colspan="1" rowspan="1">服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td colspan="1" rowspan="1">404</td><td colspan="1" rowspan="1">请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td colspan="1" rowspan="1">405</td><td colspan="1" rowspan="1">请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td colspan="1" rowspan="1">406</td><td colspan="1" rowspan="1">请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td colspan="1" rowspan="1">407</td><td colspan="1" rowspan="1">　与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td></tr><tr><td colspan="1" rowspan="1">408</td><td colspan="1" rowspan="1">请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td colspan="1" rowspan="1">409</td><td colspan="1" rowspan="1">由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td colspan="1" rowspan="1">410</td><td colspan="1" rowspan="1">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td colspan="1" rowspan="1">411</td><td colspan="1" rowspan="1">服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td colspan="1" rowspan="1">412</td><td colspan="1" rowspan="1">服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td colspan="1" rowspan="1">413</td><td colspan="1" rowspan="1">服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td colspan="1" rowspan="1">414</td><td colspan="1" rowspan="1">请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td colspan="1" rowspan="1">415</td><td colspan="1" rowspan="1">对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td colspan="1" rowspan="1">416</td><td colspan="1" rowspan="1">如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td colspan="1" rowspan="1">417</td><td colspan="1" rowspan="1">在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td colspan="1" rowspan="1">421</td><td colspan="1" rowspan="1">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td colspan="1" rowspan="1">422</td><td colspan="1" rowspan="1">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td colspan="1" rowspan="1">422</td><td colspan="1" rowspan="1">请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td colspan="1" rowspan="1">424</td><td colspan="1" rowspan="1">由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td colspan="1" rowspan="1">425</td><td colspan="1" rowspan="1">在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td colspan="1" rowspan="1">426</td><td colspan="1" rowspan="1">客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td colspan="1" rowspan="1">449</td><td colspan="1" rowspan="1">由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td colspan="1" rowspan="1">500</td><td colspan="1" rowspan="1">服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td colspan="1" rowspan="1">501</td><td colspan="1" rowspan="1">服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td colspan="1" rowspan="1">502</td><td colspan="1" rowspan="1">作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td colspan="1" rowspan="1">503</td><td colspan="1" rowspan="1">由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td></tr><tr><td colspan="1" rowspan="1">504</td><td colspan="1" rowspan="1">作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td colspan="1" rowspan="1">505</td><td colspan="1" rowspan="1">服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td colspan="1" rowspan="1">506</td><td colspan="1" rowspan="1">由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td colspan="1" rowspan="1">507</td><td colspan="1" rowspan="1">服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td colspan="1" rowspan="1">509</td><td colspan="1" rowspan="1">服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td colspan="1" rowspan="1">510</td><td colspan="1" rowspan="1">获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></table><br clear="none"/></div></div><div><br clear="none"/></div></span>
</div></body></html> 