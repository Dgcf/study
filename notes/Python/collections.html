<html>
<head>
  <title>collections</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="568"/>
<h1>collections</h1>

<div>
<span><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">共9个</span></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">1. collections.Counter</span><span style="font-family: georgia, palatina, serif;">([iterable-or-mapping])：是dict的一个子类，可以给Counter对象提供任何</span><span style="font-family: georgia, palatina, serif; font-style: italic; font-weight: bold;">可哈希 </span><span style="font-family: georgia, palatina, serif;">的对象序列作为输入，无序的，给键准备一个计数器，每次更新一个键的时候会增加或者计数器；元素存储在一个字典的key中，元素出现的个数存储在字典的value中；</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">Counter有四种构造方法：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">c = Counter()</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">c = Counter('gallahad')    # from iterable</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">c = Counter({'red': 4, 'blue': 2})</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">c = Counter(cats=4, dogs=8)</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">Counter对象之间可以和各种运算操作结合起来使用，如+，-</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">most_common([n])：返回n个出现次数最多的以该元素和出现次数组成的元组的列表</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">update([iterable-or-mapping])：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">test_words = 'AAABBccccccDDd'</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">word_counts = Counter(test_words)</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">top_two = word_counts.most_common(2)</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">print(top_two)</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;"># 输出</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">[('c', 6), ('A', 3)]</span></div><div><br clear="none"/></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;"># 使用update方法：</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">more_words = 'bbCCCDDd'</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">word_counts.update(more_words)</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;"># 使用数学运算操作</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">&gt;&gt;&gt;a=Counter(words)</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">&gt;&gt;&gt;b=Counter(moreWords)</span></div><div><span style="color: #333333; font-size: 12px; font-family: georgia, palatina, serif;">&gt;&gt;&gt;c=a+b             # a,b之间可以进行数学运算</span></div></div><ul><li><div><br clear="none"/></div></li></ul><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">2. collections.namedtuple</span><span style="font-family: georgia, palatina, serif;">(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">typename</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">field_names</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">*</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">verbose=False</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">rename=False</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">module=None</span><span style="font-family: georgia, palatina, serif;">)：这个类创建并返回一个元组子类，是一个工厂方法，可以用来<span style="color: #ff00ff;">构建只有少量属性没有方法的对象</span></span></div><ul><li><div><span style="font-family: georgia;">内存：用namedtuple构建的类实例消耗的内存和元组是一样的；这个实例和普通的对象实例比起来也要小一些，因为python不会用__dict__存放这些实例的属性</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">参数：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">typename：类名；</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">field_names是该类的属性，用字符串表示，如果是多个就用序列如元组或列表表示，表示值的名称，类似于字典中的key；</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">这个类创建一个既可以按下标值也可以按类型名称获取其相应字段的元组，作用是将代码同它控制的元素位置解耦</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">支持普通元组的所有操作，如索引，分解。另一种用法是字典的替代，比字典更加高效，但与字典不同的是，nametuple中的值是不可变的，所以</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">要想修改任何属性值，使用_replace(att=x)：创建一个全新的命名元组</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">方法/属性：除了元组方法外，还包括三个类方法和两个属性。somenametuple是什么？nametuple是一个类工厂，返回的是一个已经定好了key的元组子类，也就是somenametuple</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">somenamedtuple._make(iterable)：用一个已存在的序列或可迭代对象实例化一个元组子类的对象，作用和typename(*delhi_data)是一样的</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">somenamedtuple._asdict(): 把具名元组以OrderedDict的形式返回</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">somenamedtuple._replace(kwargs): 返回一个新的实例，这个实例是kwargs这个键值对的值做出改变后的实例</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">somenamedtuple._source:</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">somenamedtuple._fields: 包含这个类所有字段名称的元组</span></div></li></ul><ul><li><div><span style="font-family: georgia;">作用：</span></div></li></ul><ul><li><div><span style="font-family: georgia;">当作使用少量属性，记录来用的数据类型</span></div></li><li><div><span style="font-family: georgia;">充当一个不可变的列表</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.15); -en-codeblock: true;"><div><span style="font-family: georgia, palatina, serif;">## 示例 cookbook 1.18</span></div></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">3. collections.deque([iterable[, maxlen]])</span><span style="font-family: georgia, palatina, serif;">：双向队列，这个队列是</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">线程安全</span><span style="font-family: georgia, palatina, serif;">的，默认先进先出，如果达到maxlen值，后面填加后前面的会依次移出deque。但可以通过方法自由操作</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">deque（iterable, maxlen）：使用可迭代对象初始化deque，如果为空则创建的deque也为空，maxlen指定deque的最大长度，如果不指定默认无限长</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">append（x）：从</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">右边添加</span><span style="font-family: georgia, palatina, serif;">x到deque中</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">appendleft(x)：从左边添加x到deque中，对已满的队列头部添加时，尾部(右边)的元素会被删除掉</span></div></li><li><span style="font-family: georgia, palatina, serif;">extend(iterable)：从右边添加可迭代的对象到队列</span></li><li><span style="font-family: georgia, palatina, serif;">extendleft(iterable)：从左边添加，注意，<strong>是逐个添加</strong>，所以iterable在加入序列后是倒序的形式</span></li><li><div><span style="font-family: georgia, palatina, serif;">pop()：从</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">右边移除</span><span style="font-family: georgia, palatina, serif;">并返回元素，如果没有元素，则抛出异常IndexError</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">popleft()：从左边移除并返回元素</span></div></li><li><span style="font-family: georgia, palatina, serif;">rotate(n): 旋转操作，n&gt;0时，队列最右边的n个元素会被移动到队列的左边，n&lt;0时，最左边的n个元素会被移动到右边，原地操作返回None</span></li><li><span style="font-family: georgia, palatina, serif;">clear(): 清除所有元素</span></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">对比</span>：queue：一个同步的单向队列，包括以下类和异常：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">class queue.Queue(maxlen=0):</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">作用：</span></div><ol><li><span style="font-family: georgia, palatina, serif;">快速从两端添加或删除元素，但从中间删除元素比较慢</span></li><li><span style="font-family: georgia, palatina, serif;">先进先出，保持序列中最新的某几个元素</span></li></ol><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">4. collections.defaultdict</span>([default_factory[,...]])：自动初始化每个key的值，参数有哪些：分别为list，int，set，这些为value的类型；参考fluent3.3，3.4</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">5. collections.OrderedDict</span><span style="font-family: georgia, palatina, serif;">（[items]）：标准的字典是无序的，也就是说在两个相同键值对的dict上迭代可能会出现不同的迭代顺序。OrderedDict是一种特殊的字典，能够按照键的</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">插入顺序</span><span style="font-family: georgia, palatina, serif;">来保留键值对在字典中的次序——有什么适用场合？</span></div><ul><li><div>内部维护着一个根据键插入顺序排序的双向链表，所以一个 OrderedDict 的大小是一个普通字典的两倍</div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">6. collections.ChainMap</span><span style="font-family: georgia, palatina, serif;">(*maps)：类，将多个映射合并成一个映射，但只是逻辑上表现为一个单独的映射结构，并不会合并在一起，大部分字典操作都能正常工作，</span><span style="font-family: georgia, palatina, serif; color: #ff0000;">有哪些不支持的字典操作</span><span style="font-family: georgia, palatina, serif;">？</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">如果有重复的键，会采用参数中第一个映射的值</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">修改映射的操作会作用在第一个映射结构上</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">操作任何第一个之外的映射都在原映射上不会改变，但在类实例上会改变（已验证）</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">new_child(m=None)：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">parents：</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">7. Collections.UserDict：这个类就是把标准dict用纯Python又实现一遍</span></div><div><span style="font-family: georgia, palatina, serif;">8. Collections.UserList</span></div><div><span style="font-family: georgia, palatina, serif;">9. Collections.UserString</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div></span>
</div></body></html> 