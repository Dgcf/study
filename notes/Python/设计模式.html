<html>
<head>
  <title>设计模式</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="755"/>
<h1>设计模式</h1>

<div>
<span><div><div><span style="font-family: georgia, palatina, serif;">创建型模式：</span></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">1. 工厂模式</span>：客户端可以请求一个对象，而不需要知道这个对象来自哪里，也就是，使用哪个类来生成这个对象</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">工厂方法：对不同的输入参数返回不同的对象</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">思想：简化对象的创建</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">实现：基于一个中心函数(工厂函数)创建，将创建对象的代码和使用对象代码解耦</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">抽象工厂：用于创建一系列相关事务对象的工厂方法，一个抽象工厂是一组工厂方法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">应用：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">创建对象的代码分布在多个不同的地方，无法跟踪这些对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">将对象的创建和使用解耦</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">应用性能及内存相关：在需要的时候创建新的对象</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">2.建造者模式</span>：将一个对象的构造过程与其表现分离；该模式中：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">建造者负责创建复杂对象的各个组成部分，指挥者使用一个建造者实例控制建造的<span style="font-family: georgia, palatina, serif; font-weight: bold;">过程</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">应用场景:一个对象必须经过</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">多个步骤</span><span style="font-family: georgia, palatina, serif;">创建，并且要求同一构造过程可以产生不同的表现，就可以使用建造者模式</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">与工厂模式的区别：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">工厂模式以单个步骤创建对象，建造者模式以多个步骤创建对象，并且几乎始终使用同一个指挥者</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">工厂模式下会立即返回一个创建好的对象，而在建造者模式下仅在需要时客户端代码才显式的请求指挥者返回最终的对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">例子：比如买一台电脑，如果是购买一台特定的预配置的电脑型号，则是工厂模式；如果是定制电脑，则是建造者模式，你是指挥者，向制造商（建造者）提供指令说明要预定的配置</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">相比工厂模式，建造者模式的优点：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">想要创建一个复杂的对象（对象由多个部分构成，且对象的创建需要经过多个不同的步骤）；</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">要求对象能有不同的表现，并希望将对象的构造与表现解耦</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">想要在某个时间点创建对象，但在稍后的时间点再访问——</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">3.原型模式</span>: 创建对象的克隆</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">复制对象而不是重新创建对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">应用场景：如果一个对象的某些部分会改变但又希望原有对象不变时，在这种情况下重新创建原有对象是没有意义的，通常需要对象的一个副本</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">结构型模式：处理一个系统中不同实体之间的关系，关注的是提供一种简单的对象组合方式来创造新的功能</span></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">4. 适配器模式</span>：实现两个不兼容接口之间的兼容</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">实现方式：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">继承</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">使用内部字典，通过类内部字典更新属性(精通python设计模式的例子很有借鉴意义)</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">5.修饰器模式</span>：动态扩展对象的行为。修饰器模式能够以透明的方式（不会影响其他对象）动态的将功能添加到一个对象中</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">适用场景：横切关注点如</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;"> 数据校验；日志；缓存；监控；加密，调试等</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">6. 外观模式</span>：封装内部系统，隐藏系统的内部复杂性，通过一个简化的接口向客户端暴露必要的部分</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">优点：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">隐藏复杂和不必要展示的细节</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可以改变系统内部，但外部代码不用关心这个改变，也不会受到改变的影响，客户端代码不需要进行任何改变</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">7. 享元模式</span>：通过为相似对象引入数据共享来最小化内存使用；一个享元就是一个包含状态独立的不可变数据的共享对象；依赖状态的可变不是享元的一部分</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">适用场景：是一个用于优化的设计模式</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">应用需要使用大量的对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对象太多，存储，渲染这些对象的代价太大。一旦移除对象中的可变状态，多组不同的对象可以被相对更少的共享对象所替代</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对象ID对于对象不重要(共享对象具有相同的对象ID)</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">享元模式是一种特定于面向对象编程优化的设计模式，关注的是共享对象数据</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">8.模型-视图-控制器模式：</span></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">9.代理模式：</span><span style="font-family: georgia, palatina, serif;">可以作为继承的一种替代方案</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">代理类型：</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">远程代理：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">虚拟代理：用于懒初始化，把计算成本较高的对象的创建工作延迟到用户首次使用的时候进行</span></div><ul><li><span style="font-family: georgia, palatina, serif;">最有效的方式就是利用描述符类来完成(cookbook8.10)</span></li></ul></li><li><div><span style="font-family: georgia, palatina, serif;">保护/防护代理：访问某个对象之前执行一个或多个操作，比如在访问敏感信息时先确保用户具备足够的权限，控制对敏感信息的访问</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">智能代理：</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">10. 责任链模式</span>：用于让多个对象处理单个请求，或者预先不知道由哪个对象来处理某个特定请求时</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">原则：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">存在一个对象链（链表，树或者其他便捷结构）</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">一开始将请求发送给链表中的第一个对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对象决定其是否要处理该请求</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对象将请求转发给下一个对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">重复该过程，直到到达链表尾</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">价值：解耦发送方和接收方</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">有助于对请求/处理事件建模</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-weight: bold;">10.1. 访问者模式</span>：和责任链模式的实现有点像，但思想不一样；(cookbook8.21)</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">好处：访问者模式可以避免编写大量if语句；简洁，解耦，运行速度快</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">缺点就是需要重度依赖递归；但是通过生成器和协程来控制程序的执行流可以解决该问题，具体实例cookbook8.22</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">11. 命令模式：将一个操作(撤销，重做，复制，粘贴等等)封装成一个对象</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">可以在任何时候执行一条命令，并不一定在命令创建时</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">执行一个命令的客户端代码并不需要知道命令的任何实现细节</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可以对命令进行分组</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">13. 观察者模式</span>：单个对象（发布）与一个或多个对象（订阅者）之间的发布-订阅关系</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">应用场景：一个对象发生变化时通知/更新另一个或多个对象；观察者的数量以及谁是观察者有所不同，也可以动态的改变</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-weight: bold;">14. 状态模式</span>：面向对象编程着力于在对象交互的时候改变他们的状态。关注的是实现一个状态机，状态机的核心部分是状态和状态之间的转换</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">实现：使用一个父state类和许多派生的ConcreteState类实现，父类包含所有状态共同的功能，子类只包含特定状态要求的功能</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">转换：从一个状态到另一个状态，因某个条件的触发</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">状态设计模式解决的问题是一定上下文中无限数量状态的完全封装</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">cookbook8.19：总体来说将各个状态分解开来，书中的两个例子都很好，要看熟用起来</span></div></li></ul><ul><li><div><span style="font-family: georgia, palatina, serif;">使用继承关系</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">直接修改__class__</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">30.actor模式：actor是一个并发执行的任务，只是简单的对发送给他的消息进行处理，作为这些消息的响应，actor会决定是否对其他actor发送进一步的消息。actor任务之间的通信时单向且异步的，因此，消息的发送者并不知道消息何时才会实际传递，当消息已经处理完成时也不会接收到响应或者确认</span></div><div><span style="font-family: georgia, palatina, serif;">16.模板模式：使用动作/钩子方法/函数来完成代码重复的消除</span></div><div><br clear="none"/></div></div><div><br clear="none"/></div></span>
</div></body></html> 