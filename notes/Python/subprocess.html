<html>
<head>
  <title>subprocess</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="553"/>
<h1>subprocess</h1>

<div>
<span><div>1. run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, env=None)</div><div>建议使用run函数处理所有可以处理的情况<br clear="none"/><br clear="none"/></div><div>参数：<br clear="none"/></div><ul><li>args：指定要运行的命令，等要运行的命令完成后，返回CompletedProcess实例<br clear="none"/></li><li>input：这个参数被传递给Popen.communicate() and thus to the subprocess’s stdin<br clear="none"/></li><li>shell: 为True时shell默认为/bin/sh——具体有啥作用还没发现<br clear="none"/></li><li>timeout：用于传递给Popen.communicate(),如果超时，子进程就会被杀掉，并抛出TimeOutExpired异常<br clear="none"/></li><li>check: 如果该值为True，如果以非0值退出，CalledProcessError异常会被抛出；Attributes of that exception hold the arguments, the exit code, and stdout and stderr if they were captured.<br clear="none"/></li><li>如果encoding和errors指定<br clear="none"/></li><li>如果env是非0，<span lang="zh-CN"><span>它必须是定义新进程的环境变量的映射</span></span>（？），<span lang="zh-CN"><span>这些用于代替继承当前进程环境的默认行为</span></span>，被直接传递给Popen<br clear="none"/></li></ul><div>2.类CompleteProcess：run的返回类型<br clear="none"/></div><div>方法/属性：<br clear="none"/></div><ul><li>args：运行子进程的参数，是一个list或string<br clear="none"/></li><li>returncode：子进程退出状态值，0表示子进程运行成功，-N表示子进程yi信号-N退出<br clear="none"/></li><li>stdout：从子进程中获取stdout(?)<br clear="none"/></li><li>stderr:<br clear="none"/></li><li>check_returncode(): 如果returncode是非0，抛出CalledProcessError异常<br clear="none"/></li></ul><div>3.DEVNULL：<br clear="none"/></div><div>4.PIPE：<br clear="none"/></div><div>5.STDOUT：<br clear="none"/></div><div>6.Popen(args, bufsize=-1, executable=None,<br clear="none"/>     stdin=None,stdout=None,stderr=None, </div><div>     preexec_fn=None, close_fds=True, shell=False, cwd=None,<br clear="none"/>     env=None, universal_newlines=False, startupinfo=None, creationflags=0,<br clear="none"/>     restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None)<br clear="none"/></div><ul><li>参数：<br clear="none"/><ul><li>args：分两种情况：<br clear="none"/><ul><li><span lang="zh-CN"><span>序列参数，通常是列表或元组，是首选，因为它允许模块处理任何所需的转义和引用参数</span></span><br clear="none"/></li><li><span lang="zh-CN"><span>单一字符串：<span lang="zh-CN"><span>要么shell必须为True，要么字符串必须简单地要执行的程序而不指定任何参数。，</span></span><br clear="none"/></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span style="color: rgb(255, 0, 0);">注意：在重定向的时候用序列参数不行，用字符串参数同时指定shell为True则可以</span>。<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>shlex.split()可以分割输入的命令将其改为序列参数，直接传递给Popen<br clear="none"/></span></span></span></span></li></ul></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>bufsize：被用来传递给open函数<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>executable：执行可替换的执行文件，很少使用<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>stdin/stdout/stderr:标准输入，输出，和错误文件句柄，有效值分别是PIPE，DEVNULL，一个存在的文件描述符，或None<br clear="none"/></span></span></span></span><ul><li><span lang="zh-CN"><span><span lang="zh-CN"><span>PIPE：表明对一个子进程而言新的pipe被创建<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>DEVNULL：表明特殊文件os.devnull被使用<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>默认值None：不会发生重定向<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>子文件句柄会从父类继承（？）<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>另外，stderr可以是STDOUT，表明来自子进程的stderr数据<span lang="zh-CN"><span>捕获到与stdout相同的文件句柄中</span></span>（？）</span></span></span></span><span lang="zh-CN"><span><span lang="zh-CN"><span><br clear="none"/></span></span></span></span></li></ul></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>preexec_fn：可调用对象，在子进程被执行前调用（不是线程安全的）<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>close_fds：<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>cwd：如果不空，在子进程执行之前指定工作目录，可以是一个str and path-like object<br clear="none"/></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span>shell：<span lang="zh-CN"><span>这可能很有用</span><span>如果你主要使用Python来增强控制流，那么它提供了大多数系统shell</span><span>并且仍然希望方便地访问其他shell功能，例如shell管道，文件名通配符，</span><span>环境变量扩展，并扩展到用户的主目录。</span></span><br clear="none"/></span></span></span></span><ul><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>如果shell如True，推荐args为字符串</span></span></span></span></span></span></li></ul></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>restore_signals：<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>start_new_session<br clear="none"/></span></span></span></span></span></span></li></ul></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>支持上下文管理器<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>异常：<br clear="none"/></span></span></span></span></span></span><ul><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>最常发生的异常是OSError<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>ValueError：如果Popen被无效参数调用<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>CalledProcessError：check_call() and check_output()调用出错<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>TimeoutExpired：带timeout参数的方法在超时之后会抛出该异常<br clear="none"/></span></span></span></span></span></span></li></ul></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>方法：<br clear="none"/></span></span></span></span></span></span><ul><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>poll()：检查是否子进程终止，Set and return returncode attribute. Otherwise, returns None.<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>wait(timeout=None)：等待子进程结束，Set and return returncode attribute.<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>communicate(input=None, timeout=None)：</span></span></span></span></span></span><ul><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span> 和进程交互。<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>返回元组(stdout_data, stderr_data),如果streams以文本方式打开返回字符串，否则返回字节<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>如果时间到了子进程没有被杀死，需要做好清理，下段代码值得参考</span></span></span></span></span></span><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span><br clear="none"/></span></span></span></span></span></span></li></ul></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>send_signal(signal)：发送单独的信号<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>terminate()：终止子进程<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>kill()：杀死子进程<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>旧的api：可以使用run代替：<br clear="none"/></span></span></span></span></span></span><ul><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span> subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None)<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None, shell=False, cwd=None,timeout=None)<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, cwd=None, encoding=None, errors=None, universal_newlines=False, timeout=None)<br clear="none"/></span></span></span></span></span></span></li></ul></li></ul></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>属性：<br clear="none"/></span></span></span></span></span></span><ul><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>args：<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>stdin：<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>stdout：<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>stderr：<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>pid：子进程的ID，如果设置shell为True，这个id是新打开的shell的ID<br clear="none"/></span></span></span></span></span></span></li><li><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span>returncode：子进程的返回值，set by poll() and wait() (and indirectly by communicate()).None值表明该进程还没结束<br clear="none"/></span></span></span></span></span></span></li></ul></li></ul><div><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span><br clear="none"/></span></span></span></span></span></span></div><div><span lang="zh-CN"><span><span lang="zh-CN"><span><span lang="zh-CN"><span><br clear="none"/></span></span></span></span></span></span></div><div>7.异常：<br clear="none"/></div><ol><li>subprocess.SubprocessError:这个模块中所有异常类的基类<br clear="none"/></li><li>subprocess.TimeoutExpired: 等待子进程时超时会抛出这个异常：<br clear="none"/><ol><li>cmd：用于生成子进程的命令<br clear="none"/></li><li>timeout：超时秒数<br clear="none"/></li><li>output：如果子进程被run() or check_output()捕获时的输出，其他为None<br clear="none"/></li><li>stdout：<span lang="zh-CN"><span>输出的别名</span></span><br clear="none"/></li><li>stderr：被run()捕获的子进程的输出<br clear="none"/></li></ol></li><li>subprocess.CalledProcessError：子进程被check_call() or check_output()这两个函数运行，返回非0退出值时抛出异常<br clear="none"/><ol><li>returncode：子进程的退出状态<br clear="none"/></li><li>cmd：用于生成子进程的命令<br clear="none"/></li><li>output：<br clear="none"/></li><li>stdout：<br clear="none"/></li><li>stderr：<br clear="none"/></li></ol></li></ol></span>
</div></body></html> 