<html>
<head>
  <title>类的特殊方法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="557"/>
<h1>类的特殊方法</h1>

<div>
<span><div><div><span style="font-family: georgia, palatina, serif;">1. 构造方法：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__init__(self, *args, **kwargs): 实例化实例的属性；子类如果不实现这个方法会自动调用父类init方法，反之不调用</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__new__(cls, *args, **kwargs)：</span></div><div><span style="font-family: georgia, palatina, serif;">cls表示要实例化的类；*args：**kwargs：</span></div><div><span style="font-family: georgia, palatina, serif;">返回值是类实例</span></div><div><span style="font-family: georgia, palatina, serif;">在__init__之前调用。new方法返回一个实例后自动调用init，init的self参数就是new返回的实例，若new没有正确返回当前类cls的实例，init就不会被调用</span></div><div><span style="font-family: georgia, palatina, serif;">应用场合：当需要以非标准的方式创建实例时需要绕过__init__方法，如反序列化；或者实现一个类方法作为备选构造函数(cookbook8.17)；当定义多个构造函数时应该让init尽可能简单-除了给属性赋值之外什么都不做；在其他备选的构造函数中实现更高级的操作</span></div><div><span style="font-family: georgia, palatina, serif;">元类中的new：__new__(mcs, clsname, bases, clsdict), </span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__prepare__()：在开始定义类和它的父类的时候被执行。用来创建类命名空间，通常来讲，这个方法只是简单的返回一个字典或其他映射对象。执行顺序为：prepare（创建命名空间）-&gt; 依次执行类定义语句 -&gt; new（创建类）-&gt; init（初始化类）</span></div></li></ul><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">class Date:</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">    def __init__(self, year, month, day):</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">        ,,,</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">d = Date.__new__(Date)        ## 得到的是一个未经初始化的实例。怎样初始化实例？实例属性放在一个字典中，有两种方法，setter/__dict__.update()</span></div></div><div><span style="font-family: georgia, palatina, serif;">2. 解构器：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__del__: 析构方法，在对象要被垃圾回收之前调用，但发生调用的具体时间是不可知的，所以应当尽量避免使用该方法</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">3. 描述符：是重写类属性访问方法(__get__, __set__, __delete__ )的默认行为要使用的一种推荐机制。定义了__get__(self, instance, owner), __set__(self, instance, value), __delete__ 中的一个或几个就称为描述符，其中，只实现__get__为非数据描述符，还实现了set的为数据描述符。(cookbook 8.9)</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">参数：</span></div></li><ul><li><div><span style="font-family: georgia, palatina, serif;">self：Desc的实例</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">instance：TestDesc实例</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">owner: 谁拥有这些实例，TestDesc类</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">value：</span></div></li></ul><li><div><span style="font-family: georgia, palatina, serif;">应用场景：捕获和控制对实例属性的访问</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">限制条件：描述符只能在类的级别上定义，不能为每个实例单独定义——疑问：<span style="font-family: georgia, palatina, serif; color: rgb(255, 0, 0); font-weight: bold;">类变量用实例操作？</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对于类属性描述符对象，使用type.__getattribute__,它把class.x转换为class.__dict__['x'].__get__(None, class),对实例属性描述符对象，使用object.__getattribute__,能把object.x转为object.__dict__['x'].__get__(object, type(object))</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">使用描述符的方法：因为如果解析器发现x是一个描述符的话，其实在内部是通过type.__getattribute__()，它能把MyClass.x转换为MyClass.__dict__[“x”].__get__(None,MyClass)来访问</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果将描述符的对象定义为对象属性，当访问一个实例描述符对象时，object.__getattribute__会将test.y转换为type(test).__dict__['y'].__get__(test, type(test)), 而没有类属性y，所以访问不到__get__</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">访问类层次上的描述符可以自动调用__get__, 但访问实例层次上的描述符只能返回描述符本身</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对于非数据描述符，主要用于方法，如类方法和静态方法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">属性查询优先级：</span></div><div>     <span style="font-family: georgia, palatina, serif;">__getattribute__: 无条件调用</span></div><div><span style="font-family: georgia, palatina, serif;">     数据描述符：由__getattribute__触发调用，如果重写了__getattribute__会让描述符无法自动调用</span></div><div><span style="font-family: georgia, palatina, serif;">     实例对象的字典</span></div><div><span style="font-family: georgia, palatina, serif;">     类字典</span></div><div><span style="font-family: georgia, palatina, serif;">     非数据描述符</span></div><div><span style="font-family: georgia, palatina, serif;">     父类的字典</span></div><div><span style="font-family: georgia, palatina, serif;">     __getattr__()方法</span></div><div><span style="font-family: georgia, palatina, serif;">例子：cookbook8.13继承，描述符</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">问题：</span></div></li><ul><li><div><span style="font-family: georgia, palatina, serif;"> 如果访问一个类的实例方法，__get__和__call__哪个先被调用？经实测，get先调用，接着是call(cookbook9.9)</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">class Desc(object):</span></div><div><span style="font-family: georgia, palatina, serif;">4</span></div><div><span style="font-family: georgia, palatina, serif;">5 def __get__(self, instance, owner):</span></div><div><span style="font-family: georgia, palatina, serif;">6 print(&quot;__get__...&quot;)</span></div><div><span style="font-family: georgia, palatina, serif;">7 print(&quot;self : \t\t&quot;, self)</span></div><div><span style="font-family: georgia, palatina, serif;">8 print(&quot;instance : \t&quot;, instance)</span></div><div><span style="font-family: georgia, palatina, serif;">9 print(&quot;owner : \t&quot;, owner)</span></div><div><span style="font-family: georgia, palatina, serif;">10 print('='*40, &quot;\n&quot;)</span></div><div><span style="font-family: georgia, palatina, serif;">11</span></div><div><span style="font-family: georgia, palatina, serif;">12 def __set__(self, instance, value):</span></div><div><span style="font-family: georgia, palatina, serif;">13 print('__set__...')</span></div><div><span style="font-family: georgia, palatina, serif;">14 print(&quot;self : \t\t&quot;, self)</span></div><div><span style="font-family: georgia, palatina, serif;">15 print(&quot;instance : \t&quot;, instance)</span></div><div><span style="font-family: georgia, palatina, serif;">16 print(&quot;value : \t&quot;, value)</span></div><div><span style="font-family: georgia, palatina, serif;">17 print('='*40, &quot;\n&quot;)</span></div><div><span style="font-family: georgia, palatina, serif;">18</span></div><div><span style="font-family: georgia, palatina, serif;">19</span></div><div><span style="font-family: georgia, palatina, serif;">20 class TestDesc(object):</span></div><div><span style="font-family: georgia, palatina, serif;">21 x = Desc()</span></div><div><span style="font-family: georgia, palatina, serif;">22</span></div><div><span style="font-family: georgia, palatina, serif;">23 #以下为测试代码</span></div><div><span style="font-family: georgia, palatina, serif;">24 t = TestDesc()</span></div><div><span style="font-family: georgia, palatina, serif;">25 t.x</span></div></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">4. 序列协议：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__len__(self)：返回集合中所含项目的数量,对于序列来说是元素的个数，对于映射来说是则是键值对的数量；</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__getitem__(self,key)：返回与所给键对应的值；对于序列来说键是索引值：0-n-1；对于映射来说是任何种类的键</span></div></li><ul><li><div>实现这个协议后可以支持访问元素，迭代和使用in运算符</div></li><ul><li><div>如果没有实现__iter__和__contains__, python会调用__getitem__方法，设法让迭代和in运算符可用</div></li></ul><li><div>处理切片操作: </div></li><li><div>实现这个协议只是不可变序列，如果是可变序列，还要提供__setitem__</div></li></ul></ul><div>def __getitem(self, index):</div><div>    cls = type(self)</div><div>    if isinstance(index, slice):</div><div>       return cls(self._c[index])</div><ul><li><div><span style="font-family: georgia, palatina, serif;">__setitem__(self,key,value)：按一定的方式存储和key相关的value，该值随后可以由__getitem__(self,key)获取</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__delitem__(self, key): </span></div></li><li><div><span style="font-family: georgia, palatina, serif;">注：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果键是不合适的类型就会引发TypeError</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果序列索引是正确的类型但超出了范围就会引发IndexError</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">序列协议：__len__和__getitem__,只要实现了这两个方法就可以当作序列来使用</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">5. 字符串/字节串表示形式：</span></div><div><span style="font-family: georgia, palatina, serif;">     要修改字符串的实例表示，可以通过定义__str__和__repr__方法来实现：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">c.__str__(self): 直接打印实例返回的值，str(c)或是print(c)就是打印出这个方法的返回值，注意必须返回一个字符串，类的实例方法中的self。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">c__repr__(self):要用实例去调用，返回的应当是实例代码表示，可以用它返回的字符串文本重新创建这个实例，即满足obj=eval(repr(obj)), 如果不能办到，就让他产生一段又帮助意义的文本，并且以&quot;&lt;&gt;&quot;括起来；</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__repr__()</span><span style="font-family: georgia, palatina, serif;"> 生成的文本字符串标准做法是需要让 </span><span style="font-family: georgia, palatina, serif;">eval(repr(x)) == x</span><span style="font-family: georgia, palatina, serif;"> 为真</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">直接输出实例名称而不是print(c)就会调用这个方法，如果自定义类中不覆盖这两个方法，结果都是一样的</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">特殊的格式化代码 !r 表示应该使用__repr__的输出，而不是默认的__str__；使用!r获取各个分量的表示形式</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">示例中的格式化代码{0.x}用来指代参数0的x属性，0实际上就是代表self</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">问题总结：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">!r和!s的表示法：用在要输出的属性的后面，见下例</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">0为什么代表self？</span></div></li></ul><div>    <span style="font-family: georgia, palatina, serif;">如果要使用这两个特殊方法中的一个，__repr__是更好的选择，因为如果一个对象没有__str__函数而python又需要调用到他的时候解释器会用__repr__作为替代</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">class Pair:</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">     def __init__(self):</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">          self.x = x</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">          self.y = y</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">     def __repr__(self):</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">          return 'Pair({0.x!r}, {0.y!r})'.format(self)     ## 还可以写为：return 'Pair(%r, %r)'%(self.x, self.y); 0.x对应的是第一个参数的x属性</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">     def __str__(self):</span></div><div><span style="font-family: georgia, palatina, serif; font-size: 9pt; color: #333333;">          return '({0.x!s}, {0.y!s})'.format(self)</span></div></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__bytes__</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__format__, 这个方法用来自定义字符串输出格式，</span><span style="font-family: georgia;">内置的format和str.format方法把各个类型的格式化方式委托给相应的.__format__(format_spec)方法</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">7. 上下文管理协议：通过with语句触发，通常情况下写一个上下文管理器需要定义一个类，需要实现__enter__(self)和__exit__(self, exc_type, exc_value,         traceback)方法；with语句的目的是用来简化try/finally模式</span></div><div><span style="font-family: georgia, palatina, serif;">        执行with语句后面的表达式得到的结果是上下文管理器对象，不过把值绑定到as是在上下文管理器对象上调用__enter__方法的结果；不管流程是以那种方式退出，都会在上下文管理器对象上调用__exit__方法，而不是在__enter__方法返回的对象上调用</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__exit__(self, exc_type, exc_value, exc_tb): 如果一切正常，Python调用__exit__方法时传入的参数是None，None，None；如果抛出了异常，这三个参数是异常数据；如果这个方法返回None，或者True之外的值，with块中的任何异常都会向上冒泡</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">参数：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">exc_type：异常类</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exc_value.args获取</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">exc_tb：trackback对象</span> <span style="font-family: georgia, palatina, serif;">  </span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__enter__(self)：除了隐式self之外不传入任何参数</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">as子句是可选的，对于open函数来说必须加上as子句以便获取文件的引用</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">原则：当遇到with语句时__enter__()方法首先被触发执行，__enter__()的返回值(如果有的话)被放置在由as限定的变量中，之后开始执行with代码块中的语句，最后__exit__()方法被触发来执行清理工作</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">常用在需要管理类似文件，网络连接和锁这样的资源的程序中。这样的资源的关键点在于他们必须显式地进行关闭或释放才能正确工作</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">在内置类型中支持上下文管理器协议的有：file</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">可以通过dir方法查看对象是否支持迭代协议</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">实现一个新的上下文管理器的最简单的方法就是使用 contexlib 模块中的 @contextmanager 装饰器，但只适用于编写自给自足型(?)的上下文管理器(9.22)，利用这个装饰器可以在函数中实现自定义上下文管理器，但没有尝试过。但目前有个问题：这个装饰器分别在什么时候执行enter和exit？</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">问题总结：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">怎样发现有没有异常和怎样处理异常？   </span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">8. 当创建大量实例时如何节省内存：默认情况下python在各个实例中名为__dict__的字典里存储实例属性，字典会消耗大量内存，通过__slots__属性能节省大量内存，方法是让解释器在元组(不一定是元组，推荐元组)中而不是字典中存储实例属性</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">当定义了__slots__属性时，不再让每个实例都创建一个__dict__字典，实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似。在 </span><span style="font-family: georgia, palatina, serif;">__slots__</span><span style="font-family: georgia, palatina, serif;"> 中列出的属性名在内部被映射到这个数组的指定下标上，经验证，如果访问定义里slots属性的实例的__dict__属性会抛出异常</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">带来的问题：不能再对实例添加任何新的属性，只允许使用__slots__中列出的那些</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">用途：优化，运行速度更快</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">建议：尽量不使用该属性。</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">python中有许多部分都依赖于传统的基于字典的实现</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">继承：继承自超类的slots属性没有效果，python只会使用各个类中定义的slots属性(fluent)，如果需要每一个子类也要定义这个属性；——定义了__slots__的类不支持某些特定功能如多重继承(cookbook)</span></div></li><li><div><span style="font-family: georgia;">需要注意的地方：</span></div></li><li><div><span style="font-family: georgia;">__weakref__:用户定义的类（而不是实例）中默认就有__weakref__,可是如果在类中定义了slots属性，想要把实例作为弱引用的目标，就要把__weakref__添加到__slots__中</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">9. 对象比较</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__lt__(self, obj)/__le__(self, obj)：小于/小于等于，&lt;/&lt;=</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__gt__(self, obj)/__ge__(self, obj): 大于/大于等于，&gt;/&gt;=</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__eq__(self, obj)/__ne__(self, obj): 等于/不等于，=/!=</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">10.属性访问：</span></div><div><ol><li><div><span style="font-family: georgia, palatina, serif;">__getattribute__(self,name)：当特性name被访问时自动被调用</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__getattr__(self,name)：当特性name被访问且对象没有这个属性/方法 时被自动调用，这个特殊方法的返回值会赋给没有的这个属性/方法;如果有这个属性则不会调用到这个特殊方法；如果定于了__getattr__方法也要定义__setattr__方法，以防对象的行为不一致</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__setattr__(self,name,value)：当试图给特性name赋值时自动被调用</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__delattr__(self,name)：当试图删除特性name时自动被调用</span></div></li></ol><ul><li><div><span style="font-family: georgia, palatina, serif;">注意：</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">_setattr__和__delattr__方法需要添加一些额外的逻辑来区分代理实例本身的属性和内部对象上的属性，常见的用法是代理类只委托那些不以下划线开头的属性，即代理类的属性都是以下划线开头</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__getattr__通常不适用于大部分以双下划线开头和结尾的特殊方法如__len__等，为了支持这些方法，必须手动实现</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__getattr__()和__getattribute__()的区别？前者只会在待访问属性不存在时触发(看调用顺序就知道)，而后者在每次访问属性时触发</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">如果要在__getattribute__和__setattr__方法中访问实例属性，应该直接通过super()来做避免无限递归</span></div></li></ul></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">11.拷贝：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__copy__():</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__deepcopy__():</span></div></li></ul><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">12.迭代协议：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__iter__(self)：要求返回一个特殊的迭代器对象，由该对象实现的__next__方法来完成实际的迭代，并通过 </span><span style="font-family: georgia, palatina, serif;">StopIteration</span><span style="font-family: georgia, palatina, serif;"> 异常标识迭代的完成；想要使自定义的类支持迭代操作，需要实现这个方法，可以这样实现：在__iter__方法内将迭代请求委托到对象内部持有的容器上(使用iter内建函数)，这是最快捷的方式；（</span><span style="color: rgb(255, 0, 0); font-family: georgia, palatina, serif;">如果在迭代的时候不需要使用for循环，需要先调用iter函数 cookbook4.6）</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__next__(self,)：返回下一个可用的元素，如果没有元素了抛出StopIteration异常</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__reversed__</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">13.自定义类：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">__add__(self, obj): 加法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__sub__(self, obj): 减法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__mul__(self, obj): 乘法</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__div__(self, obj): 除法</span></div></li><li><div><br clear="none"/></div></li></ul><div><span style="font-family: georgia, palatina, serif;">14. 数值转换：</span></div><ul><li><div>__abs__(self): 绝对值；abs内置方法</div></li><li><div>__bool__():</div></li><li><div>__int__</div></li><li><div>__float__:</div></li><li><div>__hash__</div></li><li><div>__index__</div></li><li><div>__complex__</div></li></ul><div>15：可哈希：为了使自定义类型为可哈希的，必须要实现__hash__方法和__eq__方法</div><div><br clear="none"/></div><div><div><span style="font-family: georgia, palatina, serif;">. 其他属性：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">c.__module__: c定义所在的模块，也就是定义它的模块名，这个名字用于生成 __repr__()方法的输出，如果是正在运行的文件，该文件中的类的__module__就是__main__</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__call__: 在调用实例的属性或方法时会调用；实现这个方法是创建函数式类实例的简便方式，一般的类实例通过调用类方法或属性，但实现了这个特殊方法后，直接用类实例带个参数(类似与函数)就可以调用了，运行后会进入call方法。此时必须在内部维护一个状态，让她在调用之间可用<span style="font-family: georgia, palatina, serif; color: rgb(255, 0, 0);">为什么调完call方法就进入到init方法了；</span></span></div></li><li><div><span style="font-family: georgia, palatina, serif;">c.__name__:如果c是一个函数，这个返回值就是函数名,返回的是一个字符串</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">c.__class__: 返回的是类自身</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">c.__bool__: 在默认情况下，自定义类的实例总被认为是真，除非这个类对__bool__或__len__函数有自己的实现</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__missing__: </span></div></li><li><div><span style="font-family: georgia, palatina, serif;">标准库有三个关于序列和映射规则可以立即使用的实现：UserList，UserString，UserDict</span></div><div><span style="font-family: georgia, palatina, serif;">静态方法和类成员方法在定义时在创建时被装入Staticmethod和Classmethod中</span></div><div><span style="font-family: georgia, palatina, serif;">拦截对象的所有特性访问：</span></div><div><span style="font-family: georgia, palatina, serif;">所有的映射类型在找不到键的时候都会牵扯到__missing__方法</span></div><div><span style="font-family: georgia, palatina, serif;">__missing__方法只会被__getitem__调用？——fluent3.4.2</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__contains__: </span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__code__: </span></div></li></ul></div><div><br clear="none"/></div></div><div><br clear="none"/></div></span>
</div></body></html> 