<html>
<head>
  <title>threading</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="582"/>
<h1>threading</h1>

<div>
<span><div><span style="font-family: georgia, palatina, serif;">避免使用thread模块的原因：</span></div><ol><li><span style="font-family: georgia, palatina, serif;">主线程结束时，所有其他线程都强制结束，不会发出警告或进行适当清理</span></li><li><span style="font-family: georgia, palatina, serif;">不支持守护线程的概念</span></li></ol><div><span style="font-family: georgia, palatina, serif;"><strong>守护线程</strong>，其工作方式为，守护线程一般是一个等待客户端请求服务的服务器，如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置为守护线程，就表示这个线程不重要，进程退出时不需要等待这个线程执行完成</span></div><div><span style="font-family: georgia, palatina, serif;">要将一个线程设置为守护线程，需要在启动线程之前赋值如下：thread.daemon=True；同样，要检查线程的守护状态也需要检查这个值</span></div><div><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></div><ul><li><span style="font-family: georgia, palatina, serif;"><span>Python解释器直到所有线程都终止前仍保持运行，<span>对于需要长时间运行的线程或者需要一直运行的后台任务，你应当考虑使用守护线程</span></span></span></li><li><span style="font-family: georgia, palatina, serif;">没有终止线程，给线程发信号，调整线程调度属性等其他操作，需要自己去构建</span></li><li><span style="font-family: georgia, palatina, serif;">涉及到线程同步的问题比较麻烦，更明智的做法是利用队列或者<span style="color: #ff0000;"><strong>actor模式</strong></span>完成线程间的通信任务</span></li><li><font face="georgia, palatina, serif">应当避免编写线程数量无限增长的程序，可以使用concurrent.futures中的线程池</font></li></ul><div><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-size: 14px;"><strong>1.模块级方法</strong></span>：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">active_count(): 当前活动的Thread对象的个数</span></li><li><span style="font-family: georgia, palatina, serif;">curent_thread(): 返回当前的Thread对象</span></li><li><span style="font-family: georgia, palatina, serif;">enumerate(): 返回当前活动的Thread对象的列表</span></li><li><span style="font-family: georgia, palatina, serif;">stack_size([size]):将栈的大小调低。注意，线程栈的大小至少有32768字节，通常会限制该值为系统内存页面大小</span></li><li><span style="font-family: georgia, palatina, serif;">threading.local():创建一个线程本地存储对象，创建的实例为每个线程维护着一个单独的实例字典。所有对实例的常见操作如获取，设定，删除都是只作用于每个线程专有的字典上</span></li></ul><div><span style="font-family: georgia, palatina, serif;"><strong>对象</strong>：</span></div><div><span style="font-family: georgia, palatina, serif;"><strong>2.Thread(group=None,target=None,name=None,args=(),kwargs={},*,daemon=None)：表示一个执行线程的对象</strong></span></div><ul><li><span style="font-family: georgia, palatina, serif;">属性：</span><ul><li><span style="font-family: georgia, palatina, serif;">name：线程名</span></li><li><span style="font-family: georgia, palatina, serif;">ident：线程标识符，线程还没有起来的时候为None</span></li><li><span style="font-family: georgia, palatina, serif;">daemon：是否为守护线程</span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">方法：</span><ul><li><span style="font-family: georgia, palatina, serif;">start(): 开始执行线程，<span>线程一旦启动，将独立执行直到目标函数返回，通过is_alive()<span>可以查询一个线程对象的状态，看它是否还在执行</span></span></span></li><li><span style="font-family: georgia, palatina, serif;">run(): 定义线程功能的方法</span></li><li><span style="font-family: georgia, palatina, serif;">join(): 直至启动的线程终止之前一直挂起，除非给出了timeout，否则一直阻塞；join方法只有在需要等待线程完成的时候才有用</span></li><li><span style="font-family: georgia, palatina, serif;">is_alive(): 判断一个线程是否是活的</span></li></ul></li></ul><div><span style="font-family: georgia, palatina, serif;">启动一个线程的方法：</span></div><ol><li><span style="font-family: georgia, palatina, serif;">实例化Thread, target是可调用对象，由run调用，args是target的参数</span></li><li><span style="font-family: georgia, palatina, serif;">继承类threading.Thread</span></li></ol><div><span style="font-family: georgia, palatina, serif;">线程同步：threading模块的Lock，RLock，Condition，Semaphore，BoundedSemaphore都支持上下文管理器</span></div><div><span style="font-family: georgia, palatina, serif;">1.锁Lock</span></div><ul><li><span style="font-family: georgia, palatina, serif;">方法：</span><ul><li><span style="font-family: georgia, palatina, serif;">acquire(blocking=True, timeout=1): </span></li><li><span style="font-family: georgia, palatina, serif;">release(): 释放锁</span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">注意：</span><ul><li><span style="font-family: georgia, palatina, serif;">用到锁的地方应该这样写：每个线程只允许获取一把锁，如果无法做到就要在程序中引入更高级的避免死锁的技术——？？</span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">使用上下文管理器：Lock对象和with语句一起使用可以保证互斥，就是每次只有一个线程执行with语句块；with语句块在代码执行前自动获取锁，在执行结束后自动释放锁</span></li></ul><div><span style="font-family: georgia, palatina, serif;">2. 可重入锁RLock：可以被同一个线程多次获取，主要用来编写基于锁的代码，或者基于监视器的同步处理；当某个类持有这种类型的锁时，只有一个线程可以使用类中的全部函数或者方法——这个用法还没搞懂</span></div><div><span style="font-family: georgia, palatina, serif;">3.信号量Semaphore：共享计数器的同步原语，如果计数器非0，with语句会递减计数器并允许线程继续执行</span></div><ul><li>方法：<ul><li><span style="font-family: georgia, palatina, serif;">acquire(block=True, timeout=None): 默认值会一直阻塞直到有线程调用release；timeout如果指定时间，则在指定时间内阻塞</span></li><li><span style="font-family: georgia, palatina, serif;">release():</span></li></ul></li></ul><div><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></div><div><span style="font-family: georgia, palatina, serif;">4.事件Event：允许线程等待某个事件的发生。初始状态为0，如果事件没有被设置而线程正在等待该事件，线程就会被阻塞(进入休眠状态)直到事件被设置为止。当有线程设置了这个事件时，会唤醒所有等待该事件的线程</span></div><ul><li><span style="font-family: georgia, palatina, serif;">方法：</span><ul><li><span style="font-family: georgia, palatina, serif;">is_set(): </span></li><li><span style="font-family: georgia, palatina, serif;">set(): 将flag设置为True，所有等待的线程都会醒来</span></li><li><span style="font-family: georgia, palatina, serif;">clear(): 将flag重新设置为False。虽然可以清楚事件，但不推荐</span></li><li><span style="font-family: georgia, palatina, serif;">wait(timeout=None)：阻塞，直到另一个线程调用set()方法将flag设置为True，或者timeout超时</span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">讨论：</span><ul><li><span style="font-family: georgia, palatina, serif;">Event最好只用于一次性事件，也就是说，创建一个事件，让线程等待事件被设置，一旦完成设置Event对象就被丢弃</span></li><li><span style="font-family: georgia, palatina, serif;">如果线程打算重复通知某个事件，最好使用condition对象来处理</span></li><li><span style="font-family: georgia, palatina, serif;">关键特性是唤醒所有等待的线程，所以如果希望唤醒的是一个单独的等待线程，最好使用Semaphore或者Condition</span></li></ul></li></ul><div><span style="font-family: georgia, palatina, serif;">5.条件Condition：如果线程打算一遍又一遍的重复通知某个事件，就使用condition对象来处理</span></div><ul><li><span style="font-family: georgia, palatina, serif;">方法：</span><ul><li><span style="font-family: georgia, palatina, serif;">wait(timeout=None)：等待通知或超时；需要在其他线程调用notify/notify_all才能重新获得锁并返回；如果没有获得锁去调用会抛出RuntimeError的错误</span></li><li><span style="font-family: georgia, palatina, serif;">notify(n=1)：</span></li><li><span style="font-family: georgia, palatina, serif;">notify_all(): 唤醒所有在等condition的线程</span></li></ul></li></ul><div><span style="font-family: georgia, palatina, serif;"><strong>事项</strong>：</span></div><div><span style="font-family: georgia, palatina, serif;">1.避免死锁</span></div><div><span style="font-family: georgia, palatina, serif;">2.保存线程专有状态，这个状态对其他线程是不可见的：通过threading.local()创建一个线程本地存储对象，在这个对象上保存和读取的属性只对当前运行的线程可见，其他线程无法感知</span></div></span>
</div></body></html> 