<html>
<head>
  <title>re</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="545"/>
<h1>re</h1>

<div>
<span><div><span style="font-family: georgia, palatina, serif;">推荐使用预编译成正则表达式对象再进行操作。但预编译并不是必须的，如果需要编译就使用编译过的方法，如果不需要就是用函数，函数名和方法名是相同的</span></div><div><span style="font-family: georgia, palatina, serif;">compile(pattern, flags=0):编译正则表达式的模式，返回一个<span style="font-family: georgia, palatina, serif; font-weight: bold;">正则表达式对象</span></span></div><div><span style="font-family: georgia, palatina, serif; font-weight: bold;">1.以下两个方法返回 匹配(match) 对象，可以用在正则表达式对象之后：</span></div><div><span style="font-family: georgia, palatina, serif;">     match(pattern, string, flags=0)：从字符串的开头找到匹配项，只匹配开头，后面即使有也不匹配，匹配不到返回None</span></div><div><span style="font-family: georgia, palatina, serif;">     search(pattern, string, flags=0)：查找模式，不但搜索模式在字符串中第一次出现的位置，而且严格地对字符串从左到右搜索，匹配不到返回None, 注意：这个方法从左到右只搜索第一个匹配到的地方后就不会往后搜索了</span></div><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">    match对象的以下三个方法，这两个方法是用来匹配子组的，如果要查找所有符合pat的元素应该使用findall/finditer等</span>：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">group([</span><span style="font-family: georgia, palatina, serif; font-style: italic;">group1</span><span style="font-family: georgia, palatina, serif;">, </span><span style="font-family: georgia, palatina, serif; font-style: italic;">...</span><span style="font-family: georgia, palatina, serif;">]):返回一个元组，要么返回整个匹配对象(参数为0或没有，没有默认为0)，要么根据要求返回特定子组(参数可为多个)，子组是从1开始的，返回的是捕获组的内容，如果匹配不到返回为None；如果是指定命名组名称，可以将名称字符串作为group的参数返回对应的键值；异常：IndexError</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">groups():返回一个包含唯一或全部子组的元组。</span><span style="font-family: georgia, palatina, serif; color: #ff6600;">只匹配子组，</span><span style="font-family: georgia, palatina, serif;">如果没有子组，group()仍然返回整个匹配时，但groups返回一个空元组</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">groupdict(default=None):返回一个以名字命名的子组的字典。返回所有匹配到的字典，这个方法貌似只用在使用 ?P&lt;name&gt; 指定子组名字的对象</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-weight: bold;">2.查找</span>：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">findall</span><span style="font-family: georgia, palatina, serif;">(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">pattern</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">string</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">flags=0</span><span style="font-family: georgia, palatina, serif;">)：在string中找到所有匹配pattern的所有字符串，以列表的形式返回</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">finditer</span><span style="font-family: georgia, palatina, serif;">(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">pattern</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">string</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">flags=0</span><span style="font-family: georgia, palatina, serif;">)：功能上，返回一个迭代器，以迭代的方式返回匹配对象：注意返回的是match对象</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">注：search的group和查找中的findall方法有挺大的区别</span></div><div><span style="font-family: georgia, palatina, serif;">怎样让{}和search/findall配合使用？目前展示的效果是只能找到第一个</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div><strong><span style="font-family: georgia, palatina, serif;">3.替换</span></strong></div><div><span style="font-family: georgia, palatina, serif;"> sub</span><span style="font-family: georgia, palatina, serif;">(</span><span style="font-family: georgia, palatina, serif; font-style: italic;">pattern</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">repl</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">string</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">count=0</span><span style="font-family: georgia, palatina, serif;">,</span> <span style="font-family: georgia, palatina, serif; font-style: italic;">flags=0</span><span style="font-family: georgia, palatina, serif;">)：在string中把pattern模式替换为repl，返回替换后的字符串，原string不变</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">第一个参数是要匹配的模式</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">第二个参数是要替换的模式。类似“\6”这样的反斜线加数字的符号代表模式中捕获组号对应的字符串</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对于更复杂的情况，可以将第二个参数替换为一个回调函数，该函数返回一个用来替换的字符串，入参是一个匹配对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">对于第二个参数是回调函数的情况：</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">  subn():和sub一样，但还返回一个表示替换的总数，替换后的字符串和表示替换总数的数字作为一个拥有两个元素的元组返回</span></div><div><span style="font-family: georgia, palatina, serif;">现在有个问题：怎样替换多个正则表达式对象？</span></div><div><br clear="none"/></div><div><strong><span style="font-family: georgia, palatina, serif;">4.其他方法</span></strong></div><div><span style="font-family: georgia, palatina, serif;">split(pattern,string,maxsplit=0,flag=0)：根据pattern指定的模式分解string，返回一个列表</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">概念：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">捕获组： <span style="letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; font-family: georgia, palatina, serif; color: #000000; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: 400; text-decoration-color: initial; text-decoration-style: initial;">就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。只要用到()的地方就会引入捕获组？捕获组能将每个组的内容单独取出来</span></span></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; font-family: georgia, palatina, serif; color: #000000; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: 400; text-decoration-color: initial; text-decoration-style: initial;">5.<span style="color: #ff0000;">scanner()</span>：(这个方法在手册中没找到)创建一个scanner对象，在这个对象上不断调用match方法会一步步扫描目标文本：cookbook2.18，用的比较少；</span></span></div><div><span style="color: #000000; font-family: georgia, palatina, serif;">  里面还有两个方法/属性：</span></div><ul><li><span style="color: #000000; font-family: georgia, palatina, serif;">lastgroup：命名组的捕获名称</span></li><li><span style="color: #000000; font-family: georgia, palatina, serif;">group()：捕获到的内容</span></li></ul><div><br clear="none"/></div><div><span style="color: #000000; font-family: georgia, palatina, serif;">扩展表示法：</span></div><div><span style="color: #000000; font-family: georgia, palatina, serif;">1. 扩展表示法都是以？开始，通常是用于在判断匹配之前提供标记，实现一个 前视匹配或条件检查</span></div><div><span style="color: #000000; font-family: georgia, palatina, serif;">2. 尽管也是用（），但只有(?P&lt;name&gt;)表示一个匹配分组，其他都没有创建一个分组</span></div><div><span style="color: #000000; font-family: georgia, palatina, serif;">(...)：指定一个捕获组</span></div><div><span style="font-family: georgia, palatina, serif;">(?:...)：指定一个非捕获组，即只做匹配不捕获结果，也不分配组号，适用于match对象和正则表达式对象</span></div><div><span style="font-family: georgia, palatina, serif;">(?P=name):</span></div><div><span style="font-family: georgia, palatina, serif;">(?P&lt;name&gt;):可以指定匹配组的别名，用group('name')可以访问</span></div><div><span style="font-family: georgia, palatina, serif;">(?aiLmsux): 不匹配任何字符串，相当于re.A/re.I/re.L/re.M/re.S/re.U/re.X; 比如指定(?i)xxx，表示匹配时不区分大小写；如果想在正则表达式而不是re.compile中指定标记，这是种好方式</span></div><div><span style="font-family: Monaco, Courier, monospace;">(?#...)：不做匹配，只作为注释，<span style="font-family: Monaco, Courier, monospace; color: #ff0000;">待验证</span></span></div><div><span style="font-family: Monaco, Courier, monospace;">(?=...):如果一个字符串后面跟着...才匹配，<span style="font-family: Monaco, Courier, monospace; color: #ff0000;">待验证</span></span></div><div><span style="font-family: Monaco, Courier, monospace;">(?!...)：如果一个字符串后面不跟...才匹配，<span style="font-family: Monaco, Courier, monospace; color: #ff0000;">待验证</span></span></div><div><span style="font-family: Monaco, Courier, monospace;">(?&lt;=...):如果一个字符串前面为...才匹配，<span style="font-family: Monaco, Courier, monospace; color: #ff0000;">待验证</span></span></div><div><span style="font-family: Monaco, Courier, monospace;">(?&lt;!...):如果一个字符串前面不为...才匹配，<span style="font-family: Monaco, Courier, monospace; color: #ff0000;">待验证</span></span></div><div><span style="font-family: Monaco, Courier, monospace;">(?(id/name)yes-pat|no-pat):如果一个匹配组id或name存在则与yes-pat匹配，否则与no-pat匹配，</span><span style="font-family: Monaco, Courier, monospace; color: #ff0000;">待验证</span><span style="font-family: Monaco, Courier, monospace;">；</span></div><div><br clear="none"/></div><div>.：<span style="font-family: georgia, palatina, serif;">默认是匹配除换行之外的所有字符</span></div><div><span style="font-family: georgia, palatina, serif;">^: 匹配字符串的开始位置</span></div><div><span style="font-family: georgia, palatina, serif;">$: 匹配字符串的结束位置</span></div><div><span style="font-family: georgia, palatina, serif;">*: 匹配0次，1次或多次前面出现的字符</span></div><div><span style="font-family: georgia, palatina, serif;">\s：匹配任何空格字符（包括\n:换行，\t:）</span></div><div><span style="font-family: georgia, palatina, serif;">\S: 匹配除空白字符之外的任意一个字符</span></div><div><span style="font-family: georgia, palatina, serif;">\w：Unicode下能匹配</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">数字</span><span style="font-family: georgia, palatina, serif;">，</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">字母</span><span style="font-family: georgia, palatina, serif;">，</span><span style="font-family: georgia, palatina, serif; font-weight: bold;">下划线</span><span style="font-family: georgia, palatina, serif;">，还能匹配<strong>汉字</strong>等<strong>其他语言的字母</strong>，但不能匹配标点如'；', 也不能匹配注释符\\也不匹配空格等，如果设置了是ASCII只匹配大小写字母和数字，与\W相反</span></div><div><span style="font-family: georgia, palatina, serif;">\d: 匹配任意一个十进制数</span></div><div><span style="font-family: georgia, palatina, serif;">\D: 匹配除十进制数之外的任意一个其他字符</span></div><div><span style="font-family: georgia, palatina, serif;">flags：</span></div><div><span style="font-family: georgia, palatina, serif;">a{m}:匹配m个a<br clear="none"/></span></div><div><span style="font-family: georgia, palatina, serif;">a{m, n}:匹配a出现m到n次，如果忽略m,默认为0，如果忽略n，默认为最少匹配m次</span></div><div><span style="font-family: georgia, palatina, serif;">[]:多种用法：<br clear="none"/></span></div><ul><li><span style="font-family: georgia, palatina, serif;">eg. [amk]:匹配a，m或k<br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">eg. [1-9][a-z]:通过“-”指定范围，可以匹配1到9，a到z任意一个数字或字母<br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></li></ul><div><br clear="none"/></div><div>re.ASCII:只匹配ASCII字符</div><div><span style="font-family: georgia, palatina, serif;">re.</span><span style="font-family: georgia, palatina, serif;">I</span></div><div><span style="font-family: georgia, palatina, serif;">re.</span><span style="font-family: georgia, palatina, serif;">IGNORECASE：不区分大小写，这两种形式都可以</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">re.</span><span style="font-family: georgia, palatina, serif;">S</span></div><div><span style="font-family: georgia, palatina, serif;">re.</span><span style="font-family: georgia, palatina, serif;">DOTALL：这个标志可以让”.“匹配任何字符包括换行符，主要也就是用来匹配换行符”\n“的</span></div><div><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></div><div><span style="font-family: georgia, palatina, serif;">re.M/re.MULTILINE: 可以匹配多行</span></div><div><span style="font-family: Monaco, Courier, monospace;">使用心得：</span></div><ol><li><div><span style="font-family: Monaco, Courier, monospace;">使用&quot;(xx)&quot;捕获组时，如果存在&quot;(xx(xx)xx)&quot;情况，里面的捕获号次于外侧捕获号</span></div></li><li><div><span style="font-family: Monaco, Courier, monospace;">一般情况下都是贪婪匹配，可以在&quot;*&quot;, &quot;+&quot;, &quot;?&quot;之后再加上&quot;?&quot;达到非贪婪（紧跟*，+，？）(cookbook2.7)</span></div></li></ol><div>需要转义的特殊字符：+；*</div></span>
</div></body></html> 