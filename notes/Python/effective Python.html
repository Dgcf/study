<html>
<head>
  <title>effective Python</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="758"/>
<h1>effective Python</h1>

<div>
<span><div>1. 遵循PEP8分割<br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">2. 了解bytes，str和Unicode的区别</span></div><div><span style="font-family: georgia, palatina, serif;">3. 用辅助函数来取代复杂的表达式</span></div><div><span style="font-family: georgia, palatina, serif;">4. 了解切割序列的办法——见内建类型</span></div><div><span style="font-family: georgia, palatina, serif;">5. 在单次切片操作中，不要同时指定start, end, stride</span></div><div><span style="font-family: georgia, palatina, serif;">6. 用列表推导来取代map和filter</span></div><ul><li><span style="font-family: georgia, palatina, serif;">列表推导式比map和filter清晰，因为无需编写lambda表达式</span></li><li><span style="font-family: georgia, palatina, serif;">列表推导式可以跳过输入列表中的某些元素，如果改用map就必须辅以filter</span></li></ul><div><span style="font-family: georgia, palatina, serif;">8. 不要使用含有两个以上表达式的列表推导：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">列表推导式是按从左到右执行的</span></li><li><span style="font-family: georgia, palatina, serif;">列表推导支持多个if语句，处在同一循环级别中的多项条件彼此之间默认形成and表达式，b=[x for x in a if x &gt; 4 if x % 2 == 0]和c=<span>[x for x in a if x &gt; 4 and if x % 2 == 0]是等效的</span></span></li></ul><div><span style="font-family: georgia, palatina, serif;">9. 用生成器表达式来改写数据量较大的列表推导：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">当输入数据量过大时，列表推导可能会因内存过大出现问题</span></li><li><span style="font-family: georgia, palatina, serif;">把列表推导所用的写法放在一对圆括号中就构成了生成器表达式</span></li><li><span style="font-family: georgia, palatina, serif;">由生成器表达式返回的迭代器可以逐次产生输出值，从而避免了内存用量问题</span></li></ul><div><span style="font-family: georgia, palatina, serif;">10. 尽量用enumerate取代range——见内建函数</span></div><div><span style="font-family: georgia, palatina, serif;">11. 用zip函数同时遍历两个迭代器：会把两个及以上的迭代器封装成生成器，——具体见内建函数</span></div><div><span style="font-family: georgia, palatina, serif;">12. 不要在for或while循环后面写else块：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">有种特殊语法，在for和while循环内部语句块之后会紧跟一个else块，仅当循环中途break不会执行，其他情况下都会执行，不建议使用这种语法</span></li></ul><div><span style="font-family: georgia, palatina, serif;">13. 合理利用try/except/else/finally结构中的每个代码块——见异常总结</span></div><div><span style="font-family: georgia, palatina, serif;">14. 尽量用异常来表示特殊情况，而不要返回None</span></div><ul><li><span style="font-family: georgia, palatina, serif;">用None作为返回值容易使调用者犯错，因为None和0，空字符串在条件表达式里会被判断为False</span></li><li><span style="font-family: georgia, palatina, serif;">遇到特殊情况应抛出异常而不是返回None</span></li></ul><div><span style="font-family: georgia, palatina, serif;">15. 了解如何在闭包里使用外围作用域中的变量——见基础部分</span></div><div><span style="font-family: georgia, palatina, serif;">16. 考虑用生成器来改写直接返回列表的函数：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">使用生成器比把结果放到列表里给调用者更加清晰</span></li></ul><div><span style="font-family: georgia, palatina, serif;">17. 在参数上面迭代时要多加小心：如果传给参数的是一个迭代器，注意该迭代器只能消费一次，有三种方法可以解决这个问题：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">明确使用该迭代器复制到一份列表里面，可能风险：如果含有大量数据，可能会导致内存耗尽崩溃</span></li><li><span style="font-family: georgia, palatina, serif;">通过参数调用另外一个函数，这个函数每次调用完之后都会返回新的迭代器</span></li><li><span style="font-family: georgia, palatina, serif;">自定义实现迭代器协议__iter__</span></li></ul><div><span style="font-family: georgia, palatina, serif;">18. 用数量可变的位置参数减少视觉杂讯，在def语句中使用*args可令函数接受数量可变的位置参数</span></div><ul><li><span style="font-family: georgia, palatina, serif;">调用函数时使用*操作符，可把序列(这个序列也可以是迭代器)中的元素当成是位置参数传给函数</span></li></ul><div><span style="font-family: georgia, palatina, serif;">19. 使用关键字参数，</span></div><div><span style="font-family: georgia, palatina, serif;">20. 动态/可变默认值的参数怎样定？</span></div><div><span style="font-family: georgia, palatina, serif;">    例子：def log(message, when=datetime.now()):</span></div><div><span style="font-family: georgia, palatina, serif;">                     print('%s: %s' % (when, message))</span></div><div><span style="font-family: georgia, palatina, serif;">    datetime.now()只会执行一次</span></div><ul><li><span style="font-family: georgia, palatina, serif;">正确实现动态默认值是把默认值设为None，并在文档字符串中把None所对应的实际行为描述出来</span></li><li><span style="font-family: georgia, palatina, serif;">参数的默认值只在程序加载模块并读到本函数的定义时评估一次，所以如果默认参数是可变类型如{}或[]，一定要使用None作为形式上的默认值</span></li></ul><div><span style="font-family: georgia, palatina, serif;">21.  使用只能以关键字形式指定的参数使代码明确</span></div><ul><li><span style="font-family: georgia, palatina, serif;">对于各参数之间容易混淆的函数，用只能以关键字形式指定的参数来确保代码明晰：</span><ul><li><span style="font-family: georgia, palatina, serif;">py3中，在参数列表中加&quot;*&quot;，标志着位置参数就此终结，之后的参数必须以关键字形式指定</span></li><li><span style="font-family: georgia, palatina, serif;">py2中不支持&quot;*&quot;语法，可以使用**kwargs接受任意数量的关键字参数，即使某些关键字参数没有定义在函数中也依然能够接受</span></li></ul></li></ul><div><span style="font-family: georgia, palatina, serif;">类与继承：</span></div><div><span style="font-family: georgia, palatina, serif;">22. 1</span></div><div><span style="font-family: georgia, palatina, serif;">23. 函数参数使用挂钩函数的问题：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">函数和方法都可以像一级函数那样使用</span></li><li><span style="font-family: georgia, palatina, serif;">通过名为__call__的特殊方法，可以使类的实例能够像普通Python函数那样得到调用</span></li><li><span style="font-family: georgia, palatina, serif;">使用要记录状态的挂钩函数分为以下几种：</span><ul><li><span style="font-family: georgia, palatina, serif;">使用闭包</span></li><li><span style="font-family: georgia, palatina, serif;">使用类的方法实例</span></li><li><span style="font-family: georgia, palatina, serif;">使用定义了__call__的类实例</span></li></ul></li></ul><div><span style="font-family: georgia,palatina,serif;">24.1</span></div><div><span style="font-family: georgia,palatina,serif;">25. 以@classmethod形式的多态去通用的构建对象：也就是通过这种方式实现类似c++中的不同构造对象，因为Python只能有一个__init__构造器</span></div><ul><li><span style="font-family: georgia,palatina,serif;">通过@classmethod机制，可以用一种与构造函数相仿的方式来构造类的对象</span></li><li><span style="font-family: georgia,palatina,serif;">通过类方法多态机制，能够以更加通用的方式来构建并拼接具体的子类——这个还需要继续深入理解</span></li></ul><div><span style="font-family: georgia,palatina,serif;">26. </span></div><div><span style="font-family: georgia,palatina,serif;">27. 多用public属性，少用private属性</span></div><div><span style="font-family: georgia,palatina,serif;">28. 继承collections.abc以实现自定义的容器类型——这部分内容需要实战</span></div><ul><li><span style="font-family: georgia,palatina,serif;">如果要设计用法比较简单的序列，那就直接从Python的容器类型(如list或dict)中继承</span></li><li><span style="font-family: georgia,palatina,serif;">编写自定义的容器类型时，可以从collections.abc模块的抽象基类中继承，那些基类能够确保子类具备适当的接口及行为</span></li></ul><div><span style="font-family: georgia,palatina,serif;">31. 当存在大量需要使用@property方法及其验证机制的地方使用描述符：</span></div><ul><li><span style="font-family: georgia,palatina,serif;">WeakKeyDictionary可以保证描述符类不会泄露内存</span></li></ul><div><span style="font-family: georgia,palatina,serif;">37. 可以用线程来执行阻塞式IO，但不要用它做平行运算</span><br clear="none"/></div><ul><li><span style="font-family: georgia,palatina,serif;">由于受到全局解释器锁(GIL)的限制</span><br clear="none"/></li></ul><div><br clear="none"/></div></span>
</div></body></html> 