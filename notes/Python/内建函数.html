<html>
<head>
  <title>内建函数</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="559"/>
<h1>内建函数</h1>

<div>
<span><div><ul><li><div><span style="font-size: 11pt; font-family: Georgia;">ascii</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">id(object): 判断的是identity（Cython使用对象的内存作为对象唯一ID），<span style="font-size: 11pt; font-family: Georgia; color: rgb(255, 0, 255);">用is判断时就是判断id值</span></span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">bool([x])：返回一个 bool值True或False，参数如果为False或空返回False，否则为True；会调用x.__bool__(),如果不存在会尝试调用x.__len__</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">bytearray：</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">bytes：</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">exec(object [, globals [, locals]]): 动态执行一段python代码，但在函数体内执行是有坑的，参考cookbook9.23</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">locals(): </span></div></li><li><div><span style="font-size: 14.66px; font-family: Georgia;">input([prompt])：执行到该函数处停下来等待用户输入，promp是显示</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">hash()：判断参数是否是可哈希的（对于判断参数值能否作为字典键）</span></div></li><li><div><span style="font-size: 14.66px; font-family: Georgia;">hasattr(object, name)：object是一个对象，name是一个str，判断name是不是object的一个属性。返回True/False</span></div></li><li><div><span style="font-size: 14.66px;"><span style="font-size: 14.66px; font-family: Georgia;">getattr(object, name[, default])：name 是一个字符串, 返回object对象的name属性，getattr(x, 'foobar')==x.foobar, 如果这个属性不存在则返回default，否则抛出AttributeError；<span style="font-size: 14.66px; font-family: Georgia; color: rgb(255, 0, 0);">Object必须是类的实例？</span></span></span></div></li><li><div><span style="font-size: 14.66px;"><span style="font-size: 14.66px; font-family: Georgia;">setattr(object, name, value)：给实例对象object的name属性赋值，这个属性如果不存在则新建一个属性；注意：会调用__setattr__但并不会调用__set__</span></span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">callable(object)：参数是一个对象，判断对象是否是一个可调用对象，返回值为True或False</span></div></li><li><div><span style="font-size: 14.66px; font-family: Georgia;">super()：调用父类的方法，常见用途为：</span></div></li><ul><li><div><span style="font-family: Georgia; font-size: 14.66px; color: unset;">调用父类的__init__()方法，确保父类正确的初始化</span></div></li><li><div><span style="font-family: Georgia; font-size: 14.66px; color: unset;">当自己写的类覆盖了Python的特殊方法时调用原特殊方法</span></div></li><li><div><span style="font-family: Georgia; font-size: 14.66px; color: unset;">在多重继承如钻石形，使用类名调用方法有可能出现多次调用基类的方法，但使用super可以避免这种情况，因为super定义了方法解析顺序，会以标准流程安排超类之间的初始化顺序，也能保证钻石顶部的公共基类的__init__只会运行一次</span></div></li></ul><li><div><span style="font-size: 14.66px; font-family: Georgia;">注：</span></div></li><ul><li><div><span style="font-family: Georgia; font-size: 14.66px; color: unset;">基类没有__init__方法也是可以正常调用的</span></div></li><li><div><span style="font-family: Georgia; font-size: 14.66px; color: unset;">在py2中基类必须要继承自object，py3中可以不继承 </span></div></li></ul><li><div><span style="color: unset; font-size: 11pt; font-family: Georgia;">format(</span><span style="color: unset; font-size: 11pt; font-family: Georgia; font-style: italic;">value</span><span style="color: unset; font-size: 11pt; font-family: Georgia;">[,</span> <span style="color: unset; font-size: 11pt; font-family: Georgia; font-style: italic;">format_spec</span><span style="color: unset; font-size: 11pt; font-family: Georgia;">])：按照给出的format_spec格式输出value，format_spec格式比较多：如果要额外填充字符，需要在对齐字符之前指定，之后不行</span></div></li><ul><li><div><span style="font-family: Georgia; font-size: 11pt; color: unset;">'&lt;'：左对齐</span></div></li><li><div><span style="font-family: Georgia; font-size: 11pt; color: unset;">'&gt;'：右对齐</span></div></li><li><div><span style="font-family: Georgia; font-size: 11pt; color: unset;">'^'：居中对齐</span></div></li></ul><li><div><span style="font-size: 11pt; font-family: Georgia;">range(</span><span style="font-size: 11pt; font-family: Georgia; font-style: italic;">stop</span><span style="font-size: 11pt; font-family: Georgia;">)：start默认为0，step默认为1</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">range(</span><span style="font-size: 11pt; font-family: Georgia; font-style: italic;">start</span><span style="font-size: 11pt; font-family: Georgia;">,</span> <span style="font-size: 11pt; font-family: Georgia; font-style: italic;">stop</span><span style="font-size: 11pt; font-family: Georgia;">[,</span> <span style="font-size: 11pt; font-family: Georgia; font-style: italic;">step</span><span style="font-size: 11pt; font-family: Georgia;">])：start&lt;=k&lt;end, step不能为0，step默认值为1，返回一个范围列表（但并不是列表），返回的是一个可迭代对象；注意：不能完成对小数的操作</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">ord(</span><span style="font-size: 11pt; font-family: Georgia; font-style: italic;">c</span><span style="font-size: 11pt; font-family: Georgia;">)/chr(</span><span style="font-size: 11pt; font-family: Georgia; font-style: italic;">i</span><span style="font-size: 11pt; font-family: Georgia;">)：unicode编码和字符之间的转换，前者给定字符返回对应ascii值，后者相反</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">vars([object]):返回对象object的属性和属性值的字典对象(</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-family: Georgia;">返回的是个什么鬼？</span><span style="font-size: 11pt; font-family: Georgia;">)，对象实例也可作为参数，返回属性和属性值组成的字典(cookbook 2.15)； </span><span style="text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; font-size: 11pt; word-spacing: 0px; white-space: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Georgia; font-style: normal; font-weight: normal;">如果默认不输入参数，就打印当前调用位置的属性和属性值，相当于</span><span style="text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; font-size: 11pt; word-spacing: 0px; white-space: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Georgia; font-style: normal; font-weight: normal;">locals()</span><span style="text-align: left; text-transform: none; text-indent: 0px; letter-spacing: normal; font-size: 11pt; word-spacing: 0px; white-space: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Georgia; font-style: normal; font-weight: normal;">的功能——返回的是object的__dict__属性值</span></div></li><li><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">dir([object])：无参以列表返回当前范围的属性名，带参数则返回参数对象的属性名。与</span><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 153, 102); font-family: Georgia; font-weight: bold;">类中的__dict__有什么区别</span><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">？经测试，内建方法dir只返回属性名组成的</span><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; font-weight: bold;">列表</span><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">，而__dict__返回属性和属性值的键值对的</span><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; font-weight: bold;">字典；——不只是这一点区别，比如定义一个函数def func():pass,func.__dict__返回{}，dir(func)返回一堆东西</span></span></div></li><li><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">bytearray:返回一个字节数组</span></span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">slice(stop)/slice(start, end, step)：创建并返回一个(切片)slice对象，有三个只读属性：start，stop，step，可以通过对象实例访问，这个对象可以使用在任何支持切片操作的地方；有一个方法：indices(size), 这个方法返回一个三元组(start, stop, step)（cookbook1.11）</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">del：删除名称而不是对象，del命令可能会导致对象被当作垃圾回收，但仅当这个变量是对象的最后一个引用时</span></div></li></ul><div><span style="font-weight: bold;">高级函数</span>：</div><ul><li><div><span style="font-size: 11pt; font-family: Georgia;">filter(</span><span style="font-size: 11pt; font-family: Georgia; font-style: italic;">function</span><span style="font-size: 11pt; font-family: Georgia;">,</span> <span style="font-size: 11pt; font-family: Georgia; font-style: italic;">iterable</span><span style="font-size: 11pt; font-family: Georgia;">)：给定一个序列对象和一个过滤函数，每个序列元素都会被过滤函数筛选，保留函数</span><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">返回为真</span><span style="font-size: 11pt; font-family: Georgia;">的元素(以boolean值作为判断标准)，返回一个迭代器，经实测，返回的迭代器</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-family: Georgia;">只能消费一次————返回的是生成器</span></div></li><li><div style="padding: 8px; border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902); box-sizing: border-box; background-color: #fbfaf8;"><div><span style="background-color: rgb(251, 250, 248); font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">filter(function, iterable)相当于(item for item in iterable if function(item))</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">filter(None, iterable)相当于(item for item in iterable if item)</span></div></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">map(function, iterable, ... ):类似于filter, map是直接将函数function作用于iterable上的每个元素，而不是过滤，返回产生结果的迭代器，经实测，返回的迭代器只能消费一次；————返回的是生成器，等同于(function(item)  item for item in iterable)；如果传入的是n个可迭代对象，那么func必须能接受n个参数，而且要并行处理各个可迭代对象</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">注：filter和map由于引入了列表推导式和生成器表达式变得没有那么重要了(fluent5.2)</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">匿名函数存在的原因就是为了高阶函数使用便利</span></div></li></ul><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia; font-weight: bold;">归约函数</span>：接受一个可迭代对象，然后返回单个结果：</span></div><ul><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">all(iterable)：参数为一个序列，序列中所有的元素都为True则为True,否则为False</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">any(iterable)：与all的作用相反，参数为一个序列，序列中有一个为True则为True</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">max(iterable,*[,key,default])/ max(arg1, arg2, *arg[,key])：key可以是一个lambda表达式</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">min：</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">sum(iterable[, start])：从可迭代对象的start开始，返回总和。start可选，默认为0.</span></div></li></ul><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia; font-weight: bold;">与序列相关的四个内建函数</span>：</span></div><ul><li><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">stored(iterable[,key][,reverse]):</span></span></div><div><span style="font-family: georgia, palatina, serif;"><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); font-family: georgia, palatina, serif; color: rgb(51, 51, 51);">返回值</span></span><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); font-family: georgia, palatina, serif; color: rgb(51, 51, 51);">：</span></span>返回一个由参数iterable指定的序列经排序后的列表</span></div><div><span style="font-family: georgia, palatina, serif;">参数：</span></div><div><span style="font-family: georgia, palatina, serif;">     key是一个可调用的对象，该对象从iterable中接收并返回一个用来作为排序依据的值；</span></div><div><span style="font-family: georgia, palatina, serif;">     reversed用来确定是不是要按反序来，默认为False</span></div><div><span style="font-family: georgia, palatina, serif;">注意：如果iterable是一个dict，是按字典的key进行排序的，类似key中既有字符串又有数字的这种情况会抛出TypeError的异常；如果是数字的话，默认是按从小到大的顺序排列的</span></div></li><li><div><span style="font-size: 11pt;"><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">zip(</span></span><span style="background-color: #ffffff;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">*iterables)：返回一个元组的迭代器，（创建的只是迭代器）每个参数都会有一个元素成为返回元组中的成员；它的内容只能被使用一次；整个迭代的长度和其中最短的输入序列的长度相同，如果迭代的长度和最长的序列长度相同，使用itertools.zip_longest; 可以使用dict/list将zip的返回值分别转为字典/列表进行保存，有两个问题：</span></span></span></div></li><ul><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">py3中的zip相当于</span><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; text-decoration-line: underline;">生产器</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">，但py2中zip并不是生成器，所以会把产生的元组组成的列表完整的返回，这可能会占用大量内存并导致程序崩溃，应该使用itertools内置模块中的izip函数</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia; font-size: 11pt;">迭代器长度不同会自动提前终止，若不能确定zip所封装的列表是否等长，应考虑使用itertools内置模块中的zip_longest函数，这个函数会平行遍历多个迭代器而不用在乎长度是否相等</span></div></li></ul><li><div><span style="background-color: #ffffff;"><span style="background-color: #ffffff;"><span style="background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">enumerate(iterable, start=0):返回值是一个enumerate对象实例(</span><span style="background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(255, 0, 0); font-family: Georgia;">经测试是tuple类型？</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia;">)(索引-值的形式)，是一个迭代器,（__next__()方法返回的是元组）该迭代器是由元组构成，元组由1从start开始的数字和2 iterable的每个成员组成</span></span></span></div><div><span style="background-color: #ffffff;"><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">在遍历迭代器时获知每个元素的索引</span></span></span></div><div><span style="background-color: #ffffff;"><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">可用来改写将range和下标访问相结合的序列遍历代码</span></span></span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: georgia, palatina, serif;">seasons=['Spring', 'Summer', 'Fall', 'Winter']</span></div><div><span style="font-family: georgia, palatina, serif;">list(enumerate(seasons, start=1))</span></div><div><span style="font-family: georgia, palatina, serif;">[(1, 'Spring'),(2, 'Summer'),(3,'Fall'),(4, 'Winter')]</span></div></div><ul><li><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">len():如果是字典会返回键值对的数目，</span><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; font-weight: bold;">会调用__len__()方法</span></span></div></li></ul><div><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;"><span style="background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: Georgia; font-weight: bold;">与迭代器相关</span>：</span></span></div><ul><li><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">iter(object[,sentinel])：对一个对象调用iter就可以得到它的迭代器；如果没有第二个参数，object必须是一个支持迭代协议__iter__() 的集合或支持序列协议__getitem__()的整数参数从0开始的函数；如果给出了第二个参数，object必须是一个可调用对象（如函数，每次迭代运行这个函数，直到遇到sentinel时终止），此时iter创建了一个迭代器对象，每次调用这个迭代器__next__方法时都会调用到object，如果__next__方法等于第二个参数值，抛出StopIteration，否则返回下一个值</span></span></div><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">如果不支持这两个协议，抛出TypeError异常；</span></span></div><div><span style="font-size: 14.66px; color: rgb(51, 51, 51); font-family: Georgia;">必须要支持</span><span style="font-size: 14.66px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; font-style: italic; font-weight: bold;">迭代协议 </span><span style="font-size: 14.66px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">或者</span><span style="font-size: 14.66px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; font-style: italic; font-weight: bold;">序列协议 </span><span style="font-size: 14.66px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">，即实现了</span><span style="font-size: 14.66px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; font-style: italic;">__iter__() </span><span style="font-size: 14.66px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">或</span><span style="font-size: 14.66px; color: rgb(51, 51, 51); font-family: Georgia; font-style: italic;">__getitem__()</span></div><div><span style="caret-color: #333333;"><span style="color: rgb(51, 51, 51); font-family: Georgia; font-style: italic;">Iter(s)通过调用s.__iter__（）返回底层的迭代器</span></span></div><div><span style="font-size: 14.66px; color: rgb(51, 51, 51); font-family: Georgia;">可以接受一个无参的可调用对象以及一个结束值，以这种方式调用时，iter会创建一个迭代器，然后重复调用用户提供的可调用对象，直到返回结束止为止；这种特定的方式对于需要重复调用函数的情况实用</span></div><div><br clear="none"/></div><div><span style="font-size: 14.66px; color: rgb(51, 51, 51); font-family: Georgia;">问题：结束值起到什么作用——结束调用提供的方法，当这个方法返回的值等于结束值时</span></div></li></ul><div><span style="font-size: 14.66px; color: rgb(51, 51, 51); font-family: Georgia;">        检查一个对象是否可以迭代最准确的方法是iter(x)，如果不可迭代再处理TypeError异常</span></div><div><span style="font-size: 14.66px; color: rgb(51, 51, 51); font-family: Georgia;">         检查对象x是否为迭代器最好的方式是使用isinstance(x, abc.Iterator)</span></div><ul><li><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">any(iterable)/all(iterable):如果迭代器中某个/所有条目的值为真时返回True，否则为False</span></span></div></li><li><div><span style="background-color: #ffffff;"><span style="font-size: 11pt; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia;">eval(expression,global=None, locals=None)/repr(object): eval是</span></span>实现<span style="font-family: georgia, palatina, serif;">list、dict、tuple与str之间的转化，如果expression是字符串，会</span>转成相应的<span style="font-family: georgia, palatina, serif;">变量；如a='[1,2,3]', eval(a)=[1,2,3]，就是去掉引号；</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">next(iterator[, default]): 这个函数调用__next__()，手动访问可迭代对象中的元素；注意：如列表是不能直接使用next方法的，需要先使用iter转为iterator对象</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">reversed(seq)：实现反向迭代，反向迭代只有在待处理的对象拥有可确定的大小，或者对象实现了__reversed__()特殊方法时才能奏效，如果这两个条件都无法满足，则必须首先将对象转换成列表，但当文件太大转换成列表代价太高，所以自定义类型可以实现__reversed__方法；但要注意的一点是如果可迭代对象元素很多的话，将其预先转换为一个列表要消耗大量的内存。注：reversed在没有没有__reversed__的情况下也是合法的</span></div></li></ul><div><span style="font-size: 11pt; font-family: Georgia;"><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">类型函数</span>:</span></div></div><ul><li><div><span style="font-size: 11pt; font-family: Georgia;">int(x)</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">str():会将字典按字符串的形式表示</span></div></li><li><div><span style="font-size: 14.66px; font-family: Georgia;">list([iterable]):将可迭代对象转换为list</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">set([iterable])：创建集合</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">dict(**kwarg)/dict(mapping, **kwarg) / dict(iterable, **kwarg)</span></div></li><li><div><span style="font-size: 14.66px; font-family: Georgia; line-height: 23.04px;">repr(object): 将任意值转换为字符串</span></div></li></ul><div><span style="font-size: 14.66px; font-family: Georgia; line-height: 23.04px;"><span style="font-size: 14.66px; font-family: Georgia; line-height: 23.04px; font-weight: bold;">数学计算</span>：</span></div><ul><li><div><span style="font-size: 14.66px; font-family: Georgia; line-height: 23.04px;">abs(x)：返回参数的绝对值，注意参数必须是数字，如果是字母会返回NameError</span></div></li><li><div><span style="font-size: 14.66px; font-family: Georgia; line-height: 23.04px;">round(number[, ndigits]): </span></div></li></ul><div><span style="font-size: 11pt; font-family: Georgia;"><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">类型判断</span>：</span></div><ul><li><div><span style="font-size: 11pt; font-family: Georgia;">isinstance(object,classinfo): 如果object不是classinfo类型返回False，否则返回True;——尽量避免使用检查对象的类型——不符合面向对象编程</span></div></li><li><div><span style="font-size: 11pt; font-family: Georgia;">issubclass(class,classinfo):</span></div></li><li><div><span style="font-family: georgia, palatina, serif;"><span style="font-size: 11pt; font-family: georgia, palatina, serif;">type(object)/(name, bases, dict)：</span>一个参数的返回object的类型，相当于object.__class__。type(self).__name__是一种获取类名的方便技巧；另外一种完全不同的能力：动态创建一个类。name为类名，__name__的值，bases是一个元祖，基类名，也就是属性__bases__的值；dict是字典，中的值就是类的属性(实例属性还是类属性？)，如果是增加方法，先定义好方法，再在字典中指定，会同步在类的__dict__中；type是内建元类，是创建类的类；类function是创建函数的类，function, int，str等的__class__都是type</span></div></li></ul><div><span style="font-size: 11pt; font-family: Georgia;">二/八/十六进制转换：</span></div><ul><li><div><span style="font-size: 11pt; font-family: Georgia;">bin(x): 入参整数x转换为二进制字符串，<span style="font-size: 11pt; font-family: Georgia; color: rgb(255, 0, 0);">如果x不是python的int类型，必须要定义一个__index__()方法返回一个整数(没搞懂)</span></span></div></li><li><div><br clear="none"/></div></li></ul><div><span style="font-family: georgia, palatina, serif;"><span style="font-family: georgia, palatina, serif; font-weight: bold;">属性相关</span>：</span></div><ul><li><div><span style="font-family: georgia, palatina, serif;">property(fget=None, fset=None, fdel=None, doc=None): 返回的是一个</span><span style="color: rgb(255, 0, 255); font-family: georgia, palatina, serif; font-weight: bold;">特性（类属性）</span><span style="font-family: georgia, palatina, serif;">，关键是怎么用？cookbook9.19</span></div></li><li><div><span style="font-family: georgia, palatina, serif;">__import__：用于动态加载类和函数，如果一个模块经常变化就可以使用 __import__() 来动态载入。</span></div></li></ul><div><span style="font-family: georgia, palatina, serif;">问题：</span></div><ol><li><div><span style="font-family: georgia, palatina, serif;">vars，locals，dir，__dict__这几个的作用，区别？</span></div></li></ol></div><div><br clear="none"/></div></span>
</div></body></html> 