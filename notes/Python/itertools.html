<html>
<head>
  <title>itertools</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="560"/>
<h1>itertools</h1>

<div>
<span><div><span><span style="font-family: georgia, palatina, serif;">一共提供了19个生成器函数</span></span></div><div><span><span style="font-family: georgia, palatina, serif;">组合，操控迭代器，分为三大类</span>：</span></div><div><span style="font-family: georgia, palatina, serif;">1.能够把迭代器连接起来的函数：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">chain(*iterables)： 接受一系列可迭代对象作为输入并返回一个迭代器，返回的迭代器能访问每个迭代对象中的元素；常见的用途是一次性想对分散在不同序列中的元素做迭代；比先把各个序列合并在一起然后迭代有效<br clear="none"/></span><ul><li><span style="font-family: georgia, palatina, serif;">优点：在输入序列非常大的时候会节省内存</span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">chain.from_iterable(it): 产出it生成的可迭代对象中的元素，无缝连接，返回一个迭代器</span></li><li><span style="font-family: georgia, palatina, serif;">product(*iterables, repeat=1):计算笛卡儿积</span><br clear="none"/></li><li><span style="font-family: georgia, palatina, serif;"><code>zip_longest</code>(<em>*iterables</em>, <em>fillvalue=None</em>)：zip按最短，这个方法按最长，没有的补None<br clear="none"/></span></li></ul><div><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></div><div><span style="font-family: georgia, palatina, serif;">2.能够从迭代器中（生成器）过滤元素的函数，从输入的可迭代对象中产出元素的子集，而且不修改元素本身：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">islice(<em>iterable</em>, <em>stop</em>)</span></li><li><span style="font-family: georgia, palatina, serif;">islice(<em>iterable</em>, <em>start</em>, <em>stop</em>[, <em>step</em>])：</span><ul><li><span style="font-family: georgia, palatina, serif;">迭代器和生成器没法执行普通的切片操作</span></li><li><span style="font-family: georgia, palatina, serif;">用法很类似切片，(如果明确知道要跳过的元素的个数)对迭代器/生成器进行切片操作，从可迭代对象的start开始，按step到stop截止，返回一个迭代器</span></li><li><span style="font-family: georgia, palatina, serif;">注意：<span style="color: #ff0000;">islice会消耗所提供的迭代器中的数据，必须考虑到迭代器是不可逆这个事实，所以如果需要之后再次访问这个迭代器的话就得先将它里面的数据放入一个列表中；不支持负值；有一个问题，见下面例子：</span></span></li></ul></li></ul><div><span style="color: #ff0000; font-family: georgia, palatina, serif;">def count(n):</span></div><div>     <span style="font-family: georgia, palatina, serif; color: #ff0000;">while True:</span></div><div><span style="color: #ff0000; font-family: georgia, palatina, serif;">           yield n</span></div><div><span style="color: #ff0000; font-family: georgia, palatina, serif;">           n+1</span></div><div><span style="color: #ff0000; font-family: georgia, palatina, serif;">如果按下面运行：</span></div><div><span style="color: #ff0000; font-family: georgia, palatina, serif;">for i in islice(count(10), 13, 20):</span></div><div><span style="color: #ff0000; font-family: georgia, palatina, serif;">     print(i)</span></div><div><span style="color: #ff0000; font-family: georgia, palatina, serif;">本意是从13开始，到20结束，但结果是从23开始，到30结束；start/stop值加了10，没搞懂     </span></div><ul><li><span style="font-family: georgia, palatina, serif;">takewhile(predicate, iterable)：返回iterable中使predicate为True的元素的生成器；生成一个使用另一个生成器的生成器，在指定条件为False时停止；这个函数和dropwhile刚好相反</span></li><li><span style="font-family: georgia, palatina, serif;">dropwhile(<em>predicate</em>, <em>iterable</em>)：</span><ul><li><span style="font-family: georgia, palatina, serif;"> 参数：为一个函数和一个可迭代对象，参数函数的参数为第二个参数，<span style="color: #ff00ff;">函数不需要在内部对iterable进行迭代，会自动迭代iterable将其中的元素传入函数；函数参数一般使用lambda表达式</span></span></li><li><span style="font-family: georgia, palatina, serif;">该函数返回一个迭代器，返回的元素是使第一个参数返回为False的元素, 注意，丢弃的是返回为True的元素</span></li><li><span style="font-family: georgia, palatina, serif;"><span style="color: #ff0000;"><strong>注意</strong></span>：只丢弃前面的几个元素直到某个元素满足测试函数为止，之后的所有剩余元素全部会不经过筛选直接返回，经实测</span><br clear="none"/></li></ul></li><li><span style="font-family: georgia, palatina, serif;">filter(predicate, it)：it中各个元素传给predicate，如果predicate(item)返回为真，产出对应元素，如果为None，只产出真值元素；返回的是一个迭代器</span><span style="font-family: georgia, palatina, serif;"><br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">filterfalse(predicate, iterable): 与内建的filter相反，predicate是一个布尔函数，返回的是使该函数返回为False的序列中的<span style="color: #ff00ff;">所有</span>元素；这个函数与上面的takewhile/dropwhile作用互补</span></li><li><span style="font-family: georgia, palatina, serif;">compress(data, selectors): 并行处理两个可迭代对象(一个iterable和一个boolean选择器序列，输出iterable中选择器中对应为true的元素)，如果selectors中的元素是真值，产出data中对应下标的元素(fluent14.9)相当于(d for d, s in zip(data, selectors) if s)；返回的是一个可迭代对象</span></li></ul><div><span style="font-family: georgia, palatina, serif;">3.能够把迭代器中的元素组合起来的函数</span></div><ul><li><span style="font-family: georgia, palatina, serif;">permunations(iterable, r=None): </span><ul><li><span style="font-family: georgia, palatina, serif;"> 将迭代器所提供的所有元素重新排列为所有可能的情况，元素下标顺序也是考虑在里面的</span></li><li><span style="font-family: georgia, palatina, serif;">返回值：返回的是一个迭代器，迭代器由原序列元素进行各种排列之后组成的元组组成<br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">参数: r是返回元组中元素的个数，如果是默认值，就是原来元组的个数</span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">combinations(iterable, r):<br clear="none"/></span><ul><li><span style="font-family: georgia, palatina, serif;">返回值：产生输入序列中所有元素的全部组合形式,元组元素的迭代器</span></li><li><span style="font-family: georgia, palatina, serif;">和permunations的区别是，combinations不考虑元素之间的实际顺序，即相同元素组成的元组元素只会有一个</span></li><li><span style="font-family: georgia, palatina, serif;">经使用，返回的迭代器<span style="color: #ff00ff;">只能消费一次</span></span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">combinations_with_replacement():这个就比较奇怪了，不知道使用场景是什么<br clear="none"/></span><ul><li><span style="font-family: georgia, palatina, serif;">返回值：在前两个方法中，如果返回元组中已经选择过的元素将从可能的候选元素中移除掉('a'已经选过，则该元组中不再包含'a')，这个方法打破这一规则，就是说，在返回的子序列中可以有重复的元素出现</span></li><li><span style="font-family: georgia, palatina, serif;">看结果，没有考虑元组元素的顺序，比如('a','a','b')出现后不会再出现('a','b','a'),这一点同combinations</span></li></ul></li><li><span style="font-family: georgia, palatina, serif;">count(start=0, step=1): 从start开始，按step生成数，这个函数从不停止，因此如果调用list(count())会一直创建；文档中说可以用作map的参数，或可以和zip一起使用<br clear="none"/></span></li><li><span style="font-family: georgia, palatina, serif;">cycle(iterable)：从iterable中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素</span></li><li><span style="font-family: georgia, palatina, serif;">repeat(object[, times])：重复不断的产出指定的元素，除非提供times，指定次数</span></li></ul><div><span style="font-family: georgia, palatina, serif;">4. 用于映射的生成器函数：</span></div><ul><li><span style="font-family: georgia, palatina, serif;">accumulate(iterable [, func]): 默认产出累积的总和的迭代器；如果提供了func，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产生出结果</span></li><li><span style="font-family: georgia, palatina, serif;">startmap(func, iterable): 将迭代器iterable的元素传给func，产生元素；与map的区别类似于function(a,b)和function(*c)</span></li><li><span style="font-family: georgia, palatina, serif;">内置：enumerate/map</span></li></ul><div><span style="font-family: georgia, palatina, serif;">5. 重新排列元素的生成器函数</span></div><ul><li><code>itertools.</code><code>groupby</code><br clear="none"/></li><li>tee</li></ul><div><span style="font-family: georgia, palatina, serif;">删除文件 1.txt中以'a'开头的行的部分：</span></div><div><span style="font-family: georgia, palatina, serif;">    from itertools import dropwhile</span></div><div><span style="font-family: georgia, palatina, serif;">    with open('1.txt) as f:</span></div><div><span style="font-family: georgia, palatina, serif;">          for line in dropwhile(lambda line: line.startswith('a'), f):</span></div><div><span style="font-family: georgia, palatina, serif;">              print(line)</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;"><code>itertools.</code><code>groupby</code>(<em>iterable</em>, <em>key=None</em>)：按照key指定的方法，返回的是一个可迭代对象，由一系列keys和groups（自迭代器）组成，keys是key方法指定的分组依据，groups是分组后的iterable中的值组成的新的迭代器。<span>一个非常重要的准备步骤是要根据指定的字段将数据排序</span></span></div><div><span style="font-family: georgia, palatina, serif;">首先对感兴趣的字段对数据进行排序示例：</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; color: #333333; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: #fbfaf8; border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="font-family: georgia, palatina, serif;"># 指定key方法</span></div><div><span style="font-family: georgia, palatina, serif;">def height_class(h):</span></div><div><span style="font-family: georgia, palatina, serif;">     if h &gt; 180:</span></div><div><span style="font-family: georgia, palatina, serif;">          return 'tall'</span></div><div><span style="font-family: georgia, palatina, serif;">     elif h &lt; 160:</span></div><div><span style="font-family: georgia, palatina, serif;">          return 'short'</span></div><div><span style="font-family: georgia, palatina, serif;">     else:</span></div><div><span style="font-family: georgia, palatina, serif;">          return 'middle'</span></div><div><span style="font-family: georgia, palatina, serif;">friends = [191,158,159,165,161,194,153,178]</span></div><div><span style="font-family: georgia, palatina, serif;">friends = sorted(friends, height_class)          # 1</span></div><div><span style="font-family: georgia, palatina, serif;">for k,v in itertools.groupby(friends, height_class):     # 2</span></div><div><span style="font-family: georgia, palatina, serif;">     print(k)</span></div><div><span style="font-family: georgia, palatina, serif;">     print(list(v))</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">## 输出结果为</span></div><div><span style="font-family: georgia, palatina, serif;">short</span></div><div><span style="font-family: georgia, palatina, serif;">[158,159,153]</span></div><div><span style="font-family: georgia, palatina, serif;">middle</span></div><div><span style="font-family: georgia, palatina, serif;">[165,161]</span></div><div><span style="font-family: georgia, palatina, serif;">tall</span></div><div><span style="font-family: georgia, palatina, serif;">[191,194,178]</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;"># 分析</span></div><div><span style="font-family: georgia, palatina, serif;"># 1中，先使用给定的方法height_class给friends排序，这样方便groupby的时候能将同类型的方法一个列表中</span></div><div><span style="font-family: georgia, palatina, serif;"># 2中，使用height_class给friends分组</span></div><div><span style="font-family: georgia, palatina, serif;"># 循环中，k为height_class指定的分组名，v为friends中的值</span></div><div><br clear="none"/></div><div><span style="font-family: georgia, palatina, serif;">#不指定key方法：</span></div><div><span style="font-family: georgia, palatina, serif;">s = 'AAAABBBBBCCDDDAAA'</span></div><div><span style="font-family: georgia, palatina, serif;">for k,v in groupby(s):</span></div><div><span style="font-family: georgia, palatina, serif;">     print(k)</span></div><div><span style="font-family: georgia, palatina, serif;">     print(list(v))</span></div><div><span style="font-family: georgia, palatina, serif;">## 输出结果：</span></div><div><span style="font-family: georgia, palatina, serif;">A</span></div><div><span style="font-family: georgia, palatina, serif;">['A','A','A','A']</span></div><div><span style="font-family: georgia, palatina, serif;">B</span></div><div><span style="font-family: georgia, palatina, serif;">['B','B','B','B','B']</span></div><div><span style="font-family: georgia, palatina, serif;">C</span></div><div><span style="font-family: georgia, palatina, serif;">['C','C']</span></div><div><span style="font-family: georgia, palatina, serif;">D</span></div><div><span style="font-family: georgia, palatina, serif;">['D','D']</span></div><div><span style="font-family: georgia, palatina, serif;">A</span></div><div><span style="font-family: georgia, palatina, serif;">['A','A','A']</span></div></div><div><br clear="none"/></div><div><br clear="none"/></div></span>
</div></body></html> 