<html>
<head>
  <title>内存管理</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="748"/>
<h1>内存管理</h1>

<div>
<span><div><div><div><div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">一. 智能指针</span></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 89px;"></col><col style="width: 130px;"></col><col style="width: 204px;"></col><col style="width: 604px;"></col></colgroup><tbody><tr><td rowspan="1" style="width: 89px; padding: 8px; border: 1px solid;">智能指针</td><td rowspan="1" style="width: 130px; padding: 8px; border: 1px solid;"><div>功能</div></td><td rowspan="1" style="width: 204px; padding: 8px; border: 1px solid;"><div>共同特性</div></td><td rowspan="1" style="width: 604px; padding: 8px; border: 1px solid;"><div>独有操作</div></td></tr><tr><td rowspan="1" style="width: 89px; padding: 8px; border: 1px solid;"><div>share_ptr</div></td><td rowspan="1" style="width: 130px; padding: 8px; border: 1px solid;"><div>共享式：允许多个指针指向同一对象</div></td><td rowspan="2" style="height: 56px; width: 204px; padding: 8px; border: 1px solid;"><div>1.p:p用作一个条件判断，若p指向一个对象则为true</div><div>2.*p：解引用p，获得他指向的对象</div><div>3.p-&gt;mem: 等价于*p</div><div>4.p.get():返回p中保存的指针</div><div>5.swap(p, q)/p.swap(q)：交换p和q中的指针</div></td><td rowspan="1" style="width: 604px; padding: 8px; border: 1px solid;"><div>1.make_shared&lt;T&gt;(args): 返回一个shared_ptr，指向一个动态分配的类型为T的对象，</div><div>使用args初始化此对象</div><div>2.shared_ptr&lt;T&gt;p(q)：p是q的拷贝：会递增q中的计数器</div><div>3.p=q：会递减p所指内存的引用计数，递增q所指内存的引用计数</div><div>4.p.unique(): 若p.use_count()为1返回true，否则返回false</div><div>5.p.use_count():返回与p共享对象的智能指针数量，主要用于调试</div><div>6.get():返回智能指针内部的原始指针</div></td></tr><tr><td rowspan="1" style="width: 89px; padding: 8px; border: 1px solid;"><div>unique_ptr</div></td><td rowspan="1" style="width: 130px; padding: 8px; border: 1px solid;"><div>独占式：独占所指向的对象,它所指向的对象只有一个拥有者</div></td><td rowspan="1" style="width: 604px; padding: 8px; border: 1px solid;"><div>1.为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少</div><div>2.可以移动但不能拷贝（仅通过move来转移），一旦转移成功，原来的unique_ptr就失去了对象内存的所有权</div></td></tr><tr><td rowspan="1" style="width: 89px; padding: 8px; border: 1px solid;"><div>weak_ptr</div></td><td rowspan="1" style="width: 130px; padding: 8px; border: 1px solid;"><div>弱引用；共享但不引用，不控制对象的声明周期</div></td><td rowspan="1" style="width: 204px; padding: 8px; border: 1px solid;"><div>shared_ptr和weak_ptr在计数上是原子操作，性能较好；</div><div>线程安全级别上与stl容器相同</div></td><td rowspan="1" style="width: 604px; padding: 8px; border: 1px solid;"><div>只有一个接受一个shared_ptr 的构造函数，指向shared_ptr指针指向的对象内存但不拥有该内存</div></td></tr></tbody></table><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">补充</span></span>：</div></div><ol><li><div>智能指针的出现就是为了使动态内存允许在多个对象之间共享。</div></li></ol><ol start="2"><li><div>如果程序不知道到底需要多少对象，则使用容器类</div></li><li><div>不支持分配数组，string和vector可以做这件事情，或者使用boost库中的工具</div></li><li><div>以独立语句将new的对象置入智能指针(Effective C++ 17)：</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void processWidght(shared_ptr&lt;Widget&gt; pw, int priority);</div><div>// 现在调用processWidget：</div><div>processWidget(shared_ptr&lt;Widget&gt;(new Widget), priority());</div><div>// 可能会造成资源泄露,因为c++编译器不确定以何种次序完成参数调用，如果先调用new widget,再priority过程中发生异常，new Widget返回的指针就会遗失，所以使用分离语句</div><div>shared_ptr&lt;Widget&gt; pw(new Widget);</div><div>processWidget(pw, priority())</div></div><div><br clear="none"/></div><div>1.shared_ptr：允许多个指针指向同一对象</div><ul><li><div>shared_ptr的三种初始化方式：</div></li><ul><li><div>()或{}：</div></li><ul><li><div>构造函数的实参可以时weak_ptr,如果是empty，会抛出bad_weak_ptr</div></li><li><div>支持移动语义，shared_ptr&lt;T&gt; sp(move(uniqueptr)) //唯一使用uniqueptr初始化的方式；赋值操作类似</div></li><li><div>shared_ptr&lt;T&gt; sp(move(shared_ptr)) //也支持使用另一个shared_ptr移动</div></li></ul><li><div>make_shared：返回一个shared_ptr对象</div></li><li><div>先声明一个shared_ptr, 然后使用reset对它赋值</div></li><li><div>注意：接受指针参数的智能指针构造函数是explicit的，不能将一个内置指针转换为一个智能指针，必须使用直接初始化的形式：</div><div>shared_ptr&lt;int&gt;p1 = new int(1024);     // 错误，必须使用直接初始化的形式,这样会被视为需要一个隐式转换</div><div>shared_ptr&lt;int&gt;p2(new int(1024));     // 正确</div><div>当将一个shared_ptr绑定到一个普通指针时，就将内存的管理责任交给了shared_ptr，这个时候就不能使用内置指针来访问shared_ptr所指向的内存。也就是说，用内置指针初始化一个智能指针后，不需要自己调用delete了</div></li></ul><li><div>定义自己的deleter：shared_ptr提供的default deleter调用的是delete，而不是delete[],所以如果用new[]建立一个array of object，必须定义自己的deleter，也可以使用为unique_ptr而提供的辅助函数作为deleter，其内调用delete[]:</div><div>std::shared_ptr&lt;int&gt; p(new int[10], std::default_delete&lt;int[]&gt;());</div></li><li><div>方法：</div></li><ul><li><div>各种初始化方法</div></li><li><div>move赋值</div></li><li><div>sp.swap(sp1) / swap(sp1, sp2)：置换sp1合sp2的pointer和deleter</div></li><li><div>sp.reset()/sp.reset(ptr)：放弃拥有权，并重新初始化，拥有empty/ptr</div></li><li><div>sp.get()：返回原始指针</div></li><li><div>sp.use_count():返回共享对象拥有的数量</div></li><li><div>sp.unique():返回sp是否是唯一拥有者</div></li><li><div>支持比较操作符</div></li><li><div>static_pointer_cast(sp)：对sp执行static_cast&lt;&gt;语义</div></li><li><div>dynamic_pointer_cast(sp):对sp执行dynamic_cast&lt;&gt;语义</div></li><li><div>const_pointer_cast(sp): 对sp执行const_cast&lt;&gt;语义</div></li></ul><li><div>注意：</div></li><ul><li><div>shared_ptr引用计数是线程安全且无锁的(原子操作)，但指向的对象不是线程安全的，读写需要加锁</div></li><li><div>循环依赖会出问题，通常的做法是owner持有指向child的shared_ptr, child持有指向owner的weak_ptr——<span style="font-weight: bold;">具体实现</span></div></li></ul></ul><div><br clear="none"/></div><div>2.unique_ptr：独占式拥有，可确保一个对象和其相应资源同一时间只被一个pointer拥有</div><ul><li><div>必须直接初始化而不是赋值：unique_ptr&lt;int&gt; up(new int);</div></li><li><div>方法：</div></li><ul><li><div>不再提供指针运算符如++等，这被视为优点</div></li><li><div>初始化/赋值：不允许以赋值语法将一个平常指针当作初值，所以必须直接初始化：unique_ptr&lt;int&gt; up(new int);</div></li><li><div>可以调用nullptr或reset()</div></li><li><div>up.reset()/up.reset(ptr):对智能指针调用deleter，并令为0/重新初始化为ptr——之前的先析构掉了</div></li><li><div>up.get():返回原始指针</div></li><li><div>up.release():获得unique_ptr拥有的对象并放弃up的拥有权</div></li><li><div>bool():检查是否unique pointer是否拥有对象</div></li><li><div>可以和nullptr比较</div></li><li><div>up1.swap(up2)：置换up1和up2的pointer和deleter</div></li></ul><li><div>unique_ptr的特化版本：支持数组，但接口稍有不同，不再提供*和-&gt;，而是提供[],用以访问其所指向的array中的某一个对象</div></li><ul><li><div>问题：</div></li><li><div>如果一个函数返回unique_ptr，这个时候是拷贝还是移动？首先肯定不是拷贝，有两种情况：</div></li><ul><li><div>NRV优化并不会返回值</div></li><li><div>编译器允许：如果支持move构造，返回值时调用move构造；如果不支持，就调用copy构造；否则报错(<span style="color: rgb(227, 0, 0); font-weight: bold;">顺序?</span>）</div></li></ul></ul></ul><div>3. weak_ptr:</div><ul><li><div>当指向的对象正被处理时，shared_ptr pointer无法被释放</div></li><li><div>如果不确定隐身于weak_ptr背后的对象是否仍旧存活，有以下几个选择：</div></li><ul><li><div>expired():会在weak_ptr不再共享对象时返回true，等同于检查use_count()是否为0，但速度更快</div></li><li><div>可以使用相应的shared_ptr的构造函数明确将weak_ptr转换为一个shared_ptr,如果被指对象不存在了该构造会抛出一个bad_weak_ptr异常(派生自std::exception),其what为&quot;bad_weak_ptr&quot;</div></li><li><div>调用use_count()，询问相应对象的个数；通常只是为调试而使用use_count(),但这个函数效率低</div></li></ul><li><div>方法：</div></li><ul><li><div>wp.swap(wp2)</div></li><li><div>wp.reset():放弃拥有权，重新初始化为空</div></li><li><div>wp.use_count():返回拥有者的数量</div></li><li><div>wp.expired():返回wp是否为空</div></li><li><div>wp.lock():返回一个shared pointer,共享被weak_ptr拥有的指针的拥有权</div></li><li><div>wp.owner_before()</div></li></ul></ul><div>其他：</div><div>enable_shared_from_this：这是一个以派生类为模板类型实参的j基类模板，继承他，this指针就能变身为shared_ptr, 也就是能让一个对象（假设其名为t，被一个shared_ptr对象pt管理）安全的生成其他额外的std::shared_ptr实例，它们与pt共享对象t的所有权。</div><div>若一个类T继承std::enable_shared_from_this，则会为该类提供成员函数shared_from_this。当T的对象t被一个名为pt的shared_ptr&lt;T&gt;管理时，调用T::shared_from_this()成员函数会返回一个T的新的shared_ptr对象，它与pt共享t的所有权</div><div><br clear="none"/></div><div>左值引用，右值引用：</div><div>左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时变量，所以：</div><ul><li><div>所引用的对象将要被销毁</div></li><li><div>该对象没有其他用户</div></li></ul><div>这两个特性意味着，使用右值引用的代码可以自由的接管所引用的对象的资源;右值引用只能绑定到一个将要销毁的对象，不能绑定到一个左值；不能将一个右值引用绑定到一个右值引用类型的变量上</div><div>std::move:虽然不能将一个右值引用直接绑定到一个左值上，但可以显式的将一个左值转换为对应的右值类型，move(#include &lt;utility&gt;)获得绑定到左值上的右值引用；调用move意味着：可以销毁一个移后源对象，也可以赋予它新值，但不能再使用一个移后源对象对象的值</div><div><font style="font-size: 12pt;"><br clear="none"/></font></div></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">二. new</span></font></div><ul><li><div><span style="font-size: 11pt;">新标准中可以用花括号列表初始化new的元素</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int *p = new int[10]{0,1,2,3,4,5,6,7,8,9};</div></div><ul><li><div><span style="font-size: 11pt;">动态分配一个空数组是合法的</span></div></li></ul><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">三. allocator模板</span></font></div><div><span style="font-size: 16px; font-family: Cambria;">allocator</span><span style="font-size: 16px; font-family: 幼圆;">模板，定义于头文件memory中，将内存分配和对象构造分离开来。它分配的内存是原始的，未构造的。</span></div><ol><li><div><span style="font-size: 16px; font-family: 幼圆;">定义并分配原始内存：</span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>allocator&lt;T&gt; a;     //定义一个名为a的allocator对象</div><div>a.allocate(n);     //分配一段原始的，未构造的内存，保存n个类型为T的对象</div></div><ol start="2"><li><div><span style="font-size: 16px; font-family: 幼圆;">构造元素：construct函数接受一个指针和零个或多个额外参数，args被传给类型为T的构造函数，用来在p指向的内存中构造一个对象；为使用allocate返回的内存，必须使用construct构造对象</span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>a.construct(p,args);     //</div></div><ol start="3"><li><div><span style="font-size: 16px; font-family: 幼圆;">销毁：destroy，使用完对象后，必须用每个构造的元素调用destroy销毁之，即析构</span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>while( q != p )</div><div>     alloc.destroy(--q);     //q指向最后一个构造的元素</div></div><ol start="4"><li><div><span style="font-size: 16px; font-family: 幼圆;">元素被销毁后可以用这部分内存保存其他元素，也可以归还系统，释放内存通过调用deallocate</span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>alloc.deallocate(p,n);     //释放从p开始的内存，这段内存保存了n个类型为T的对象</div></div><div><br/></div><div><span style="font-size: 16px; font-family: 幼圆;">拷贝和填充未初始化内存的算法：</span><span style="font-size: 16px; font-family: Cambria;">allocator</span><span style="font-size: 16px; font-family: 幼圆;">算法</span></div><ul><li><div><span style="font-size: 16px; font-family: Cambria;">uninitialized_copy(b, e, b2)</span><span style="font-size: 16px; font-family: 幼圆;">：从迭代器b和e指定的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2的构造必须足够大</span></div></li><li><div><span style="font-size: 16px; font-family: Cambria;">uninitialized_copy_n(b, n, b2)</span><span style="font-size: 16px; font-family: 幼圆;">：从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中</span></div></li><li><div><span style="font-size: 16px; font-family: Cambria;">uninitialized_fill(b, e, t)</span><span style="font-size: 16px; font-family: 幼圆;">：从迭代器b和e指定的原始内存中创建对象，对象的值均为t的拷贝</span></div></li><li><div><span style="font-size: 16px; font-family: Cambria;">uninitialize_fill_n(b, n, t)</span><span style="font-size: 16px; font-family: 幼圆;">：从迭代器b指向的内存地址开始创建n个对象，对象的值都是t的拷贝</span></div></li></ul><div>四. 小型对象分配</div></div><ul><li><div>为什么要用小型对象分配而不是C++标准通用的</div></li><ul><li><div>new/delete通常用来分配中大型对象（数百个或数千个bytes）</div></li><li><div>除了速度慢，C++缺省分配器的通用性也造成了小型对象空间分配的低效。缺省分配器管理一个记忆池，一般通过new分配管理的个数达到了4-32个bytes，所以如果分配大内存，开销微不足道，但如果分配8个bytes，开销达到50%-400%</div></li></ul></ul><div>问题归纳：</div><ul><li><div>new和malloc的区别：malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br/></div></li></ul><ul><ul><li><div>申请的内存所在位置不同：</div></li><ul><li><div><span style="color: unset; font-family: unset; font-size: unset;">mollloc函数从自由存储区（free store）上为对象动态分配内存空间</span></div></li><li><div><span style="color: unset; font-family: unset; font-size: unset;">而new操作符从堆上动态分配内存。new甚至可以不为对象分配内存！定位new的功能可以办到这一点：new (place_address) type，operator new不分配任何的内存，它只是简单地返回指针实参。</span></div></li></ul><li><div>返回类型安全性</div></li><ul><li><div><span style="color: unset; font-family: unset; font-size: unset;">new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。</span></div></li><li><div><span style="color: unset; font-family: unset; font-size: unset;">malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</span></div></li></ul><li><div>内存分配失败时的返回值</div></li><ul><li><div>new内存分配失败时，会抛出bad_alloc异常，它不会返回NULL；</div></li><li><div>malloc分配内存失败时返回NULL。</div></li></ul><li><div>是否需要指定内存大小</div></li><ul><li><div>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，</div></li><li><div>malloc则需要显式地指出所需内存的尺寸。</div></li></ul><li><div>是否调用构造函数/析构函数</div></li><ul><li><div>new</div></li><ul><li><div>调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</div></li><li><div><span style="color: unset; font-family: unset; font-size: unset;">编译器运行相应的构造函数以构造对象，并为其传入初值。</span></div></li><li><div><span style="color: unset; font-family: unset; font-size: unset;">对象构造完成后，返回一个指向该对象的指针。</span></div></li></ul><li><div>使用delete操作符来释放对象内存时会经历两个步骤：</div></li><ul><li><div>第一步：调用对象的析构函数。</div></li><li><div><span style="color: unset; font-family: unset; font-size: unset;">第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</span></div></li></ul></ul><li><div>对数组的处理：<span style="color: unset; font-family: unset; font-size: unset;">C++提供了new[]与delete[]来专门处理数组类型:。</span></div></li><ul><li><div>是否相互调用：<span style="color: unset; font-family: unset; font-size: unset;">new底层其实还是用malloc实现动态内存分配的，所以new调用malloc，malloc不会调用new。</span></div></li></ul><li><div>函数重载：<span style="color: unset; font-family: unset; font-size: unset;">new可以重载；</span><span style="color: unset; font-family: unset; font-size: unset;">malloc不行</span></div></li></ul></ul><div><br/></div><div>附：</div><div>1.C++内存方面的问题：</div><ul><li><div>缓冲区溢出——可以使用vector或string</div></li><li><div>空悬指针/野指针——shared_ptr/weak_ptr配合使用</div></li><li><div>重复释放——unique_ptr</div></li><li><div>内存泄漏——unique_ptr</div></li><li><div>不配对的new[]/delete——vector或者boost中的数组相关的</div></li><li><div>内存碎片——内存池</div></li></ul><div><br/></div></div><div><br/></div></span>
</div></body></html> 