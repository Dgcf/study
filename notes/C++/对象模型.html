<html>
<head>
  <title>对象模型</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="725"/>
<h1>对象模型</h1>

<div>
<span><div><div><div><div><div><div><div><div>一. 关于对象</div><ul><li><div>C++在布局及存取时间上的主要额外负担是由virtual带来的，包括：</div></li><ul><li><div>虚函数机制，用以支持一个有效率的执行期绑定</div></li><li><div>虚基类，用以实现多次出现在继承体系中的基类，有一个单一而被共享的实体</div></li><li><div>发生在子类和父类之间的转换</div></li></ul><li><div>对象模型：</div></li><ul><li><div>有两种数据成员：静态和非静态；三种成员函数：静态/非静态/虚函数；非静态成员置于类内，静态数据成员，静态成员函数和非静态成员函数虽然在class的声明之内，都被存放在所有class对象之外</div></li><li><div>虚函数：有两个步骤支持</div></li><ul><li><div>每一个class产生出一堆指向虚函数的指针，放在一个一维数组中(虚表(vtbl))；<span style="font-size: 10pt; font-family: Georgia;">派生类会生成一个兼容基类的虚函数表</span></div></li><ol><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">vs怎样查看虚函数表？</span><span style="font-size: 10pt; font-family: Georgia;">打开vs的命令行工具Command prompt；</span><span style="font-size: 10pt; font-family: Georgia;">切换到cpp文件目录下，输入cl /d1 reportSingleClassLayoutXXX YYY.cpp，其中XXX是类名，YYY是类所在的cpp文件名</span></font></div></li></ol><li><div>每一个类对象添加了一个虚指针（vptr），指向相关的虚表；vptr的设定和重置由类的构造，析构和拷贝赋值运算符自动完成；每一个类所关联的type_info对象（用以支持运行时类型识别）放在虚表的第一个位置，其他的虚函数按照声明顺序(<span style="font-size: 10pt; font-family: Georgia;">先父类，再子类，同类中的声明顺序</span><span style="font-size: 11pt; font-family: Georgia;">)</span>依次放入</div></li></ul><li><div>继承。虚继承的情况下基类不管在继承串链中被派生多少次，永远只会存在一个实体</div></li></ul><li><div>为了支持POD类型（保证与C兼容的空间布局），可以将pod类型抽出来作为基类再派生需要的class；但这种作法已经不再被推荐（因为某些编译器可能会做改变）；组合而非继承，才是把C和C++结合在一起的唯一可行方法</div></li><li><div>对象的差异：</div></li><ul><li><div>多态操作要求对象只能是一个指针或引用，指针或引用之所以支持多态，是因为他们并不会引发内存中任何与类型有关的内存委托操作；会受到改变的只是他们所指向的内存的大小和内容解释方式</div></li><li><div>C++的多态只存在于一个个公有类体系中，非公有的派生行为以及类型为void*的指针可以说是多态，但并没有被语言明白地支持，只能通过程序员明白的转型操作来管理。C++以下列 方式支持多态：</div></li><ul><li><div>经由一组隐含的转换操作，如一个基类指针指向公有继承的子类对象</div></li><li><div>经由虚函数机制（对象调用虚函数）</div></li><li><div>经由dynamic_cast和typeid运算符</div></li></ul><li><div>多态的主要用途是经由一个共同的接口来影响类型的封装，这个接口通常被定义在一个抽象的基类中</div></li></ul></ul></div><ul><ul><li><div>类对象需要多少内存：</div></li><ul><li><div>非静态数据成员的总和大小</div></li><li><div>对齐而填补的字节数</div></li><li><div>为支持虚函数而产生的额外负担</div></li></ul><li><div>指针类型：指针类型会教导编译器如何解释某个特定地址中的内存内容及其大小，</div></li><ul><li><div>所以转型其实是一种编译器指令，大部分情况下并不改变一个指针所含的真正地址，只影响被指出之内存的大小和内容的解释方式</div></li><li><div>也是为什么一个void*的指针只能够含有一个地址而不能通过它操作所指的object的缘故</div></li></ul><li><div>加上多态之后：</div></li><ul><li><div>如果虚函数被定义为inline，则效率上有很大的收获</div></li></ul></ul></ul><div>二. 构造函数语意</div><div>    1.默认构造的建构：</div><ul><li><div>编译器需要的时候才会合成默认构造，被合成的构造只执行编译器所需的行动，像一些数据成员的初始化操作并不执行，那是程序员的职责，<span style="font-size: unset; color: unset; font-family: unset;">编译器需要默认构造并合成的几种情况： </span></div></li><ul><li><div>带有默认构造的对象的数据成员：</div></li><ul><li><div>这个合成操作只有在构造真正需要<span style="font-weight: bold;">被调用时</span>才发生，那么问题来了，在C++的各个编译模块中编译器如何避免合成出多个默认构造？解决方法是把合成的所有方法都以inline方式完成，如果函数太复杂不适合做成inline就会合成出一个explict non-inline static实体</div></li><li><div>如果有多个成员都要求构造函数初始化，以在class中的声明次序来，在用户代码之前调用成员的构造</div></li></ul><li><div>带有默认构造的基类：一个没有任何构造的类派生自一个带有默认构造的基类，需要被合成出来调用基类的默认构造</div></li><ul><li><div>如果子类有除默认构造之外的构造，编译器会扩张现有的每一个构造，将调用所有必要的默认构造的代码加进去</div></li><li><div>如果存在带默认构造的成员，先基类构造，再成员默认构造</div></li></ul><li><div>带有一个虚函数的类，两种情况下需要合成默认构造函数：因为要初始化vptr</div></li><ul><li><div>class声明或继承自一个虚函数</div></li><li><div>class派生自一个继承串链，其中有一个或更多的虚基类</div></li></ul><li><div>带有一个虚基类的类：<span style="color: rgb(227, 0, 0);">通过派生类访问成员时需要知道编译器产生指针指向虚基类——？</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">显式定义默认构造：</span><span style="font-size: 10pt; font-family: Georgia;">T() = default;</span></div></li><li><div>两个误解：都是不成立的</div></li><ul><li><div>任何class如果没有定义默认构造，编译器都会合成一个出来</div></li><li><div>编译器合成出来的默认构造会明确class内的每一个数据成员的默认值</div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">不支持静态构造函数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">构造函数不能被 声明为常量成员函数——？；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">避免使用默认构造(more effective c++ 4)：</span><span style="font-size: 10pt; color: unset; font-family: Georgia;">一个类如果没有缺省构造，在三个方面使用会有问题：</span></div></li><ol><li><div><span style="font-size: 10pt; font-family: Georgia;">不能建立对象的数组——可以利用指针数组来代替，但有缺点：增加了内存分配量，可以为数组分配原始内存，这样就避免了浪费内存</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">无法在许多基于模板的容器里使用——通过仔细设计模板可以杜绝对缺省构造函数的使用</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">不提供缺省构造的虚基类很难与其进行合作</span></div></li></ol></ul><div>    2.拷贝构造的建构：决定一个拷贝构造能否被编译器合成的标准在于class能否展现出位逐次拷贝，如果能展示出位逐次拷贝就不需要合成</div><ul><li><div>有三种情况会调用拷贝构造（注意后两种不是调用拷贝赋值运算符，实测）：</div></li><ul><li><div>一个对象初始化另外一个</div></li><li><div>参数值传递</div></li><li><div>返回值拷贝</div></li></ul><li><div>一个类什么时候不展示出位逐次拷贝？前两种情况将合成的构造安插到拷贝构造中</div></li><ul><li><div>当class有一个成员对象且这个成员对象有一个拷贝构造时（不管这个拷贝构造是明确定义的还是编译器合成的）</div></li><li><div>当class继承自一个base class而该base class有拷贝构造函数（不管是明确定义的还是编译器合成的）</div></li><li><div>当class声明了一个或多个虚函数的时候：需要拷贝构造初始化vptr</div></li><li><div>当class派生自一个继承串链，其中有一个或多个虚基类</div></li></ul><li><div>拷贝构造要还是不要？</div></li><ul><li><div>如果支持位拷贝，不需要提供拷贝构造，因为编译器自动为你实施了最好的行为，既快速又安全</div></li><li><div>如果需要拷贝构造，使用memcpy会更有效率，不管使用memcpy或memset，都只在class不含任何编译器产生的内部成员时才安全，如有虚函数或虚基类就不安全</div></li><li><div><span style="color: rgb(227, 0, 0); font-weight: bold;">类的拷贝操作在什么情况下可以直接使用memcpy？</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">拷贝构造函数通常不应该是explicit的，因为如果没有拷贝赋值运算符，=会被转换为拷贝构造的调用</span></div></li></ul><div>    3.程序转化语意：</div><ul><li><div>明确的初始化操作：a. 重写每一个定义，其中的初始化操作会被剥除；b. class的拷贝构造的调用操作会被安插进去</div></li><li><div>参数的初始化：</div></li><li><div>返回值的初始化，以下例子也是在编译层面做优化（NRV(返回值)优化）：</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>X bar(){</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    X xx;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    return xx;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// 转化过程（可能每个编译器的实现不一样）：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">1. 首先加一个额外参数，类型为对象的引用；</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2.在return之前安插一个拷贝构造操作，return空（</span><span style="font-size: 9pt; font-family: Monaco;"><font style="color: rgb(28, 51, 135);">这就是编译器省略拷贝构造的唯一一种情况&lt;Modern C++ Desgin  P123&gt;</font></span><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">）</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">void bar(X &amp;_result){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    X xx;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    xx.X::X();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    _result.X::X(xx);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    return ;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">所以：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">X xx = bar();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">转换为：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">X xx;    // 注意，这里是不需要施行默认构造的</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">bar(xx);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">如果是函数指针也是同理</span></div></div><ul><li><div>在程序员层面优化：</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>X bar(const T&amp; y, const T&amp; z){</div><div>    X xx;</div><div>    return xx;</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">这个会要求xx被membersize地拷贝到编译器所产生的结果中，使用以下替代：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">X bar(</span>const T&amp; y, const T&amp; z<span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    return X(y, z);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">效率会比较高，避免了一次拷贝构造：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">void bar(X&amp; __result, </span>const T&amp; y, const T&amp; z<span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    __result.X::X(y, z);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    return;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div>    4.成员函数的初始化：</div><ul><li><div>必须使用列表初始化：</div></li><ul><li><div>初始化一个引用成员</div></li><li><div>初始化const成员</div></li><li><div>调用基类的构造，而基类构造有一组参数（严格的说应该是没有默认构造）</div></li><li><div>调用成员的构造，而成员构造有一组参数（同上）</div></li></ul><li><div>初始化列表的内部实现是将代码安插在构造函数体中，初始化的顺序是按声明次序而不是列表初始化的顺序，初始化执行代码置于任何显式用户代码之前；<span style="color: rgb(227, 0, 0);">析构的时候是按相反的顺序吗？</span></div></li><li><div>在构造函数初始化列表中调用成员函数（注意所用到的成员变量是否已经初始化）是可行的，但尽量避免这么做，因为你不知道这个成员函数对类型的依赖性又多强，如果依赖的数据成员还没有完成初始化就有问题</div></li><li><div>this指针在什么时候构建妥当：X::X(/*this pointer, */ int val){ ... }</div></li><li><div>派生构造中，派生类的成员函数返回值被当作base类的构造参数也是有问题的，vptr的初始化是在基类构造完成之后，是静态调用</div></li></ul><div><br/></div><div>三. Data语意</div><div>   1.数据成员的布局</div><ul><li><div>sizeof一个空类为1，因为编译器会安插进一个1byte的char以表示对象在内存中配置独一无二的地址；继承自空虚基类的空类有多大</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 64位测试</div><div>class X{};  // sizeof(X)==1</div><div>class Y: public virtual X {};    // sizeof(Y)==8</div><div>class Z: public virtual X {};    // sizeof(Z)==8</div><div>class A: public Y, public Z {};  // sizeof(A)==16</div></div><ul><li><div>数据成员：</div></li><ul><li><div>非静态成员的顺序和在类中被声明的顺序一致，任何中间插入的静态成员都不会被放进对象布局中</div></li><li><div>C++标准要求同一个访问限制符下的成员只需要符合“较晚出现的成员有较高的位置（<span style="color: rgb(227, 0, 0);">和栈向下增长的不符？经验证：全局函数中的局部变量和指针向下增长；类中的成员栈向上增长，搞不清了</span>）”即可，各个成员并不一定得连续排列，什么东西可能介于被声明的成员之间呢，如为对齐而补齐的字节，vptr 等</div></li><li><div>C++没有规定不同的访问限制符下的成员的排列顺序，但大部分编译器还是按照顺序排列</div></li><li><div>C++标准允许vptr放在对象的任何位置，一般编译器会放在对象的头部或尾部</div></li></ul></ul><div>    2.数据成员的存取</div><ul><li><div>普通成员的存取成本是多大？每个成员的存取，以及与class的关联，并不会导致任何空间或执行时间上的额外负担——<span style="color: rgb(227, 0, 0);">不是要通过对象去获取吗？这中间是否有寻址？——编译阶段应该已经确定了地址</span></div></li><li><div>静态数据成员：经由对象的.或者-&gt;对静态成员的存取操作只是语法上的一种便宜行事，即便是定义在虚继承基类内，存取路径仍然很直接，所以封装不会带来存取成本</div></li><ul><li><div>被编译器提出class之外，并被视为一个全局变量，存放在data段中，所以若取一个静态数据成员，会得到指向其数据类型的指针而非一个指向其类成员的指针。每一个静态成员只有一个实体</div></li><li><div>如果不同的class有同名的static成员，都存放在data段中，怎么做区分？编译器会改写名称，具体不同的编译器有不同的做法</div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">在类内声明，必须在类的外部定义和初始化每个静态成员，只能定义一次；static关键字只出现在类内声明中；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">静态数据成员可以是不完全类型，特别的，静态数据成员的类型可以是它所属的类类型，而非静态数据成员则受到限制，只能声明成它所属类的指针或引用——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">待验证</span></div></li><li><div>可以使用静态成员作为默认实参，非静态数据成员则不能</div></li></ul><li><div>非静态成员：</div></li><ul><li><div>欲对一个非静态成员进行存取操作，编译器需要把类对象的起始地址加上数据成员的偏移量</div></li><li><div>每一个非静态成员的偏移量在编译期间就能获取地址，即使是派生自单一或多重继承链，因此存取一个非静态成员的效率和存取一个C结构体的成员的效率是一样的</div></li></ul></ul><div>    3.继承与数据成员</div><ul><li><div>C++标准并未强制指定基类和派生类成员的排列次序，大部分编译器按先基类后派生类的顺序，<span style="color: rgb(227, 0, 0);">如果是虚基类就例外</span></div></li><li><div>只要继承不要多态：</div></li><ul><li><div>一般而言具体继承不会增加空间或存取时间上的额外负担</div></li><li><div>字节对齐导致的膨胀，以及子类赋值给父类，填补了字节对齐而补充的字节，造成子类的值被覆盖</div></li></ul><li><div>加上多态</div></li><ul><li><div>会带来哪些负担？</div></li><ul><li><div>新增一个和增加虚函数类相关的虚表，虚表元素数目是虚函数数目加上一两个元素空间以支持运行时类型识别</div></li><li><div>在每个类对象中增加一个虚指针，指向虚表</div></li><li><div>加强构造，使能够设定vptr；加强析构，使能够消除vptr</div></li></ul></ul><li><div>多重继承：C++标准并未要求多重继承的父类在内存中的排列顺序，大部分按从左到右排序。这种情况下要注意，子类转换为排序靠后的父类时要注意字节偏移</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Point2d{};</div><div>class Point3d{};</div><div>class Vertex{};</div><div>class Vertex3d :public Point3d, public Vertex{};</div><div>Vertex3d v3d, Vertex *pv, Point2d *p2d, Point3d *p3d;</div><div>pv = &amp;v3d;    // 需要进行这样的转换：pv = (Vertex*)(((char*)&amp;v3d)+sizeof(Point3d));</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Vertex3d *pv3d; Vertex *pv; </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">pv = pv3d;    不只是简单的上述转换了，对于指针，内部转换操作需要有一个条件测试：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">pv = pv3d ? (Vertex*)</span>(((char*)&amp;v3d)+sizeof(Point3d)):0;</div></div><ul><li><div>虚拟继承：解决下图所示的菱形继承问题</div></li><ul><li><div>语言层面导入虚拟继承之后，如果class内含一个或多个virtual base class（下图种的istream或ostream），将被分割成两部分，一个不变局部和一个共享局部。不变局部种的数据不管后继如何衍化总是拥有固定的offset，所以这部分数据可直接存取，共享局部所表现的就是虚基类的部分，这部分数据位置会因为每次的派生操作而有变化，所以只能被间接存取。各家编译器实现技术之间的差异就在于间接存取的方法不同</div></li><li><div>一般的布局策略是先安排好derived class的不变部分，然后再建立其共享部分；微软的解决办法是引入virtual base class table，每个class object如果有一个或多个virtual base classes，就会由编译器安插一个指针指向virtual base class table</div></li><li><div>一般而言virtual base class最有效的一种运用形式就是：一个抽象的virtual base class，没有任何数据成员</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class ios{ ... };</div><div>class istream: public virtual ios{ ... };</div><div>class ostream: public virtual ios{ ... };</div><div>class iostream: public istream, public ostream { ... };</div></div><div><img src="对象模型_files/Image.png" type="image/png" data-filename="Image.png" width="321"/></div><div>    4.对象成员的效率：</div><ul><li><div>测试结果表明，打开编译器的优化后单一继承（不支持多态）封装不会带来执行期的效率成本，成员被连续存储在对象中，并且偏移量在编译期就是已知的</div></li><li><div>虚拟继承的效率总是令人失望</div></li></ul><div>    6.指向数据成员的指针</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Point3d{</div><div>public:</div><div>    float x, y, z;    </div><div>}</div><div>Point3d origin;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">问题1：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">vs上运行</span>printf(&quot;x: %p\n&quot;, &amp;Point3d::x)为0，</div><div>float Point3d::*p1=0; printf(&quot;x: %p\n&quot;, &amp;Point3d::x); // vs测试打印为FFFFFFFF</div><div>float Point3d::*p2 = &amp;Point3d::x;    //注意x的类型是float Point3d::</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">所以 p1 != p2</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">问题2：</span><span style="font-family: Monaco; font-size: 9pt;">&amp;Point3d::x和&amp;origin.z之间有什么差异？</span></div><div><span style="font-family: Monaco; font-size: 9pt;"><font color="#328712">取一个数据成员的地址，将会得到它在class中的偏移量（可以认为它是一个不完整的值）</font>，而取一个绑定于类对象上的数据成员得到的是该成员在内存中的真正地址</span></div></div><ul><li><div>如果不做优化，以指向数据成员的指针存取数据要消耗直接存取的两倍的时间——？</div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">类成员指针：使用classname::*的形式声明一个指向数据成员或成员函数的指针</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">当初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针时才提供对象的信息</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">常规的访问规则对成员指针仍然有效，如public，private</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">使用类型别名或typedef可以让成员指针更容易理解</span></div></li><li><div><span style="font-family: Georgia;">使用成员函数指针调用对象时需要用到两个C++操作符：&quot;.*&quot;和&quot;-&gt;*&quot;,这两个操作符优先级都很低，所以通常用括号保证表达式语法正确</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">class A{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public:</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    void Eat() { cout &lt;&lt; &quot;Eat&quot; &lt;&lt; endl; }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">};</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">typedef void (A::*TpMemFun) ();  // 成员函数指针类型</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// 给</span>TpMemFun的对象赋值及调用：</div><div>TpMemFun mfp1 = &amp;A::Eat;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">A a;</span></div><div><span style="font-family: Monaco; font-size: 9pt;">(a.*mfp)();</span><span style="font-family: Monaco; font-size: 9pt;">    // 通过普通对象调用A中的Eat成员函数</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">A *pa = new A;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">(pa-&gt;*mfp)();    // 通过指针对象调用</span></div></div><div><br/></div><div><span style="font-weight: bold;">四. 函数语意</span></div><div>    1.成员函数的各种调用方式</div></div><ul><li><div>非静态成员：C++设计准则之一是非静态成语函数至少必须和普通函数有相同的效率，因为编译器已经在内部将成员函数转换为对等的非成员函数，步骤：</div></li><ul><li><div>修改函数签名，在函数参数第一个位置处插入this指针，<span style="font-size: 10pt; font-family: Georgia;">this类型是指向类类型非常量版本的常量指针，T *const this，如果是const函数，const T *const this</span></div></li><li><div>将每一个非静态成员的操作改成由this指针来存取</div></li><li><div>将成员函数重新写成一个外部函数，对函数名称进行处理，使之独一无二</div></li><ul><li><div>成员函数名称会加上命令空间名称，类名，参数链表等，至于具体怎么加，目前的编译器没有统一的编码方法（c++filt工具可解析出来），并伴随NRV优化</div></li><li><div>extern &quot;C&quot;会压抑特殊处理效果——<span style="color: rgb(227, 0, 0);">具体怎么做的？</span></div></li></ul></ul><li><div>虚成员函数：通过vptr调用。vptr的名称也有可能被改写，因为在一个复杂的类派生体系中可能存在多个vptrs</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ptr-&gt;normalize();  // normalize()是一个虚函数</div><div>在内部会被转换为：(*ptr-&gt;vptr[n])(ptr)</div></div><ul><li><div>静态成员函数：主要特性是没有this指针</div></li><ul><li><div>静态成员的名称也会被修改</div></li><li><div>不能够直接存取非静态成员</div></li><li><div>不能够被声明为const，volatile或virtual，因为静态成员没有this指针，const是用来修饰this的</div></li><li><div>不需要经过class的对象来调用，大部分这样的调用只是为了符号上的便利</div></li></ul></ul></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>静态成员函数：static unsigned int &amp;Point3d::object_count();</div><div>&amp;Point3d::object_count()的类型是：</div><div>unsigned int (*)()而不是unsigned int (Point3d::*)();</div><div>静态成员可以通过以下形式调用：</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">((Point3d*)0)-&gt;</span>object_count()</div></div><div><br/></div><div>    2.虚函数：C++中的<span style="color: rgb(65, 0, 125); font-weight: bold;">多态</span>表示以一个公有继承的父类指针寻址出一个子类对象</div><ul><li><div>对多态的支持：</div></li><ul><li><div>编译阶段：</div></li><ul><li><div>编译器建构好虚函数表的大小和内容（虚函数在编译期可以获取到，并且是固定不变的，将虚函数地址放在表中）</div></li><li><div>给每个类对象添加虚指针并指向虚表，给每个虚函数指派一个索引值</div></li></ul><li><div>执行期要做的就是激活虚函数（<span style="color: rgb(227, 0, 0); font-weight: bold;">不就是调用一个函数指针造成的性能吗，为什么会很低？</span>）；</div></li></ul><li><div>一个类只能有一个虚函数表，每一个表内对应虚函数的地址，包括：</div></li><ul><li><div>这个类所定义的虚函数实体，他会改写一个可能存在的从基类继承的虚函数</div></li><li><div>继承自基类的函数实体，这是不改写虚函数时才出现的情况</div></li><li><div>纯虚函数，它既可以占位，也可以当作<span style="color: rgb(227, 0, 0);">执行期异常处理函数</span></div></li></ul><li><div>多重继承下的虚函数</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>问题1：怎样确定调用的是哪一个虚函数?</div><div>Base* pBase = new Derived1;  </div><div>// 编译器会转换如下：</div><div>Derived1 *temp = new Derived1;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Base* pBase = temp ? temp + sizeof(Base): 0;——</span><span style="font-size: 9pt; font-family: Monaco;"><font color="#E30000">这个转换不理解</font></span></div></div><ul><li><div><font style="color: rgb(227, 0, 0);">虚拟继承下的虚函数</font>：</div></li><li><div>虚函数不能是内联的，放弃了内联，这也是虚函数的一个代价</div></li><li><div>对一个虚成员函数取地址，所能获得的只能是一个索引值—<span style="color: rgb(227, 0, 0);">—？</span></div></li></ul><div>    3.函数的效能</div><ul><li><div>inline函数不止能够节省一般函数调用所带来的负担，也提供了程序优化的额外机会——具体做了哪些优化</div></li></ul><div>    4.指向成员函数的指针</div><ul><li><div>取一个非静态数据成员的地址，如果该函数是非虚，则得到的结果是它在内存中真正的地址，然而这个值也是不完全的，需要绑定到某个类对象的地址上，才能通过它调用该函数，所有的非静态成员函数都需要对象的地址</div></li><li><div>以下两个问题：</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>printf(&quot;Point::~Point: %p\n&quot;, &amp;Point::~Point);  // <font color="#E30000">并不能打印出析构的地址，编译器报错：构造函数或析构函数不能提取其自身；原因：C++标准规定，不能获取构造函数和析构函数的地址，指向成员函数的指针可以，指向构造和析构的不行，因为构造和析构都是没有返回值的</font></div><div>printf(&quot;Point::z: %p\n&quot;, &amp;Point::z);            // <font color="#E30000">并没有打印出z（虚函数）的序号，打印出的是地址，这个地址是什么？</font></div></div><div>    5.Inline函数</div><ul><li><div>一般而言处理一个inline函数有两个阶段：</div></li><ul><li><div>分析函数的复杂度或建构等问题判断能否称为inline函数，如果被判断不可成为inline函数，它会被转为一个static函数，并在被编译模块内产生对应的函数定义</div></li><li><div>必须要到汇编器里面才能看到inline的真正实现了</div></li></ul><li><div>形参：如果inline的实际参数是一个表达式，就要先求值，所以inline函数可能会产生大量的临时变量，所以用起来还是要谨慎</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>inline int min(int i, int j) { return i &lt; j ? i: j; }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">int mainval = min(foo(), bar() + 1);   // 扩展成：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">int mainval = (t1 = foo()), (t2 = bar() + 1), t1 &lt; t2 ? t1 : t2;</span></div></div><ul><li><div>局部变量：inline函数中的局部变量在展开后也会产生临时变量，如果是单一表达式扩展多次，每次扩展都需要一组表达式；如果是以分离的多个式子被扩展多次，只需一组变量；结合下面的例子，看看产生了多少的临时变量：</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>inline int min(int i, int j) { int val = i &lt; j ? i: j; return val; }</div><div>int val = min(val1, val2) + min(foo(), foo()+2)</div></div><div><br/></div><div><span style="font-weight: bold;">五. 构造，析构，拷贝语意</span></div><ul><li><div>总说：</div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">默认的构造，拷贝构造，拷贝赋值运算符和析构都是public且inline的，编译器生成的析构是non-virtual；拷贝构造和拷贝赋值也只是单纯的将对象的每一个non-static成员变量拷贝到目标对象</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">编译器拒绝生成默认拷贝运算符的两种情况：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">类中含有一个reference成员或const成员，因为这两类成员初始化之后不允许改变；</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">如果基类的拷贝运算符是private，子类也拒绝生成一个拷贝运算符（</span><span style="font-size: 10pt; color: rgb(65, 173, 28); font-family: Georgia;">拷贝构造呢？</span><span style="font-size: 10pt; font-family: Georgia;">）；所以需要自己实现</span></font></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">主动阻止编译器自动生成拷贝构造和拷贝赋值运算符（不只是拷贝相关操作）</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">可将相应的成员函数声明成private并且不予实现，但如果在成员函数或友元函数中调用会在链接期报错</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">定义一个专门为了阻止copying动作的基类，定义private成员，并以private的方式继承之，这些函数的编译器生成版会尝试调用其base class的对应兄弟（？）可</span><span style="font-size: 10pt; font-family: Georgia;">将链接期错误转移至编译期</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">在c++11中，将拷贝构造和拷贝赋值运算符定义为删除的函数来阻止拷贝：在参数列表后加=delete;</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">执行拷贝操作时要确保：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">复制所有的local成员变量</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">调用所有基类内的适当的拷贝函数</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">通过调用带一个实参的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则；可以通过将构造函数声明为explicit加以阻止：explicit只对</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">一个实参</span><span style="font-size: 10pt; font-family: Georgia;">的构造函数有效；只在类内声明时使用，在类外定义时不应重复；需要多个实参的构造函数不能用于执行隐式转换，所以无须声明为explicit；explicit构造函数只能用于直接初始化，虽然explicit不能用于隐式转换，但可以显式的强制进行转化：</span></font></div></li><li><div><span style="font-family: Georgia;">继承构造函数：使用using A::A</span></div></li><li><div><span style="font-family: Georgia;">委托构造函数：</span><span style="font-size: 10pt; font-family: Georgia;">使用其他构造函数执行自己的初始化过程；</span><span style="font-family: Georgia;">委派构造函数是在构造函数的初始化列表位置进行构造，委派的；但是构造函数不能同时委派和使用初始化列表，所以初始化代码必须放在函数体中</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">访问控制：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">public：对象和子类成员都可以访问</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">protected:</span><span style="font-size: 10pt; font-family: Georgia;"> 在本类和派生类的成员，友元中能够使用，但对象不能使用</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">private：只能本类中使用，对于派生类来说是不可访问的</span></div></li></ul></ul><li><div>如果基类的析构是纯虚函数，则必须要有定义，否则会导致链接的失败，因为子类调用的时候会调用到；较好的方案就是不要把虚析构声明成纯虚。<span style="font-size: 10pt; font-family: Georgia;">不过有个好处是一举两得(既是抽象类，又是虚析构函数)</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Base</div><div>{</div><div>public:</div><div>       virtual ~Base() = 0</div><div>       {</div><div>              cout &lt;&lt; &quot;Base::~Base&quot; &lt;&lt; endl;</div><div>       }</div><div>};</div></div><ul><li><div>虚函数最好不要声明成inline函数<span style="color: rgb(227, 0, 0);">——内联时函数会展开，但虚函数只有在调用时才能确定具体调用哪个</span></div></li><li><div>虚函数中const存在：最好的方法是不要把虚函数声明成const函数，因为有可能在派生类中会改变成员</div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">移动构造/移动赋值：如果一个类没有移动操作，通过正常的函数匹配，类会使用相对应的拷贝操作来代替移动操作，——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">移动构造一般用在什么情况下？</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">移动构造接受一个右值引用的参数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">定义了一个移动构造函数或移动赋值运算符的类也必须定义一个常量左值为参数的拷贝操作，否则这些成员默认的被定义为删除的；所以定义了移动构造一般会定义拷贝构造，移动不成再拷贝</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使试图通过move来移动也是如此（用拷贝构造函数代替移动构造函数几乎肯定是安全的）</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">移动构造函数</span><span style="font-size: 10pt; color: rgb(50, 135, 18); font-family: Georgia;">必须确保移后源对象处于这样一种状态：销毁它是无害的</span><span style="font-size: 10pt; font-family: Georgia;">，一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源的归属权已经归属新创建的对象，</span><span style="font-size: 10pt; font-family: Georgia;">必须确保移后源对象进入一个可析构的状态（也就是移后源对象可以随时析构掉）</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">由于移动操作是窃取资源，通常不分配任何资源，所以不会抛出任何异常；不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept，在声明和定义中都要指定</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">类似移动构造函数，移动赋值运算符必须正确处理自赋值<span style="font-size: 10pt; font-family: Georgia; color: rgb(255, 0, 0);">——？</span></span></div></li><li><div><span style="font-family: Georgia;">移动构造何时被触发？一旦用到的是临时变量，移动构造就会调用——</span><span style="color: rgb(255, 0, 0); font-family: Georgia;">如何判断是临时变量</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">移动构造(移动赋值运算符)的生成条件：</span></div></li><ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">如果定义了拷贝操作（拷贝构造和拷贝赋值运算符）和析构函数中的一个或多个，则</span><span style="color: rgb(51, 51, 51); font-family: Georgia;">编译器不会为类定义默认移动构造</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">每个非static数据成员都可以移动</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">所以</span><span style="font-family: Georgia;">拷贝构造/拷贝赋值和移动构造/移动赋值必须同时提供或同时不提供，才能保证类同时有拷贝和移动语义，只声明其中一个的话类都仅能实现一种语义</span></div></li></ul><li><div><span style="font-family: Georgia;">在#include&lt;type_traits&gt;中，可以使用辅助的模板类来判断一个类型是否是可以移动的，如</span></div></li><ul><li><div><span style="font-family: Georgia;">is_move_constructible</span></div></li><li><div><span style="font-family: Georgia;">is_trivially_move_constructible</span></div></li><li><div><span style="font-family: Georgia;">is_nothrow_move_constructible,使用方法仍然是使用其成员value</span></div></li></ul><li><div><span style="font-family: Georgia;">对于移动构造函数来说抛出异常是危险的事情，所以通过声明为noexcept，在抛出异常时直接调用terminate来结束程序；可用std::move_if_noexcept的模板函数替代move函数，该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义；而在类的移动构造中有noexcept时返回一个右值引用，从而使变量可以使用移动语义</span></div></li></ul></ul><div><span style="font-weight: bold;">   </span></div><div>    1.无继承情况下的对象构造</div><ul><li><div>POD类型的全局变量不会执行默认构造，不过与C不同的是，未定义的全局变量在C中会被视为一个临时性定义，存在bss段中，bss段在C++中并不重要，因为C++构造行为的隐含应用之故。C++中所有全局对象都被当作初始化过的数据对待</div></li><li><div>POD类型的C++类编译器会辨别出来，所以不会产生默认的构造等或产生了但不调用；赋值操作也会像C一样进行纯粹的位拷贝操作，删除时析构也不会被产生或调用，所有的操作如同C结构体一样进行位搬移</div></li><li><div>虚函数的引入带来class的膨胀：</div></li><ul><li><div>构造函数附加了代码：初始化vptr，在所有基类构造之后，程序员代码之前调用（在构造函数体中，不过具体要看编译器的实现）</div></li><li><div>合成拷贝构造和拷贝赋值运算符，且是non-trivial，不再支持位拷贝，合成的拷贝操作会自动拷贝虚指针的</div></li><li><div>编译器在优化状态下可能会把对象的连续内容拷贝到另一个对象身上，而不会精确的以成员为基础的赋值操作，C++标准要求编译器尽量延迟non-trivial成员的实际合成操作，直到使用时</div></li></ul></ul><div>    2.继承体系下的对象构造</div><ul><li><div>一个对象的定义可能会让编译器按顺序做如下扩充操作：</div></li><ul><li><div>虚基类的构造被调用，从左到右，从深到浅</div></li><ul><li><div>如果class被列到成员初始化列表中，如果有任何明确的参数都应传递过去；如果没有列到初始化列表中，调用默认构造</div></li><li><div>class中每一个虚基类子对象的偏移量必须在执行期可被存取<span style="color: rgb(227, 0, 0); font-weight: bold;">——？？</span></div></li><li><div>如果类对象是最底层的，构造可能被调用，某些用于支持这个行为的机制必须被放进来</div></li></ul><li><div>所有上一层基类的构造函数必须被调用，以基类的声明顺序为顺序</div></li><ul><li><div>如果基类被列到成员初始化列表中，那么任何明确指定的参数都要给传过去</div></li><li><div>如果基类没有列到成员初始化列表中，有默认构造就调用之</div></li><li><div>如果基类是多重继承下的第二或后继的基类，那么this指针必须有所调整<span style="color: rgb(227, 0, 0); font-weight: bold;">——？？</span></div></li></ul><li><div>如果类有vptr，必须被设定初值，以指向虚表；如果有一个成员并未出现在初始化列表中，该默认构造必须被调用（基础类型为默认值）</div></li><li><div>以数据成员的声明顺序在初始化列表中进行初始化</div></li></ul><li><div>一个类的成员如果有显式的构造，拷贝构造，它自己如果没有定义也会合成；<span style="color: rgb(227, 0, 0);">如果一个类的成员的拷贝构造是delete的，这个类没有显式定义拷贝构造，编译器会怎么做？应该是不会合成</span></div></li><li><div>虚拟继承：<span style="font-size: unset; color: unset; font-family: unset;">在有虚基类的构造初始化中，最上面公共继承的父类的构造只调用一次，最底层继承的类负责构造最顶层共享的父类，编译器的大概实现是加一个bool字段，在每一层派生的子类构造中添加代码判断是否是最下面的子类，如果是去调用虚基类构造；如果不是就不调用</span></div></li><li><div>vptr初始化语意：</div></li><ul><li><div>vptr的初始化是在基类构造调用之后，在成员列表初始化之前</div></li><li><div>构造/析构中调用一个虚函数是以静态方式调用，不会用到虚拟机制；所以尽量不在构造和析构中调用虚函数</div></li><ul><li><div>在调用父类构造时子类还没有开始构造，所以此时的对象还是父类的，不会触发多态；所以基类构造期间绝不在构造和析构中调用virtual函数</div></li><li><div>析构同样，子类先进行析构，虚函数被调用时子类内容已经被析构了，所以会执行父类的virtual函数</div></li></ul><li><div>在类成员中调用虚函数来初始化成员是安全的，但语意上是不安全的，因为有可能依赖未设置初值的成员。所以不推荐</div></li></ul></ul><div>    3.对象拷贝语意：</div><ul><li><div>如果类是一个POD类型，自己定义的拷贝赋值运算代替了按位拷贝反倒会降低执行速度，在什么情况下需要定义拷贝语义？只有在默认行为所导致的语意不安全或不正确时才需要设计拷贝赋值运算符</div></li><li><div>一个类对于默认的拷贝赋值运算符，在以下情况不会表现出按位拷贝行为（<span style="color: rgb(227, 0, 0);">重复</span>）：</div></li><ul><li><div>成员变量有拷贝赋值运算符</div></li><li><div>基类有一个拷贝赋值运算符</div></li><li><div>类声明了虚函数</div></li><li><div>类继承自虚函数</div></li></ul><li><div>默认拷贝构造虽然也可以完成位拷贝，考虑到NVR优化，可能需要提供显式拷贝构造；定义了拷贝构造并不意味着必须要提供拷贝赋值运算符</div></li><li><div>尽可能不要允许一个虚基类的拷贝操作(甚至不要在任何虚基类中声明数据），多重虚基类可能会造成重复拷贝赋值</div></li></ul><div>    4.对象的功能</div><ul><li><div>按位拷贝：</div></li><ul><li><div>初始化列表初始化指令只有一个，先存储再赋值有两条指令；</div></li><li><div>额外的单一继承或多重继承不影响成员对象的初始化或拷贝操作的成本</div></li></ul><li><div>导入虚拟继承之后，class不再有按位操作，导致效率降低（书中的例子看默认合成的降低2倍，自定义降低接近1倍）——<span style="color: rgb(227, 0, 0);">需要自测</span></div></li></ul><div>    5.析构语意</div><ul><li><div>如果class没有析构，<span style="font-weight: bold;">只有</span>class的成员变量有析构的情况下编译器才会自动合成析构，否则不会合成，即使是有虚函数。不要因为不确定就提供析构，提供了反而降低效率；——<span style="color: rgb(227, 0, 0);">为什么会降低效率？</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">析构函数</span><span style="font-size: 10pt; font-family: Georgia;">可以是内联的</span></div></li><li><div>析构顺序（和构造相反）：</div></li><ul><li><div>执行析构函数本身</div></li><li><div>如果成员变量有析构，按相反的声明顺序调用成员变量的析构，vs中人写代码在前面，默认成员的析构代码在后面</div></li><li><div>如果有vptr，先<span style="color: rgb(65, 0, 125);">重新设定，指向适当的基类虚函数表</span></div></li><li><div>调用父类析构</div></li></ul><li><div>当在析构函数中抛出异常时：</div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">调用abort()直接退出程序</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">使用try catch捕获异常，但只是吞掉了异常，并没有处理；所以</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果需要对某个函数运行期间抛出异常做出反应，class应该提供一个普通函数来执行该操作，让使用者去处理这个异常</span></div></li></ul></ul><div>六：执行期语意：</div><ul><li><div>对象的构造和析构：</div></li><ul><li><div><span style="font-size: unset; color: unset; font-family: unset;">全局对象：</span><span style="font-size: unset; color: unset; font-family: unset;">C++中所有的全局变量保存在data段中，如果没有给初值就赋值为0，这个和C的不自动设定初值不同——</span><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset;">C++中全局基础类型的变量不在bss段？</span></div></li><li><div>局部静态对象：C++标准规定静态局部自定义类型变量在函数第一次调用时初始化</div></li><li><div>对象数组：</div></li></ul><li><div>new和delete运算符</div></li><ul><li><div>一个new运算符的两个步骤：<span style="font-size: unset; color: unset; font-family: unset;">申请内存；</span><span style="font-size: unset; color: unset; font-family: unset;">调用构造，如果是内建类型的话给赋初值</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int *p = new int[0];  // 这样写是合法的，语言要求每一次对new的调用都必须传回一个独一无二的指针，解决该问题的方法是内部判断为0时传回一个指针，指向一个默认为1byte的内存区块</div></div><ul><ul><li><div>针对数组的new语意</div></li><li><div>placement operator new</div></li></ul><li><div>临时性对象</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>T c = a + b;      // 编译器基本上不会产生一个临时变量,为什么不会产生临时；<font color="#E30000">这两个的不同有疑问</font></div><div>c = a + b;        // 赋值语句，（<font color="#328712">和上面一句是完全不一样的，上面的效率更高</font>）不能忽略a+b所产生的临时变量，会导致以下结果：</div><div>T temp;</div><div>temp.operator(a+b);   // </div><div>c.operator=(temp);</div><div>temp.T::~T();</div></div><ul><ul><li><div>临时对象的生命周期：应该是在完整表达式求值过程中的最后一个步骤结束之后析构或释放（分号之后就释放了）</div></li><ul><li><div>例外：如果一个临时性对象被绑定于一个引用，对象将残留，知道被初始化之引用的生命结束，或临时对象的生命范畴结束</div></li><li><div><span style="color: rgb(227, 0, 0); font-weight: bold;">反聚合</span>的优化操作能够减少临时对象的产生，对于效率的提升有很大的帮助</div></li></ul></ul></ul><div><br/></div><div>七：站在对象模型的顶端</div><ul><li><div>执行期类型识别：</div></li><ul><li><div>保证安全的向下转型操作：</div></li><ul><li><div>需要额外的空间以储存类型信息，通常是一个指针，指向某个类型信息节点</div></li><li><div>需要额外的时间已决定执行期的类型，</div></li></ul><li><div>保证安全的动态转型：dyanmic_cast可以在执行期决定真正的类型，如果是安全的（也就是说父类指针指向派生类对象），这个运算符会传回被适当转型过的指针，如果不是安全的，会传回空</div></li><ul><li><div>究竟用static还是dynamic，必须视pt指向的是否是一个多态对象而定</div></li><li><div>引用不是指针，如果dynamic_cast运算符施行于一个引用时，不能够提供于针对于指针的那一组true/false，因为如将一个引用设为0，会引起一个临时对象被产生出来，该临时对象的初值为0。取而代之的是：</div></li><ul><li><div>如果引用真正参考到适当的派生类，向下转换会继续执行</div></li><li><div>如果引用不是某一种派生类，由于不能够传回0，丢出一个bad_cast的异常</div></li></ul><li><div>Typeid运算符：使用typeid运算符，就有可能以一个引用达到相同的执行期替代路线；typeid运算符传回一个const reference，类型为type_info;</div></li><ul><li><div>typeid也可以适用于内建类型和非多态的使用者自定义类型，这对于异常的支持有必要；与使用多态的差异在于，这时候的type_info对象是静态取得，而非执行期取得</div></li></ul><li><div>type_info：除了支持operator==和operator!=外，还支持如下两个函数：</div></li><ul><li><div>name()，传回一个const char*代表型别名称，但不一定是类名称，实测windows是类名linux不是</div></li><li><div>before()：type_info对象的次序关系，程序员可运用type_info::before()对type_info对象建立索引——？<span style="color: rgb(255, 0, 0);">怎样建立？</span></div></li><li><div><span style="color: rgb(255, 0, 0);">实现type_info的外覆类</span></div></li></ul></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if(typeid(rt)==typeid(fct)){</div><div>    fct&amp; rf = static_cast&lt;fct&amp;&gt;(rt);</div><div>}</div></div><div><br/></div><div><span style="font-size: 10pt; font-family: Georgia;">继承：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">虚拟继承：为节省内存空间，可以将B和C对A的继承定义为虚继承，A就成了虚拟基类</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">为什么虚函数效率低？因为虚函数要进行一次间接寻址，而一般函数在编译时就确定了函数的地址</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">避免遮掩继承而来的名称（effective c++ 32）：如果子类中有和父类函数名称一样但参数类型或个数不一致的函数，不管父类是virtual函数还是non-virtual函数，不管带参还是无参，子类都会把父类中同名的所有函数覆盖掉；解决办法：可以使用using声明父类的函数避免被覆盖，或使用</span><span style="font-size: 10pt; font-family: Georgia; text-decoration: underline;">转交函数</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">区分接口继承和实现继承</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">纯虚函数是为了让派生类继承接口，纯虚函数可以提供定义但唯一调用途径是</span><span style="font-family: Georgia;">被静态调用(</span><span style="font-size: 10pt; font-family: Georgia;">通过类名调用</span><span style="font-family: Georgia;">)，不能经由虚拟机制调用</span></div></li><li><div><span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">普通函数继承默认实现，声明non-vritual的目的就是令derived classes继承函数的接口及一份强制性实现。</span><span style="font-size: 10pt; color: unset; font-family: Georgia;">注意：</span></div></li><ul><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">基类的虚函数定义了缺省行为，而派生类在未明白说出我要的情况下就继承了该缺省行为，有可能有风险，要切断虚函数接口和其缺省实现之间的联系：(1)将虚函数声明为纯虚，在基类定义默认非虚实现作为缺省实现;(2)定义为纯虚函数，但也可以拥有一份自己的实现</span></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">绝不重新定义继承而来的非虚函数,因为非虚函数是静态绑定的</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">绝对不要重新定义一个继承而来的默认参数值——（</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">定义了会出现什么问题？</span><span style="font-size: 10pt; font-family: Georgia;">）（这个主要针对虚函数，因为重新定义非虚函数永远是错误的），因为默认参数值都是静态绑定的，而虚函数是动态绑定的，这里有个奇怪的现象：如果子类重新定义了继承而来的虚函数，用指针调用参数可以不用带默参，但非指针就必须要定义默参（effective c++ 37）</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">继承控制：继承控制的作用要</span><span style="font-size: 10pt; color: rgb(50, 135, 18); font-family: Georgia;">和访问控制结合</span><span style="font-size: 10pt; font-family: Georgia;">起来使用</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">public: is-a的关系</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">期望一个父亲类型的，都可以传递子类型，这个论点只对public继承才成立</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">private：</span></div></li><ol><li><div><span style="font-size: 10pt; font-family: Georgia;">编译器不会将一个派生类自动转换为基类；——？</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">继承而来的所有成员在子类中都会变成private，即使在父类中是public或protected；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">使用private继承只是为了采用父类的一些特性，并不是两个对象之间有任何关系；<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0);">也不能由子类转成父类</span></span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">private继承意味着is-implemented-in-terms-of,和复合的作用相同，两者如何取舍？尽可能的使用复合(effective c++ 38),必要时才使用private继承，何时需要？当protected成员或虚函数牵扯进来的时候(effective c++ 39)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如何在private继承的对象使用base的成员？using——？</span></div></li></ol><li><div><span style="font-size: 10pt; font-family: Georgia;">protected:</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">继承而来的public和protected变成protected了</span></div></li></ul></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">虚继承：</span></div></li><li><div><span style="font-family: Georgia;">默认继承：private</span></div></li></ul></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">类型转换：</span><span style="font-size: 10pt; font-family: Georgia;">两种函数允许编译器进行转换</span></font></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">单参数构造函数：只有一个参数即可调用构造函数，或是虽定义了多个参数，但第一个参数以后的所有参数都有默认；通过声明explicit关键字，编译器会拒绝为隐式类型转换调用单参数构造函数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">隐式类型转换运算符：operator 关键字，不需要定义函数的返回类型，因为返回类型就是这个函数的名字——谨慎定义类型转换函数，解决的方法是不使用关键字的等同的函数来替代转换运算符；隐式类型转换可能会出现的问题：effective c++ 15</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">越有经验的C++程序员越喜欢避开类型转换运算符</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">注意，在哪些情况下会调用隐式类型转换？？编译器没有发现有合适的类型运算符函数，会试图寻找一个隐式类型转换函数</span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">重载：重载某个操作符时应该返回的是引用</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">C++的规则是每一个重载的operator必须带有一个用户定义类型</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">令operator=返回一个*this的</span><span style="font-size: 10pt; color: rgb(50, 135, 18); font-family: Georgia;">引用</span><span style="font-size: 10pt; font-family: Georgia;">：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">使其为一个左值，可以实现连锁赋值，这个协议不仅适用于=，而且适用于所有赋值相关运算；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">处理自我赋值的方式是证同测试：if(this==&amp;rhs) return *this;（检测是不是自己）;</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">让operator=具备异常安全性就可以自动获得自我赋值安全<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0);">——？</span></span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">拷贝赋值操作符调用copy构造是不合理的；同样copy构造调用copy运算符也是无意义的，如果有相同的部分，可以提取出来作为一个单独的函数，这样的函数是private而且常被命名为init</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">拷贝赋值运算符应该确保复制对象内的所有成员变量及所有的基类成员：通过调用基类拷贝复制运算符；不能用拷贝构造和拷贝运算符互相调用，应该将共同机能放进第三个函数由两个coping函数共同调用</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">不要重载&quot;&amp;&amp;&quot;, &quot;||&quot;, &quot;,&quot;：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">&quot;&amp;&amp;&quot;/&quot;||&quot;: C++使用短路求值法，一旦确定布尔表达式的真假，即使部分表达式没有被测试，仍然停止运算</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">所以说，如果重载了这两个就会改变游戏规则：用函数调用发代替了短路求值法</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果重载(operator&amp;&amp;(expr1, expr2)),不确定expr1和expr2哪个先调用，有可能与短路求值法完全相反</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">逗号表达式：一个包含逗号的表达式先计算逗号左边的表达式，然后计算右边的，整个表达式的结果是逗号右边表达式的结果</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">如果重载，就不能保证左边的表达式先于右边的表达式计算</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">不能重载的运算符还有：.; .*; ::; ?:; new; delete; sizeof; typeid</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">自增，自减前缀返回一个引用，后缀返回一个const对象（不是引用）；为了区别，前缀无参，后缀有一个int参数但不会使用；无const则i++++是成立的，所以返回const有两个原因：与内置类型行为不一致，两次使用后缀所产生的结果与调用者期望不一致：第二次调用改变的是第一次调用返回对象的值，而不是原始对象的值</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">operator*为什么返回const by value？</span></div></li></ul><div><span style="font-size: 10pt; font-family: Georgia;">附：友元函数：</span></div><ol><li><div><span style="font-size: 10pt; font-family: Georgia;">需要用类的实例访问类的数据成员？</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">友元函数是类外的函数，所以放在公有段或私有的都不影响，一般放在声明的开始或结束部分</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">友元函数可以定义在类的内部，这样的函数默认是内联的</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">友元函数没有this指针</span></div></li></ol><div><br/></div><div>设计原则：</div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">继承与面向对象的设计</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">classes之间的关系有is-a，has-a，is-implemented-in-terms-of(根据某物实现出)，应该要确实了解这些 classes相互关系 之间的差异</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">pulic继承意味着 is-a，适用于base class身上的每一件事情都适用于derived class——effective c++ 32有例子——这一点非常重要，你要知道公有继承就是is-a</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">设计一个类：</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">新对象应该如何被创建和销毁？——影响到class的构造函数和析构函数，内存分配和释放函数（operator new/opeartor new[]/operator delete/operator delete[]）</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">对象初始化和对象赋值有什么差别？——这个答案决定构造函数和赋值运算操作符的行为，以及期间的差异</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">新类型的对象如果按值传递，意味着什么？——拷贝构造函数用来定义一个类型的值传递该如何实现</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">需要什么样的类型转换？——和其他类型之间的转换</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">新的type是否需要配合某个继承图系？</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">。。。</span></div></li></ul><div><br/></div><div><span style="font-family: Georgia;">其他汇总：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">如何阻止一个类被实例化？构造声明称private或定义为抽象基类</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">vs c++ 命令行 /dl reportSingleClassLayoutXXX 注：XXX为类名，如果要打印所有class则为reportAllClass</span></div></li><li><div><span style="font-size: 10pt;">让某种类型的对象能够自我销毁：delete this的注意事项：</span></div></li><ul><li><div><span style="font-size: 10pt;">this对象必须是用new操作符分配的，而不是new[], placement new, 也不是局部对象，全局对象</span></div></li><li><div><span style="font-size: 10pt;">delete this之后，不能访问this指针，不能访问该对象任何成员，虚函数等</span></div></li><li><div><span style="font-size: 10pt;">为保证以上，可以采取：</span></div></li><ul><li><div><span style="font-size: 10pt;">将析构函数私有化以保证对象必须使用new在堆上分配对象</span></div></li><li><div><span style="font-size: 10pt;">提供destroy函数，里面只有一句delete this</span></div></li></ul></ul></ul></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">代替虚函数的方案（effective c++ 35）</span></div></li></ul></div><div><br/></div><div>问题归纳：</div><ol><li><div>以下问题：</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class NoDefault {</div><div>public:</div><div>    NoDefault(int i) :i_(i)</div><div>    {}</div><div>public:</div><div>    int i_;</div><div>};</div><div>class C {</div><div>public:</div><div>    NoDefault nf;</div><div>};</div><div>NoDefault没有默认构造可以编译通过，是因为并没有生成对象实例，没有分配内存，没有调用默认构造函数，当分配内存的时候自然会调用默认构造，这个时候编译不通过</div></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 