<html>
<head>
  <title>异常处理</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="754"/>
<h1>异常处理</h1>

<div>
<span><div><div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">总说</span></font>：</div><ul><li><div><span style="font-family: Georgia;">异常安全两个条件：</span></div></li></ul><ol><ol><li><div><span style="font-family: Georgia;">不泄漏任何资源；——通过资源管理类的方式：用自定义类封装锁之类的资源；用智能指针</span></div></li><li><div><span style="font-size: unset; color: unset; font-family: Georgia;">不允许数据败坏——</span></div></li></ol></ol><ul><li><div><span style="font-family: Georgia;">异常安全函数提供以下三个保证之一：</span></div></li></ul><ol><ol><li><div><span style="font-family: Georgia;">基本承诺：</span></div></li><ol><li><div><span style="font-size: unset; color: unset; font-family: Georgia;">异常被抛出时程序内的所有事物仍然保持在有效的状态下，没有任何数据结构遭到破坏 </span></div></li><li><div><span style="font-size: unset; color: unset; font-family: Georgia;">程序的现实状态可以出错，如抛出异常就难以拥有之前定好的背景图等业务类的东西</span></div></li></ol><li><div><span style="font-size: unset; color: unset; font-family: Georgia;">强烈保证：成功便罢，如果失败就回复到函数调用前的状态——copy and swap：为打算修改的对象做出一份副本，然后在副本上做必要的修改，待完全成功再置换</span></div></li><li><div><span style="font-size: unset; color: unset; font-family: Georgia;">不抛掷异常</span></div></li></ol></ol><ul><li><div><span style="font-family: Georgia;">当一个异常发生时，编译系统必须完成以下事情：</span></div></li></ul><ol><ol><li><div><span style="font-family: Georgia;">检验发生throw操作的函数</span></div></li><li><div><span style="font-family: Georgia;">决定throw操作是否发生在try区段内</span></div></li></ol><ul><ul><li><div><span style="font-family: Georgia;">若是，把发生异常的类型和每一个catch子句进行对比</span></div></li><li><div><span style="font-family: Georgia;">吻合：交到catch子句中</span></div></li><li><div><span style="font-family: Georgia;">不吻合：</span></div></li><ul><li><div><span style="font-family: Georgia;">摧毁所有当前局部对象</span></div></li><li><div><span style="font-family: Georgia;">从堆栈中将当前对象推出去</span></div></li><li><div><span style="font-family: Georgia;">进行到程序堆栈的下一个函数中去，重复上述第二点开始的操作</span></div></li></ul></ul></ul></ol><ul><li><div><span style="font-family: Georgia;">异常安全编程基本原则</span></div></li><ul><li><div><span style="font-family: Georgia;">明确哪些操作不会抛出异常</span></div></li><li><div><span style="font-family: Georgia;">确保析构函数不会抛出异常</span></div></li><li><div><span style="font-family: Georgia;">避免异常发生时的资源泄露，这些资源包括动态内存，文件，互斥锁等</span></div></li></ul></ul><div><br/></div><div><br clear="none"/></div><div><span style="font-family: Georgia;"><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">throw表达式</span>：</span></div><ul><li><div><span style="font-family: Georgia;">throw关键字后紧随一个表达式，其中表达式的类型就是抛出的异常类型；</span></div></li><li><div><span style="font-family: Georgia; font-weight: bold;">如果抛出一个空的异常，是捕获不到的</span><span style="font-family: Georgia;">。</span></div></li><li><div><span style="font-family: Georgia;">当执行一个throw时，跟在throw后面的语句将不再执行，程序的控制权从throw转移到与之匹配的catch模块，有两个重要含义：</span></div></li><ul><li><div><span style="font-family: Georgia;">沿着调用链的函数会提早退出，</span><span style="font-family: Georgia;">前面如果分配了资源，然后发生了异常，则后面释放资源的操作不会执行，就会造成资源泄露，所以要注意</span></div></li><li><div><span style="font-family: Georgia;">一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁</span></div></li></ul><li><div><span style="font-family: Georgia;">如果没有找到catch的子句，程序将调用标准库函数terminate终止程序</span></div></li><li><div><span style="font-family: Georgia;">重新抛出：</span></div></li><ul><li><div><span style="font-family: Georgia;">只写</span><span style="font-family: Georgia;">一个throw：</span><span style="font-family: Georgia;">将当前的异常对象沿着调用链向上传递</span></div></li><li><div><span style="font-family: Georgia;">捕获到异常对象w后再throw w：额外多拷贝一次；如果异常类型是派生类，捕获的是基类型，这个操作抛出去的是静态类型：基类型；综合，不建议使用这种方式——<span style="font-family: Georgia; color: rgb(227, 0, 0);">未验证</span></span></div></li></ul><li><div><span style="font-family: Georgia;">异常对象：</span></div></li><ul><li><div><span style="font-family: Georgia;">编译器使用异常抛出表达式来对异常对象进行</span><span style="font-family: Georgia; font-weight: bold;">拷贝</span><span style="font-family: Georgia;">初始化，因此throw语句中的表达式必须要有完全类型，如果该表达式是类类型的话则相应的类必须拥有一个可访问的析构函数和一个可访问的拷贝构造或移动构造；如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型；</span></div></li><li><div><span style="font-family: Georgia;">异常对象位于编译器管理的空间中（</span><span style="color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">到底在堆上还是栈上</span><span style="font-family: Georgia;">），编译器最终无论调用哪个catch子句都能访问该空间，当异常处理完后异常对象被销毁。如同从函数中返回指向局部对象的指针，</span><span style="font-family: Georgia;">抛出一个指向局部对象的指针也是错误的行为</span></div></li><li><div><span style="font-family: Georgia;">当抛出一条表达式时，该表达式的静态编译类型决定了异常对象的类型，如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切割掉一部分，只有基类部分被抛出</span></div></li></ul><li><div><span style="font-family: Georgia;">坑：</span></div></li><ul><li><div><span style="font-family: Georgia;">throw &quot;xxx&quot;这种形式用</span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">catch</span> <span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">(</span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">const</span> <span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">char</span> <span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">c)/</span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">catch</span> <span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">(</span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">char</span><span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">* c)/</span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">catch</span> <span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">(</span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">const</span> <span style="min-height: 11pt; font-size: 9.5pt; color: rgb(43, 145, 175); font-family: NSimSun;">string</span><span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">&amp; c)</span><span style="min-height: 11pt; font-size: 9.5pt;"><span style="font-size: 9.5pt; font-family: Georgia;">都是捕获不到的，throw string(&quot;xxx&quot;)这样可以用</span></span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">catch</span> <span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">(</span><span style="min-height: 11pt; font-size: 9.5pt; color: rgb(0, 0, 255); font-family: NSimSun;">const</span> <span style="min-height: 11pt; font-size: 9.5pt; color: rgb(43, 145, 175); font-family: NSimSun;">string</span><span style="min-height: 11pt; font-size: 9.5pt; font-family: NSimSun;">&amp; c)</span><span style="min-height: 11pt; font-size: 9.5pt;"><span style="font-size: 9.5pt; font-family: Georgia;">捕获到</span></span></div></li><li><div><span style="font-size: 9pt; font-family: Georgia;">catch子句引用类型捕获和值类型捕获不能同时存在，否则编译器报错</span></div></li></ul></ul><div><br/></div><div><span style="font-family: Georgia;"><font style="font-size: 11pt;"><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">try……catch语句</span></font>：</span></div><div><span style="font-family: Georgia;">catch子句：</span></div><ul><li><div><span style="font-family: Georgia;">catch参数：</span></div></li><ul><li><div><span style="font-family: Georgia;">参数声明的类型决定了所能捕获的异常类型。这个类型必须是完全类型，可以是左值引用，但不能是右值引用</span></div></li><li><div><span style="font-family: Georgia;">匹配规则与函数参数类似，但catch异常声明和匹配受到更到限制，</span><span style="font-family: Georgia;">调用函数时程序的控制权会返回到函数调用处，抛出异常时控制权不会回到抛出异常的地方</span><span style="font-family: Georgia;">：</span></div></li><ul><li><div><span style="font-family: Georgia;">类型转换：</span></div></li><ul><li><div><span style="font-family: Georgia;">允许从非常量向常量的类型转换</span></div></li><li><div><span style="font-family: Georgia;">允许派生类向基类转换，但如果catch的参数是非引用类型，异常对象将被切掉一部分</span></div></li><li><div><span style="font-family: Georgia;">数组转换成指针，函数转换成函数指针</span></div></li><li><div><span style="font-family: Georgia;">除此而外，包括算术类型和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用，比如catch double无法捕获抛出的int——<span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">还有哪些转换规则？</span></span></div></li></ul><li><div><span style="font-family: Georgia;">不论通过</span><span style="font-family: Georgia;">传值捕获还是引用捕获，被抛出的异常对象不论是局部还是全局的(静态或全局变量)都将进行拷贝工作，</span><span style="font-family: Georgia;">C++规范要求为异常抛出的对象必须被复制</span></div></li><ul><li><div><span style="font-family: Georgia;">所以抛出异常运行速度要比参数传递慢</span></div></li><li><div><span style="font-family: Georgia;">如果是传值捕获，会建立两个对象的拷贝：拷贝一个临时对象；将临时对象拷贝到catch的参数中；如果是传引用捕获，只拷贝一个临时对象；vs实测发现传值只有一次拷贝构造，传引用没有拷贝，<span style="font-family: Georgia; color: rgb(227, 0, 0);">是不是编译器做了优化？</span></span></div></li></ul><li><div><span style="font-family: Georgia;">当异常对象被拷贝时，拷贝操作是由对象的静态类型而不是动态类型的拷贝构造函数完成的</span></div></li></ul><li><div><span style="font-family: Georgia;">捕获参数类型：</span></div></li><ul><li><div><span style="font-family: Georgia;">传指针捕获：优点：避免对象拷贝；缺点：异常对象很难管理，且不符合C++语言本身的规范，四个标准异常都不是指向对象的指针；结论：避免使用</span></div></li><li><div><span style="font-family: Georgia;">传值捕获：缺点：异常对象被拷贝两次；会产生切割问题，派生类的异常对象被作为基类异常对象捕获时派生类的行为就被切掉了；结论：不推荐使用</span></div></li><li><div><span style="font-family: Georgia;">传引用捕获：优点：异常对象只被拷贝一次，避免切割；结论：推荐使用</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">catch语句是按照出现的顺序逐一匹配，所以越是专门的catch越应该置于整个catch列表的前端</span></div></li><li><div><span style="font-family: Georgia;">catch捕获异常并处理完之后不同于throw后面的语句不执行，catch所在的函数会正常走完</span></div></li><li><div><span style="font-family: Georgia;">可以通过只写</span><span style="font-family: Georgia;">一个throw不包含任何表达式</span><span style="font-family: Georgia;">在一条catch子句中重新抛出异常，将当前的异常对象沿着调用链向上传递；如果catch子句改变了参数的内容，则只有当catch异常声明是引用类型时对参数所做的改变才会被保留并继续传播，</span><span style="color: rgb(227, 0, 0); font-family: Georgia;">注意：只是在继续传播的时候改变了参数值，throw出来的对象值并没有做任何改变。</span><span style="font-family: Georgia;">如下</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>catch(my_error &amp;eObj) { eObj.status = errCodes::serverErr; throw; } // 修改了异常对象</div><div>catch(other_error eObj) { eObj.status = errCodes::badErr; throw; }  // 异常对象的status成员并没有改变</div></div><ul><li><div><span style="font-family: Georgia;">捕获所有异常：既能单独出现，也能与其他几个catch子句一起出现</span></div></li><ul><li><div><span style="font-family: Georgia;">用省略号，形如catch(...)</span></div></li><li><div><span style="font-family: Georgia;">用所有异常的基类Exception</span></div></li></ul></ul><div><div><br/></div><div><span style="font-family: Georgia;"><font style="font-size: 11pt;"><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">noexcept</span></font>：跟在函数的参数列表后面，指定某个函数不会抛出异常</span></div><ul><li><div><span style="font-family: Georgia;">好处：对编译器来说，预先知道某个函数不抛出异常大有裨益：</span></div></li><ul><li><div><span style="font-family: Georgia;">有助于简化调用该函数的代码</span></div></li><li><div><span style="font-family: Georgia;">编译器确认不会抛出异常就能执行某些特殊的优化操作</span></div></li></ul><li><div><span style="font-family: Georgia;">两种用法：</span></div></li></ul><ol><ol><li><div><span style="font-family: Georgia;">跟在函数参数列表后面时是异常</span><span style="font-family: Georgia; font-weight: bold;">说明符</span><span style="font-family: Georgia;">；</span></div></li><ol><li><div><span style="font-family: Georgia;">必须要出现在该函数的所有定义和声明语句之后</span></div></li><li><div><span style="font-family: Georgia;">可以在函数指针的声明与定义中指定noexpect</span></div></li><li><div><span style="font-family: Georgia;">在typedef和类型别名中则不能出现</span></div></li><li><div><span style="font-family: Georgia;">在类的成员函数中noexcept说明符需要在const及引用限定符之后，而在</span><span style="color: rgb(255, 0, 0); font-family: Georgia; font-weight: bold;">final，ovriride</span><span style="font-family: Georgia;">或虚函数的=0之前</span></div></li><li><div><span style="font-family: Georgia;">接受一个可选的实参，是个常量表达式，该实参必须可转换为bool类型，如果实参是true则不会抛出异常，如果是false则函数可能抛出异常。在C++11之前使用throw()——<span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">有啥实质性区别</span></span></div></li></ol><li><div><span style="font-family: Georgia;"><span style="font-family: Georgia; font-weight: bold;">运算符</span>：一元运算符，返回值是一个bool的右值常量表达式，用于表示给定的表达式会不会抛出异常，经常与noexcept说明符混合使用，例如：</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void f() noexcept(noexcept(g()));    // f和g的异常说明一致</div></div><ul><li><div><span style="font-family: Georgia;">noexcept说明符使用场景：</span></div></li><ul><li><div><span style="font-family: Georgia;">确认函数不会抛出异常</span></div></li><li><div><span style="font-family: Georgia;">根本不知道该如何处理异常</span></div></li></ul><li><div><span style="font-family: Georgia;">仍然抛出异常的情况：</span></div></li><ul><li><div><span style="font-family: Georgia;">编译器并不会在编译时检查noexcept，所以在一个函数说明了noexcept的同时又含有throw语句或调用可能抛出异常的其他函数，编译器是可以顺利通过编译的。</span></div></li><li><div><span style="font-family: Georgia;">一个noexcept抛出异常，程序就调用terminate以确保遵守不在运行时抛出异常的承诺<span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">——已经对noexcept函数做了优化之类的怎么办？有可能是捕获不到的</span></span></div></li></ul></ul></div><ul><li><div><span style="font-family: Georgia;">异常说明与指针，虚函数和拷贝控制，析构：</span></div></li><ul><li><div><span style="font-family: Georgia;">函数指针和该指针所指函数必须具有一致的异常说明</span></div></li><ul><li><div><span style="font-family: Georgia;">如果某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数</span></div></li><li><div><span style="font-family: Georgia;">如果显式或隐式的说明指针可能抛出异常，则该指针可以指向任何函数，即使承诺了不抛出异常的函数也可以</span></div></li></ul><li><div>与虚函数：如果虚函数不抛出异常，派生的虚函数必须做出同样的承诺；如果虚函数运行抛出异常，派生类的随便</div></li><li><div>当编译器合成拷贝控制成员时同时也生成一个异常说明</div></li><ul><li><div>如果对所有成员和基类的所有操作都承诺了不抛出异常，则合成的是noexcept的；</div></li><li><div>如果合成成员调用的任意一个可能抛出异常，则合成的是noexcept(false)</div></li><li><div>定义了一个析构而且没有为他提供异常说明，则编译器合成一个，合成的异常说明将假设由编译器为类合成析构函数时所得的异常说明一致——<span style="color: rgb(227, 0, 0); font-weight: bold;">为类合成析构函数所得的异常说明又是什么：</span><span style="font-family: Georgia;">C++11默认析构函数是noexcept(true)的</span></div></li></ul></ul></ul><div><br/></div><div><br clear="none"/></div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">构造/析构与异常</span></font>：聚焦点是构造时抛出异常后不会调用析构，已申请的资源怎样释放</div><ul><li><div><span style="font-family: Georgia;">处理构造函数初始值或语句异常的唯一方法是将构造函数写成</span><span style="font-family: Georgia; font-weight: bold;">函数try语句块</span><span style="font-family: Georgia;">，这样既能处理成员初始化列表抛出的异常也能处理构造函数抛出的异常。如下：</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Blob::Blob(int x) try: data(x) </div><div>{ /* 函数体 */ }</div><div>catch(const std::bad_allco &amp;e)</div><div>{ handle_out_of_memory(e); }</div></div><ul><li><div>C++拒绝为没有完成构造的对象调用析构，所以如果构造中完成部分资源申请随后抛出异常而不在构造内部处理，因为不会调用析构，所以这些已经申请好的资源会得不到释放</div></li><ul><li><div>常用方法是在构造中捕获异常，然后执行一些清除代码，最后再重新抛出异常让它继续传递，但会产生一些重复代码，可以将通用的清除代码放在一个私有函数中让构造和析构调用</div></li><li><div>如果是在构造函数的参数列表中无法使用try/catch，可以用私有成员初始化，参数列表中调用，参考more effective C++ item10（p49）中的例子；在C++11中可以使用函数try语句块</div></li><li><div>最好的办法是使用<span style="font-family: Georgia;">RAII原则保证在发生异常时已申请完成的资源能得到及时释放：</span><span style="font-family: Georgia;">如智能指针</span></div></li></ul><li><div>析构函数不应该抛出不能被它自身处理的异常，如果要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块中，并且在析构函数内部得到处理，确保析构函数能完成它应该做的所有事情</div></li></ul><div><br clear="none"/></div><div><span style="font-family: Georgia;"><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">标准异常类</span>：</span></div><ul><li><div>exception仅仅定义了拷贝构造函数/拷贝赋值运算符，虚析构，和一个名为what的虚成员：const char* what()，一般输出异常信息，如果是自定义的异常类，把要输出的异常信息传给父类构造，通过该函数可以输出。该成员确保不会抛出任何异常</div></li><li><div>exception，bad_cast和bad_alloc定义了默认构造</div></li><li><div>runtime_error和logic_error没有默认构造，担忧一个可接受c风格字符串或string类型实参的构造</div></li></ul><div><span style="font-family: Georgia;"><img src="异常处理_files/Image.png" type="image/png" data-filename="Image.png" width="378"/></span></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 146px;"></col><col style="width: 428px;"></col><col style="width: 130px;"></col></colgroup><tbody style="margin: 0px; padding: 0px;"><tr style="padding: 0px;"><td style="border-collapse: collapse; background-color: rgb(250, 250, 250); border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">标准异常类</span></div></td><td style="border-collapse: collapse; text-align: center; background-color: rgb(250, 250, 250); border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">描述</span></div></td><td style="border-collapse: collapse; text-align: right; background-color: rgb(250, 250, 250); border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">头文件</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">exception</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">最通用的异常类，只报告异常的发生而不提供任何额外的信息</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">exception</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">runtime_error</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">只有在运行时才能检测出的错误</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">rang_error</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">运行时错误：产生了超出有意义值域范围的结果</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">overflow_error</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">运行时错误：计算上溢</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">underflow_error</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">运行时错误：计算下溢</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">logic_error</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">程序逻辑错误</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">domain_error</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">逻辑错误：参数对应的结果值不存在</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">invalid_argument</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">逻辑错误：无效参数</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">length_error</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">逻辑错误：试图创建一个超出该类型最大长度的对象</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">out_of_range</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">逻辑错误：使用一个超出有效范围的值</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">stdexcept</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">bad_alloc</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">内存动态分配错误</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">new</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 146px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">bad_cast</span></div></td><td style="border-collapse: collapse; text-align: center; border: 1px solid rgb(192, 192, 192); width: 428px; padding: 8px;"><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">dynamic_cast类型转换出错</span></div></td><td style="border-collapse: collapse; text-align: right; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div><span style="font-size: 9pt; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">type_info</span></div></td></tr></tbody></table><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">问题汇总</span></font>：</div><ul><li><div><span style="font-family: Georgia;">数组越界没有异常，因为它不会抛出异常</span></div></li><li><div><span style="font-family: Georgia;">abort：结束程序</span></div></li></ul></div><ul><li><div><span style="font-family: Georgia;">assert(expr)：表达式expr为0,先向stderr打印一条信息，然后调用abort终止程序 </span></div></li><li><div>std::current_exception()：将当前异常以类型std::exception_ptr生成出来，如果当前并无异常就生成nullptr</div></li></ul><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div></div></span>
</div></body></html> 