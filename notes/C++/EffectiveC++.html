<html>
<head>
  <title>EffectiveC++</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="757"/>
<h1>EffectiveC++</h1>

<div>
<span><div><div><span style="font-size: 12pt; font-family: 宋体;">Effective C++:</span></div><div><span style="font-size: 12pt; font-family: 宋体;">05：编译器默认生成构造，拷贝构造，拷贝赋值运算符，析构，且都是public和inline的；如果类中含有reference或者const，或者父类的拷贝赋值运算符为private，则编译器拒绝生成拷贝赋值运算符——<span style="font-size: 12pt; font-family: 宋体; color: rgb(134, 0, 164);">应该同样不能生成拷贝构造函数吧</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-family: 宋体;">06：若不想使用编译器自动生成的函数就该明确拒绝：</span></span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">可以将不想生成的函数声明为private但不定义——如果friend或member函数调用会报链接器错误</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">定义一个类，默认生成的定义为private来继承——friend或member调用会在编译器报错</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">在C++11中定义为delete</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">07：为多态基类声明virtual析构函数：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">任何类只要带virtual函数就应该带virtual析构函数</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">如果不作为基类，就不要定义任何virtual包括虚析构</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">每个定义了virtual的类都有一个相对应的虚函数表，当对象调用某一个虚函数时，实际被调用的函数取决于虚表指针指向的虚函数表——编译器在其中寻找适当的指针</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">定义抽象类：手头没有纯虚函数使用，可以将析构定义为纯虚函数</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">标准string和STL都被设计不被作为基类使用</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">08：别让异常逃离析构：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">C++并不禁止析构吐出异常，但不鼓励这样做，析构抛出异常</span><span style="font-size: 12pt; font-family: 宋体;">可以有两个方法处理，但不是最好：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">抛出异常后通过std::abort()结束程序</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">吞下异常</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">较好的处理方式是重新设计接口，使客户有机会做出反应而不是在析构中，比如，客户自己去调用可能抛出异常的函数</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">09：绝不在构造和析构中调用virtual函数：</span></div><div><span style="font-size: 12pt; font-family: 宋体;">10：令operator=返回一个reference to *this：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">为什么要这样做？考虑到连续赋值</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">这个标准适用于所有赋值相关操作如+=等</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">11：在operator=中处理自我赋值：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">增加证同测试达到自我验证：if(this==&amp;rhs) return *this;</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">12：复制对象时勿忘其每一个成分</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">复制所有本地类的变量</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">调用所有基类内的适当的拷贝函数</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">13：以对象管理资源：RAII对象，构造中获得资源，析构中释放资源</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">禁止复制</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">底层资源使用引用计数——shared_ptr的用法</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">转移底部资源的拥有权——unique_ptr的用法</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">14：在资源管理类中提供对原始资源的访问</span></div><div><span style="font-size: 12pt; font-family: 宋体;">18：让接口容易被正确使用，不易被误用</span></div><div><span style="font-size: 12pt; font-family: 宋体;">19：定义一个新类型</span></div><div><span style="font-size: 12pt; font-family: 宋体;">20：用const引用的方式代替值传递：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">避免对象的构造和析构</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">避免对象的切割：如果是值传递，传给基类参数类型的子类对象参数会被切割到只留基类部分，传引用不会，因为编译器底层将引用以指针实现出来，所以传引用实际传递的是指针</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">一般而言，可以合理假设值传递并不昂贵的唯一对象就是内置类型和STL迭代器和函数对象</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">21：必须返回对象时，别妄想返回引用，就让它返回一个新对象呗，编译器会实施最优化，某些情况下operator*返回值的构造和析构可被 安全的消除</span></div><div><span style="font-size: 12pt; font-family: 宋体;">22：将成员变量声明为private</span></div><div><span style="font-size: 12pt; font-family: 宋体;">23：以非成员，非友元替换成员函数，有时候非成员比成员函数更具封装性——没太理解在哪些情况下更具有封装性</span></div><div><span style="font-size: 12pt; font-family: 宋体;">26：尽可能延后变量定义式的出现时间：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">懒初始化，直到能给它初值实参为止；</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">尽量在构造的时候初始化而不是无意义的default构造然后赋值</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">如果是循环的话就要具体问题具体分析了</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">27：尽量少做转型动作</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">转型什么都没做，只是告诉编译器把某种类型视为另一种类型的观念是错误的，转型会有个偏移量在运行期被施行——编译器的特性，</span><span style="font-size: 12pt; color: rgb(255, 0, 255); font-family: 宋体; font-weight: bold;">待验证</span><span style="font-size: 12pt; font-family: 宋体;">和区分linux和windows平台下的不同</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">容易写出似是而非的代码</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 255); font-family: 宋体; font-weight: bold;">——待验证</span></span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">28：避免返回handles指向对象内部成分——<span style="font-size: 12pt; font-family: 宋体; color: rgb(209, 0, 255); font-weight: bold;">需要再复习</span></span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">避免返回handles（引用，指针，迭代器）指向对象内部</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">增加const修饰可以保证不修改它，但是还是存在handle比其所指对象更长寿的风险</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">29：为&quot;异常安全&quot;而努力</span></div><div><span style="font-size: 12pt; font-family: 宋体;">30：inline函数：对此函数的调用用函数本体替换</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">优点：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">免除函数调用的成本</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">编译器优化设置通常被设计用来浓缩不含函数调用的代码，所以inline函数编译器有可能对它执行语境相关最优化</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">缺点：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">用函数本体替换之，所以增加目标码的大小</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">inline只是对编译器的一个申请而不是强制命令，定义的</span><span style="font-size: 12pt; font-family: 宋体;">inline的函数是否是真的inline取决于编译器</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">可以隐式提出：</span><span style="font-size: 12pt; font-family: 宋体;">将函数定义于class定义式内，也可加</span><span style="font-size: 12pt; font-family: 宋体;">inlin显式指出</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">inline函数一定被置于头文件内，是编译期行为</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">编译器不会对通过函数指针调用实施inlining</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">inline无法随着程序库的升级而升级：一旦对inline函数f有修改，用到f的所有地方都要重新编译；但如果是non-inline函数只需重新链接即可，如果是动态链接都不用重新链接</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">综上：</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">将大多数inlining限制在小型，被频繁调用的函数身上，使得调试和二进制升级更容易，也可使潜在的代码膨胀问题最小化，</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">31：将文件之间的编译依存关系降至最低：用声明的依存性代替定义的依存性</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">如果使用class的references或pointers可以完成任務，就不要使用objects</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">如果能夠，尽量以class声明式代替class定义式</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">为声明式和定义式提供不同的头文件</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">32：确保public继承塑模出is-a的关系</span></div><div><span style="font-size: 12pt; font-family: 宋体;">33：避免遮掩继承而来的名称</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">继承类的作用域嵌套在基类的作用域内</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">名称遮掩规则：子类和父类之间，不存在重载的关系，就是说不管是不是虚函数，子类如果定义了同名的函数，就会遮掩父类的同名函数(对虚函数来说是继承，其实效果一样)，不管参数类型或返回值类型是否一样，存在以下几种情况：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">父类是虚函数（包含</span><span style="font-size: 12pt; font-family: 宋体;">重载的</span><span style="font-size: 12pt; font-family: 宋体;">虚函数），子类定义了其中任一个同名的虚函数(只要同名就行)，就会遮掩父类所有同名虚函数</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">父类是普通函数，子类定义同名普通函数，子类的普通函数会这样所有父类同名函数(不管参数，返回类型)</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">解决遮掩的办法：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">使用using声明式</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">使用转交函数</span></div></li></ul></ul><div><span style="font-size: 12pt; font-family: 宋体;">34：区分接口继承和实现继承：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">纯虚函数就是为了接口继承</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">非纯虚函数是为了让子类继承，并提供一份默认实现，但有可能存在一个问题：有的子类并不需要这个实现，但public让他继承下来了，所以按情况切断虚函数接口和默认实现之间的联系，比如说分开实现等</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">完全继承：父类的普通函数(public或protected访问符)</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">35：考虑virtual函数以外的其他选择：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;"><span style="font-size: 12pt; font-family: 宋体; font-weight: bold;">NVI</span>(non-virtual interface)手法（strategy模式特殊形式）:</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">虚函数应该是private的，以public的非虚成员函数调用私有虚函数，让子类重写private虚函数（</span><span style="font-size: 12pt; color: rgb(50, 135, 18); font-family: 宋体; font-weight: bold;">注意</span><span style="font-size: 12pt; font-family: 宋体;">：子类可以重写父类的的private虚函数）</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">可以在调用前后做一些事，如日志，锁等</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">由函数对象(包括</span><span style="font-size: 12pt; font-family: 宋体;">函数指针</span><span style="font-size: 12pt; font-family: 宋体;">)实现的strategy模式（用函数对象代替虚函数）</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">缺点：这种形式无法访问non-public，所以唯一能够解决“需要以non-member函数访问class的non-public成分的办法就是弱化class的封装”：</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">传统的</span><span style="font-size: 12pt; font-family: 宋体;">strategy模式:</span><span style="font-size: 12pt; font-family: 宋体;">由两个继承体系实现，代码实现见176</span><span style="font-size: 12pt; font-family: 宋体;"><img src="EffectiveC++_files/Image.png" type="image/png" data-filename="Image.png"/></span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">36：绝不重新定义继承而来的非虚函数：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">如果子类重新定义继承而来的non-virtual函数，不论是子类对象还是父类对象调用这个函数，父类或子类的该函数都可能会被调用到：决定因素不在对象自身，而在指向该对象的指针当初的声明类型（没有动态性了）</span></div></li></ul><div><span style="font-size: 16px; font-family: 宋体;">37：绝不重新定义继承而来的默认参数值</span></div><ul><li><div><span style="font-size: 16px; font-family: 宋体;">原因：虚函数是动态绑定，默认参数值是静态绑定</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">改进：使用</span><span style="font-size: 12pt; font-family: 宋体; font-weight: bold;">NVI</span><span style="font-size: 12pt; font-family: 宋体;">手法，用public non-virtual调用private virtual函数</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">38：通过复合塑模出has-a：在类中定义其他类型的变量</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">注意区分“is-a”和“has-a”，区别出这两种使用场景</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">39：谨慎使用private继承</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">特点：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">不是&quot;is-a&quot;的关系，编译器不会将private继承的子类转换成父类</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">private继承而来的所有父类成员在derived class中都会变成private属性</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">用途：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">private继承只是为了复用一些父类已经有的特性，父类和子类没有任何观念上的关联(诸如鸟和麻雀等的关系)</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">private继承意味着只有实现被继承，接口部分已经略去（</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: 宋体;">什么是接口部分？</span><span style="font-size: 12pt; font-family: 宋体;">）</span></div></li></ul></ul><div><span style="font-size: 12pt; font-family: 宋体;">40：谨慎使用多重继承</span></div><div><span style="font-size: 12pt; font-family: 宋体;">42：typename的双重意义：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">声明template的类型参数</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">如果声明嵌套从属类型（依赖于template模板参数的类型），需要在前面加关键字typename说明它是类型</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">这一规则的例外是：不可出现在base calsses list内的嵌套从属类型名称之前，也不可在成员初始化列表中作为base class修饰符</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">43：学习处理模板化基类内的名称：父类是模板类，子类的方法内调用父类成员，是不能直接调用的，编译器会报错；因为模板只有当具体化的时候才知道它是什么，有三种方式避免这种情况：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">通过</span><span style="font-size: 12pt; font-family: 宋体;">this-&gt;调用</span><span style="font-size: 12pt; font-family: 宋体;">base class函数</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-family: 宋体;">通过using声明式，重新声明一遍基类方法（带基类的作用域），这里的using并不是避免被遮盖，而是编译器不进入基类作用域查找，通过using让它去查找</span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-family: 宋体;">明白指出被调用的函数在哪个父类中</span></span></div></li></ul><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-family: 宋体;">44：通过成员函数模板接受所有兼容类型</span></span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">泛型构造函数，如shared_ptr中一个类型转为另一个类型，就用到了</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">如果不定义拷贝构造/赋值运算符，编译器会生成默认的；如果想控制拷贝的方方面面，必须同时声明泛化的和正常的copy</span></div></li></ul><div><span style="font-size: 12pt; font-family: 宋体;">47：使用traits_classes表现类型信息</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">针对迭代器的traits为iterator_traits</span></div></li></ul><div><br clear="none"/></div><div><span style="font-size: 11pt; font-family: 宋体;">MoreEffective：</span></div><div><span style="font-size: 11pt; font-family: 宋体;">01：指针与引用的区别：</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">不存在指向空值的引用意味着引用的效率比指针高，因为使用引用前不需要测试它的合法性，相反指针应该总被测试</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">引用在初始化时指定对象，不能改变</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">重载某个操作符时应该返回引用，如[],要能被赋值</span></div></li></ul><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-family: 宋体;">05：类型转换：两种函数允许编译器进行转换</span></span></div><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-family: 宋体;">单参数构造函数：只有一个参数即可调用构造函数，或是虽定义了多个参数，但第一个参数以后的所有参数都有默认；通过声明explicit关键字，编译器会拒绝为隐式类型转换调用单参数构造函数</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-family: 宋体;">隐式类型转换运算符：operator 关键字，不需要定义函数的返回类型，因为返回类型就是这个函数的名字——谨慎定义类型转换函数(more effective c++ 5),解决的方法是不使用关键字的等同的函数来替代转换运算符；隐式类型转换可能会出现的问题：effective c++ 15</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-family: 宋体;">越有经验的C++程序员越喜欢避开类型转换运算符</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-family: 宋体;">注意，在哪些情况下会调用隐式类型转换？？？</span></span></div></li></ul></ul><div><span style="font-size: 11pt; font-family: 宋体;">06：自增，自减操作符的前缀与后缀形式的区别</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">前缀和后缀都有一个参数，为做出区别，前缀没参数，后缀有一个参数</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">前缀形式返回一个引用，后缀返回const值类型：</span></div></li><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">因为一个好的准则是使该类的行为与int类型一致，而int类型不允许连续进行两次后缀加，++(i++)这种形式也是不允许的</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">两次后缀加减产生的结果与期望不一致，第二次后缀操作改变的是第一次返回对象的值，而不是原始值</span></div></li></ul></ul><div><span style="font-size: 11pt; font-family: 宋体;">07：不要重载&quot;&amp;&amp;&quot;, &quot;||&quot;, &quot;,&quot;</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">&quot;&amp;&amp;&quot;/&quot;||&quot;: C++使用短路求值法，一旦确定布尔表达式的真假，即使部分表达式没有被测试，仍然停止运算</span></div></li><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">所以说，如果重载了这两个就会改变游戏规则：用函数调用发代替了短路求值法</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">如果重载(operator&amp;&amp;(expr1, expr2)),不确定expr1和expr2哪个先调用，有可能与短路求值法完全相反</span></div></li></ul><li><div><span style="font-size: 11pt; font-family: 宋体;">逗号表达式：一个包含逗号的表达式先计算逗号左边的表达式，然后计算右边的，整个表达式的结果是逗号右边表达式的结果</span></div></li><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">如果重载，就不能保证左边的表达式先于右边的表达式计算</span></div></li></ul><li><div><span style="font-size: 11pt; font-family: 宋体;">不能重载的运算符：.; .*; ::; ?:; new; delete; sizeof; typeid</span></div></li></ul><div><span style="font-size: 11pt; font-family: 宋体;">22：宁以by-reference to const传递参数：值传递有可能导致对象被析构</span></div><div><span style="font-size: 11pt; font-family: 宋体;">25：虚构造：行为像构造函数，但视其输入，产生不同类型的对象；虚拷贝构造：返回一个指针，指向其调用者的一个新副本，基于此，虚拷贝构造以copyself或cloneself命名，虚拷贝构造就是真正的调用了拷贝构造而已；</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">怎样将非成员函数的行为虚化？本节给出了答案</span></div></li></ul><div><span style="font-size: 11pt; font-family: 宋体;">26：限制class产生的对象的数量</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">阻止初始化：</span></div></li><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">构造声明为private，然后通过友元函数创建对象，当然，友元函数中创建的对象的作用域应该是全局的，如static等</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">构造声明为private，不需要友元，通过类的静态成员函数返回类的静态对象</span></div></li></ul><li><div><span style="font-size: 11pt; font-family: 宋体;">阻止初始化：构造声明为private——C++11应该可以声明为=delete</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">只允许一个对象：static</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">成为一个function static而非calss static：</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">function static在函数第一次调用的时候会产生，而class static对象即使从来不用，也会构造和析构</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">function static确切知道初始化时机，而class static不一定在什么时候初始化。C++为同一编译单元的static的初始化顺序是保证的，但对不同单元的static初始化顺序没有任何说明</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">缺点：虽然符合对象的个数为1，但却限制了每次程序执行时只能有唯一一个对象</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">解决办法：对象计数和虚构造结合</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">有限个数的对象：static数据成员记录初始化个数，超出数量时抛出异常，缺点是：</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">缺点：</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">该类对象在三种状态下生存：他自己；派生物的base class成分；内嵌于较大对象之中。这些不同状态把追踪当前对象个数的意义搞混乱了，解决办法：构造声明为private，带有private的构造不能用作base class；且不能嵌套在其他对象中</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">终极解决方案：使用继承自对象引用计数类的带伪构造函数的类</span></div></li></ul><div><span style="font-size: 11pt; font-family: 宋体;">27:要求或禁止对象产生于heap之中：</span></div><div><span style="font-size: 11pt; font-family: 宋体;">    要求对象产生于heap中：</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">构造为public，析构为private，写一个伪构造供用户调用用来释放资源；但也妨碍了继承和内含——令析构为protected便可解决继承问题；必须是内含对象的做法可以改为内含一个指针，指向这个对象</span></div></li></ul><div><span style="font-size: 11pt; font-family: 宋体;">    禁止对象产生于heap中：</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">将operator new/delete声明为private</span></div></li></ul><div><span style="font-size: 11pt; font-family: 宋体;">28：智能指针：</span></div><ul><li><div><span style="font-size: 11pt; font-family: 宋体;">解引用操作：</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">operator*返回的是一个引用而不是对象，因为返回的指针不需要非得指向类型为T的对象，有可能是T的派生类对象！</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">operator-&gt;:返回值有点特殊，如pt-&gt;mem_func()会被编译器解释为<span style="font-size: 11pt; font-family: 宋体; color: rgb(255, 0, 0);">(pt.operator-&gt;())-&gt;mem_func() <span style="font-size: 11pt; font-family: 宋体; color: rgb(0, 0, 0);">(为什么会解释成这样？)</span></span></span></div></li><li><div><span style="font-size: 11pt; color: rgb(0, 0, 0); font-family: 宋体;">测试smart pointer是否为NULL：隐式转换为bool取代隐式转换为void*</span></div></li><li><div><span style="font-size: 11pt; color: rgb(0, 0, 0); font-family: 宋体;">智能指针转换为原始指针：提供一个隐式转换符：重载运算符T*，但这得以轻易地直接对原始指针做动作，回避了智能指针当初的设计目标；提供隐式转换会打开一个bug的门户，不要提供对dump pointers的隐式转换操作符</span></div></li><li><div><span style="font-size: 11pt; color: rgb(0, 0, 0); font-family: 宋体;">smart pointers和与继承有关的类型转换：将非虚成员函数声明为templates；最好的情况就是使用member templates来产生转换函数，，然后在模棱两可的时候使用转型动作</span></div></li><li><div><span style="font-size: 11pt; color: rgb(0, 0, 0); font-family: 宋体;">smart pointers与const</span></div></li></ul><div><span style="font-size: 11pt; color: rgb(0, 0, 0); font-family: 宋体;">29：引用计数</span></div><ul><li><div><span style="font-size: 11pt; color: rgb(0, 0, 0); font-family: 宋体;">写时才复制</span></div></li></ul><div><span style="font-size: 11pt;"><br/></span></div><div><span style="font-size: 11pt;">EffectiveSTL</span></div><div><span style="font-size: 11pt;">43：尽量用算法代替手写循环，有三个理由：</span></div><ul><li><div><span style="font-size: 11pt;">效率：算法通常比程序员产生的循环更高效</span></div></li><li><div><span style="font-size: 11pt;">正确性：写循环比调用算法更容易出错</span></div></li><li><div><span style="font-size: 11pt;">可维护性：算法通常更干净直观</span></div></li></ul><div><span style="font-size: 11pt;"><br clear="none"/></span></div><div><span style="font-size: 11pt; font-family: 宋体;">对void*变量不能直接通过在其前面加上*的方式取值，需要转成具体如int*类型；或void**也是可以的</span></div><div><span style="font-size: 11pt; font-family: 宋体;">void指针不能复引用 </span></div><div><span style="font-size: 11pt; font-family: 宋体;">   *vp//错误 </span></div><div><span style="font-size: 11pt; font-family: 宋体;">   因为void指针只知道,指向变量/对象的起始地址 </span></div><div><span style="font-size: 11pt; font-family: 宋体;">   而不知道指向变量/对象的大小(占几个字节)所以无法正确引用 </span></div><div><span style="font-size: 11pt; font-family: 宋体;">1. （more effective c++ 1）不存在指向空值的引用，意味着使用引用的效率比使用指针的要高，因为在使用引用前不需要测试他的合法性</span></div><div><span style="font-size: 11pt; font-family: 宋体;">指针与引用的另一个区别：指针可以被重新赋值以指向另一个不同的对象，引用则总是指向在初始化时被指定的对象，引用则总是指向在初始化时被指定的对象，以后不能改变；所以当必须指向一个对象且不改变其指向；或者重载操作符并防止不必要的语义误解时使用引用；其他情况下使用指针</span></div><div><span style="font-size: 11pt;"><br clear="none"/></span></div><div><span style="font-size: 11pt; font-family: 宋体;">运行时类型识别（RTTI）：</span></div><ol><li><div><span style="font-size: 11pt; font-family: 宋体;">typeid运算符，用于返回表达式的类型，形式为typeid(e)，e可以是任意表达式或类型的名字，操作的结果是一个常量对象的引用</span></div></li><li><div><span style="font-size: 11pt; font-family: 宋体;">dynamic_cast运算符：用于将基类的指针或引用安全的转换为派生类的指针或引用</span></div></li></ol><div><span style="font-size: 11pt; font-family: 宋体;">    注意：</span></div><div><span style="font-size: 11pt; font-family: 宋体;">    1.使用RTTI运算符蕴含着更多的风险</span></div><div><span style="font-size: 11pt;"><br clear="none"/></span></div><div><span style="font-size: 11pt;"><br/></span></div></div><div><br/></div></span>
</div></body></html> 