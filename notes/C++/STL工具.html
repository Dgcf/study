<html>
<head>
  <title>STL工具</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="920"/>
<h1>STL工具</h1>

<div>
<span><div><div><span style="font-family: Georgia;">一. pair: #include&lt;utility&gt;</span></div><div><span style="font-family: Georgia;">    操作函数：</span></div><ul><li><div><span style="font-family: Georgia;">构造和赋值：</span></div></li><ul><li><div><span style="font-family: Georgia;">pair&lt;T1, T2&gt; p: default构造函数，建立一个pair，元素类型分别为T1和T2，各自以其default构造函数初始化</span></div></li><li><div><span style="font-family: Georgia;">pair&lt;T1, T2&gt;p(val1, val2):建造一个pair，类型为T1和T2，以val1和val2为初值进行构造或移动构造</span></div></li><li><div><span style="font-family: Georgia;">pair&lt;T1, T2&gt; p(p2)：拷贝构造或移动构造</span></div></li><li><div><span style="font-family: Georgia;">p1=p2：拷贝或std::move</span></div></li></ul><li><div><span style="font-family: Georgia;">p.first/p.second：获得pair的第一个或第二个value</span></div></li><li><div><span style="font-family: Georgia;">p1.swap(p2) / swap(p1, p2)：互换p1和p2的数据</span></div></li><li><div><span style="font-family: Georgia;">p1==p2：等价于 (p1.first==p2.first &amp;&amp; p1.second==p2.second)</span></div></li><li><div><span style="font-family: Georgia;">make_pair(val1, val2)：返回一个pair，带有val1和val2的类型和数值</span></div></li><li><div><span style="font-family: Georgia;">get&lt;0&gt;(p) / get&lt;1&gt;(p)：全局函数，等价于p.first/p.second</span></div></li></ul><div><span style="font-family: Georgia;">    使用场合：</span></div><ul><li><div><span style="font-family: Georgia;">在很多stl中有用到，如map等</span></div></li><li><div><span style="font-family: Georgia;">如果需要返回两种类型，可以返回pair</span></div></li></ul><div><span style="font-family: Georgia;">二. 元组tuple</span></div><ul><li><div><span style="font-family: Georgia;">不是寻常的容器，不可以迭代</span></div></li><li><div><span style="font-family: Georgia;">元素类型可以是引用</span></div></li><li><div><span style="font-family: Georgia;">方法/函数：</span></div></li><ul><li><div><span style="font-family: Georgia;">构造：</span></div></li><ul><li><div><span style="font-family: Georgia;">tuple&lt;T1, T2, ...Tn&gt; t: 以n个给定类型建立一个tuple，以各元素类型的default构造函数完成初始化</span></div></li><li><div><span style="font-family: Georgia;">tuple&lt;T1,T2, ...&gt; t(v1, v2,...）</span></div></li><li><div><span style="font-family: Georgia;">tuple&lt;T1, T2&gt; t(p)：建立一个tuple，以给定的pair p初始化（类型必须吻合）</span></div></li></ul><li><div><span style="font-family: Georgia;">t = t2：赋值操作</span></div></li><li><div><span style="font-family: Georgia;">t = p：将pair p赋值给带两个元素的tuple，pair和tuple的类型必须吻合</span></div></li><li><div><span style="font-family: Georgia;">t1==t2/t1 != t2：如果所有元素相等返回true</span></div></li><li><div><span style="font-family: Georgia;">&lt;, &gt;, &lt;=, &gt;=：使用字典式比较——？</span></div></li><li><div><span style="font-family: Georgia;">t1.swap(t2)：互换t1和t2的数据——始自C++11</span></div></li><li><div><span style="font-family: Georgia;">全局函数swap(t1, t2)：同上，是个——始自C++11</span></div></li><li><div><span style="font-family: Georgia;">全局函数make_tuple：会根据value建立tuple，不需要明确指出元素的类型</span></div></li><li><div><span style="font-family: Georgia;">全局函数tie(ref1, ref2, ...)：建立一个由引用构成的tuple</span></div></li><li><div><span style="font-family: Georgia;">访问tuple的成员：</span></div></li><ul><li><div><span style="font-family: Georgia;">使用标准库函数模板：get&lt;n&gt;(t)访问tuple对象</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">其他tuple特性：</span></div></li><ul><li><div><span style="font-family: Georgia;">tuple_size&lt;tupletype&gt;::value：可获得元素个数</span></div></li><li><div><span style="font-family: Georgia;">tuple_elememt&lt;idx, tupletype&gt;::type：可获得idx个元素的类型</span></div></li><li><div><span style="font-family: Georgia;">tuple_cat()：可将多个tuple串接成一个tuple</span></div></li></ul></ul><div><span style="font-family: Georgia;">三. 辅助函数：</span></div><ul><li><div><span style="font-family: Georgia;">挑选最小值和最大值：#include&lt;algorithm&gt;</span></div></li></ul><div><span style="font-family: Georgia;"><img src="STL工具_files/Image.png" type="image/png" data-filename="Image.png" width="625"/></span></div><ul><li><div><span style="font-family: Georgia;">两值互换：swap，#include&lt;utility&gt;</span></div></li><ul><li><div><span style="font-family: Georgia;">只有参数定义了拷贝或移动语义，才可以调用成功</span></div></li><li><div><span style="font-family: Georgia;">指针数组版本提供重载版本：</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia">template&lt;typename T, size_t N&gt;</font></div><div><font face="Georgia">void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b));    // vs中的定义和这个不同</font></div></div><ul><li><div><span style="font-family: Georgia;">增补的比较操作：在std的rel_pos命名空间下，都是利用==和&lt;完成，#include&lt;utility&gt;</span></div></li><ul><li><div><span style="font-family: Georgia;">只需自己定义好&quot;&lt;&quot;和&quot;==&quot;，写上using namespace std::rel_pos，就可以使用”!=“,”&gt;“”&lt;=“”&gt;=&quot;</span></div></li></ul></ul><div><span style="font-family: Georgia;">四. 函数对象：</span></div><div><span style="font-family: Georgia;">    默认情况下函数对象是值传递而不是引用传递：——说明是可以执行拷贝的</span></div><ul><li><div><span style="font-family: Georgia;">好处是可以传递常量表达式或暂态表达式（在参数中之间传个值，如1）</span></div></li><li><div><span style="font-family: Georgia;">缺点就是无法改变function object的状态，</span><span style="font-family: Georgia;">有三个办法改变之：</span></div></li></ul><ol><ol><li><div><span style="font-family: Georgia;">在外部持有状态，并让function object指向它</span></div></li><li><div><span style="font-family: Georgia;">以by reference方式传递function object</span></div></li><li><div><span style="font-family: Georgia;">利用for_each()算法的返回值</span></div></li></ol></ol><div><span style="font-family: Georgia;">    概念：函数对象（仿函数）是定义了一个operator()的类</span></div><ul><li><div><span style="font-family: Georgia;">三大优点：</span></div></li><ul><li><div><span style="font-family: Georgia;">函数对象比一般函数更灵巧，因为它可以拥有状态</span></div></li><li><div><span style="font-family: Georgia;">有类型，可以作为template的参数，或容器的参数</span></div></li><ol><li><div><span style="font-family: Georgia;">可以作为排序准则</span></div></li></ol><li><div><span style="font-family: Georgia;">执行速度上，函数对象比函数指针更快</span></div></li></ul><li><div><span style="font-family: Georgia;">特点：</span></div></li><ul><li><div><span style="font-family: Georgia;">可以根据需要重载operator()()函数</span></div></li><li><div><span style="font-family: Georgia;">可以通过类名调用，也可通过实例名称调用</span></div></li></ul><li><div><span style="font-family: Georgia;">缺点：——</span><span style="color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">待补充</span></div></li><li><div><span style="font-family: Georgia;">判断式：返回bool的函数或函数对象</span></div></li></ul><div><span style="font-family: Georgia;">    预定义好的函数对象 #include&lt;functional&gt;：</span></div><div><span style="font-family: Georgia;"><img src="STL工具_files/Image [1].png" type="image/png" data-filename="Image.png" width="387"/></span></div><div><span style="font-family: Georgia;">    函数适配器：指能够将不同的函数对象结合起来的函数对象 #include&lt;functional&gt;</span></div><ul><li><div><span style="font-family: Georgia;">bind函数，, 一般形式为 auto newCallable = std::bind(callable, arg_list)</span></div></li><ul><li><div><span style="font-family: Georgia;">newCallable是一个可调用对象，<span style="font-family: Georgia; color: rgb(227, 0, 0);">类型为std::function&lt;&gt;</span></span></div></li><li><div><span style="font-family: Georgia;">callbale：如果是类成员要加取地址符，如std::bind(&amp;T::t, arg_list)；它还是执行的是callbale，只不过换个参数传递方式</span></div></li><li><div><span style="font-family: Georgia;">arg_list: 逗号分割的参数列表，按顺序作为callbale的参数；可包含形如_n的名字，n为整数，占位符，表示可调用对象中参数的位置，_1为newCallable的第一个参数</span></div></li><ul><li><div><span style="font-family: Georgia;">_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在命名空间std中，形如：using std::placeholders::_1</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">mem_fn(op)：调用op，把他当作某个object的成员函数</span></div></li><li><div><span style="font-family: Georgia;">not1(op)/not2(op)：已被视为过时，就不看了</span></div></li></ul><div><span style="font-family: Georgia;">    lambda表达式：匿名函数，形式为：[capture list](parameter list) mutable -&gt; return type { function body }</span></div><ul><li><div><span style="font-family: Georgia;">capture list: lambda所在函数中定义的局部变量的列表，只有在捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。但可以使用当前函数体之外的变量，通常为空；捕捉列表有如下形式：</span></div></li><ul><li><div><span style="font-family: Georgia;">[var]：表示值传递捕获边变量var</span></div></li><li><div><span style="font-family: Georgia;">[=]：表示值传递方式捕获所有父作用域的变量(包括this)</span></div></li><li><div><span style="font-family: Georgia;">[&amp;var]：表示引用传递捕捉变量var</span></div></li><li><div><span style="font-family: Georgia;">[&amp;]：表示引用传递捕捉所有父作用域的变量(包括指针)</span></div></li><li><div><span style="font-family: Georgia;">[this]：表示值传递捕捉当前的this指针</span></div></li><li><div><span style="font-family: Georgia;">[=, &amp;a, &amp;b]：以引用方法捕捉a和b，值传递方式捕捉其他所有变量</span></div></li></ul><li><div><span style="font-family: Georgia;">(parameter list)：参数列表，</span><span style="font-family: Georgia;">不能有默认参数</span></div></li><li><div><span style="font-family: Georgia;">mutable：lambda函数总是一个const函数，mutable可以取消其常量属性，在使用该修饰符时参数列表不可省略</span></div></li><li><div><span style="font-family: Georgia;">-&gt;return type：在返回类型明确的情况下可以省略；</span><span style="font-family: Georgia;">与普通函数不同的是，lambda必须使用尾置返回来指定返回类型,如果lambda函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void——<span style="font-family: Georgia; color: rgb(227, 0, 0);">这个是什么意思？</span></span></div></li><li><div><span style="font-family: Georgia;">可以忽略参数列表和返回类型，但必须包含捕获列表和函数体</span></div></li><li><div><span style="font-family: Georgia;">当定义一个lambda时，编译器生成一个与lambda对应的新的类类型，当向一个函数传递lambda时，同时定义了一个新类型和该类型的一个对象</span></div></li></ul><div><span style="font-family: Georgia;">    函数外覆器 std::function&lt;&gt;( #include&lt;functional&gt;)：允许把可调用对象(函数/函数对象/成员函数/lambda等)当作最高级对象</span></div><ul><ul><li><div><span style="font-family: Georgia;">使用成员函数时，借以调用它们的那个对象必须被当作第一实参：</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia">class C { public: void memfunc(int x, int y) const; };</font></div><div><font face="Georgia">std::function&lt;void(const C&amp;, int, int)&gt;mf = &amp;C::memfunc;    // 赋值给std::function对象</font></div><div><font face="Georgia">mf(C(), 42, 77);       // 调用</font></div></div><ul><ul><li><div><span style="font-family: Georgia;">异常：执行一个函数调用却没有 标的物 可调用，会抛出异常：std::bad_function_call</span></div></li><li><div><span style="font-family: Georgia;">std::ref()：将类型T转换成&amp;T</span></div></li><li><div><span style="font-family: Georgia;">std::cref()：将类型T转换成const T&amp;</span></div></li></ul><li><div><span style="font-family: Georgia;">哈希模板std::hash&lt;T&gt;：#include&lt;functional&gt;</span></div></li><ul><li><div><span style="font-family: Georgia;">定义了一个函数对象，实现了哈希函数，这个函数对象的实例定义了一个operator()</span></div></li><li><div><span style="font-family: Georgia;">接受一个参数的类型key，返回一个类型为size_t的值，表示参数的哈希值</span></div></li></ul></ul><div><span style="font-family: Georgia;">五. 运行时类型识别：</span></div><ul><li><div><span style="font-family: Georgia;">typeid：typeid(e)</span></div></li><ul><li><div><span style="font-family: Georgia;">e可以是任意类型或表达式</span></div></li><li><div><span style="font-family: Georgia;">操作结果是一个常量对象的引用，该对象类型是type_info或者type_info的公有派生类型</span></div></li><ul><li><div><span style="font-family: Georgia;">如果参数表达式是一个引用，返回所引用对象的类型</span></div></li><li><div><span style="font-family: Georgia;">如果参数是数组或函数，并不会执行向指针的标准类型转换，也就是说，对数组a执行typeid(a)所得结果是数组类型而非指针类型</span></div></li><li><div><span style="font-family: Georgia;">当运算对象。。。</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">type_info类：#include&lt;typeinfo&gt;：</span></div></li><ul><li><div><span style="font-family: Georgia;">一般是作为一个基类出现的，没有默认构造，拷贝，移动构造和赋值运算符都被定义成删除的，因此无法定义或拷贝type_info对象，创建type_info对象的唯一途径是使用typeid</span></div></li><li><div><span style="font-family: Georgia;">方法/属性：</span></div></li><ul><li><div><span style="font-family: Georgia;">t1==t2/t1 != t2</span></div></li><li><div><span style="font-family: Georgia;">t.name()：返回一个C风格字的类型名字符串（经验证，返回的不全是一个类型名称的字符串），</span><span style="font-family: Georgia; font-weight: bold;">不能保证</span><span style="font-family: Georgia;">获得的字符串就是这个class的名称</span></div></li><li><div><span style="font-family: Georgia;">hash_code()：返回该类型的唯一哈希值</span></div></li><li><div><span style="font-family: Georgia;">t1.before(t2)：返回一个bool值，表示t1是否位于t2之前，before所采取的顺序关系是依赖于编译器的；可以运用type_info::before()对type_info对象建立索引</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">decltype:</span></div></li><ul><li><div><span style="font-family: Georgia;">在编译时进行类型推导，可以将获得的类型定义另外一个变量；在C++11中比较典型的就是decltype于typedef/using的合用</span></div></li><li><div><span style="font-family: Georgia;">std::result_of：基于decltype的模板类，作用是推导函数的返回类型</span></div></li><li><div><span style="font-family: Georgia;">与auto推导不能带走cv限制符一样，decltype是能够带走表达式的cv限制符的；不过如果对象的定义中有const或volatile限制符，使用decltype推导其成员不会继承const或volatile限制符</span></div></li></ul></ul><div><div><span style="font-family: Georgia;">六.随机数及分布：#include&lt;random&gt;</span></div><ul><li><div><span style="font-family: Georgia;">引擎：是一个带有状态的随机性的源头，其状态决定了它将生成哪一个随机值序列（</span><span style="color: rgb(227, 0, 0); font-family: Georgia;">注意这并非随机数—有什么区别？</span><span style="font-family: Georgia;">）。是一个函数对象，能产生随机的无正负值，每次以operator()调用之，就可以产出一个随机的无正负号值，并且内部状态会改变，使得可以此后再产出一个新随机值。均匀分布在预定义的最大和最小值之间：default_random_engine</span></div></li><ul><li><div><span style="font-family: Georgia;">引擎的位置可能导致产生的随机数不变</span></div></li></ul><li><div><span style="font-family: Georgia;">分布：是把引擎产生的随机值转换为真实而有用的随机数。这些随机数由一个由使用者给定的参数所决定的区间内(包含两个区间值)。目前了解均匀分布：uniform_int_distribution和uniform_real_distribution就足够了，其他分布需要时再学习。</span></div></li><ul><li><div><span style="font-family: Georgia;">uniform_int_distribution:产生整数，类型为(short, int, long, long long及其相应的unsigned)，默认int，构造第一实参为最小值，第二实参为最大值，随机数包括这两个数。产生一个随机数的做法是，对分布调用operator(), 将引擎作为实参传入</span></div></li><li><div><span style="font-family: Georgia;">uniform_real_distribution：默认double，类型可以为float，double，long double</span></div></li></ul></ul><div><span style="font-family: Georgia;">注意：任何引擎的初始状态都有明确定义，并非随机，所以示例产生的随机数是一样的：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia">std::uniform_int_distribution&lt;int&gt; d;</font></div><div><font face="Georgia">std::default_random_engine dre1;</font></div><div><font face="Georgia">cout &lt;&lt; d(dre1) &lt;&lt; endl;</font></div><div><font face="Georgia">std::default_random_engine dre2;</font></div><div><font face="Georgia">cout &lt;&lt; d(dre1) &lt;&lt; endl;          </font></div><div>// 要避免这种情况，需要<font color="#8600A4">将引擎和分布定义成static的，暂时不知道原理</font></div></div><ul><li><div><span style="font-family: Georgia;">算法shuffle()：利用一个均匀随机数生成器如std::default_random_engine重排元素</span></div></li><ul><li><div><span style="font-family: Georgia;">可以但不应该传入一个临时引擎，原因是每次初始化一个引擎，其初始状态是相同的</span></div></li></ul></ul><div><br/></div><div><span style="font-family: Georgia;">七. 时间/日期相关：</span></div><ul><li><div><span style="font-family: Georgia;">两个概念：</span></div></li><ul><li><div><span style="font-family: Georgia;">duration（时间段）：如3minutes等</span></div></li><li><div><span style="font-family: Georgia;">timepoint（时间点）：从某个起始点开始计算的一个时间段，是一个duration和起始点的组合，如2000年，是1970年一月一日开始的第1262300400秒</span></div></li></ul><li><div><span style="font-family: Georgia;">duration：时间段</span></div></li></ul><div><span style="font-family: Georgia;"><img src="STL工具_files/Image [2].png" type="image/png" data-filename="Image.png" width="749"/></span></div><ul><li><div><span style="font-family: Georgia;">Clock：是个对象，定义时间点的起点和一个tick周期（就是计时单位，如秒），不同的clock有不同的起点。一般当处理两个时间点的差距时，必须提供相同的起点/clock。</span></div></li><ul><li><div><span style="font-family: Georgia;">标准库提供了三个clock：</span></div></li><ul><li><div><span style="font-family: Georgia;">system_clock:所提供的timepoint将关联至现行系统的即时时钟，这个clock提供便捷函数to_time_t()和from_time_t(),允许转换成C的系统时间类型time_t；精度为100ns</span></div></li><li><div><span style="font-family: Georgia;">steady_clock：它保证不会被调整；精度为ms</span></div></li><li><div><span style="font-family: Georgia;">high_resolution_clock：表现的是系统中带有最短tick周期的clock；精度为100ns</span></div></li></ul><li><div><span style="font-family: Georgia;">clock提供的类型定义和static成员：</span></div></li><ul><li><div><span style="font-family: Georgia;">clock::duration：获得clock的duration成员</span></div></li><li><div><span style="font-family: Georgia;">clock::rep：获得tick类型</span></div></li><li><div><span style="font-family: Georgia;">clock::period：获得单位类型的类型，等价于clock::duration::period</span></div></li><li><div><span style="font-family: Georgia;">clock::time_point：获得clock的timepoint类型</span></div></li><li><div><span style="font-family: Georgia;">clock::is_steady：如果clock是steady则为true</span></div></li><li><div><span style="font-family: Georgia;">clock::now：获得一个用来表现目前时间的time_point</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">Timepoint：表现出某个特定时间点，关联至某个clock的某个正值或负值duration</span></div></li></ul><div><span style="font-family: Georgia;">C和Posix中的时间相关函数#include&lt;ctime&gt;：注意，time_t通常只是始自unix起始点(1970.1.1)的秒数，但不能保证如此</span></div><div><span style="font-family: Georgia;"><img src="STL工具_files/Image [3].png" type="image/png" data-filename="Image.png" width="746"/></span></div></div><div><br/></div><div><span style="font-family: Georgia;">八. Bitset 造出来一个内含bit或Boolean值（</span><span style="color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">有这个类型吗</span><span style="font-family: Georgia;">）且大小固定的数组；传统是通过long来作为bit数组，再借由&amp;，|，~等操作符操作各个bit。bitset的邮件在于可容纳任意个数的bit（但不能动态改变个数），并提供各项操作；不可以改变bitset的bit个数，如果需要一个可变长度的bit容器，可以考虑使用vector&lt;bool&gt;：#include&lt;bitset&gt;；template参数指定可容纳bit的数量</span></div><div><br/></div><div>九. 数值的极值</div><div>模板numeric_limits，头文件 #include&lt;limits&gt;，成员有以下：</div><ul><li><div>is_specialized：类型是否有极值</div></li><li><div>is_signed：类型是否带有正负号</div></li><li><div>is_integer：整数类型</div></li><li><div>min()：最小的极值</div></li><li><div>max()：最大的极值</div></li><li><div>。。。</div></li></ul><div><span style="font-family: Georgia;">十：C++中其他功能归纳</span></div><ol><li><div><span style="font-family: Georgia;"><span style="font-family: Georgia;">std::addressof：#include&lt;memory&gt;，取地址，和取地址一元运算符&amp;有什么区别？如果重载&amp;，一元运算符会调用到重载函数中，取不到this的地址，这个模板函数可以拿到真实地址，示例参考C++标准库文档</span></span></div></li><li><div><span style="font-family: Georgia;"><br/></span></div></li></ol><div><span style="font-family: Georgia;">五：</span></div><div><span style="font-family: Georgia;">标准库函数：begin和end，C++11引入，为了让指针的使用更简单，更安全</span></div><div><span style="font-family: Georgia;">int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};</span></div><div><span style="font-family: Georgia;">int* beg = begin(a);     // 指向ia首元素的地址</span></div><div><span style="font-family: Georgia;">int* last = end(a);         // 指向ia尾元素下一位的指针</span></div><div><br clear="none"/></div></div><div><br/></div></span>
</div></body></html> 