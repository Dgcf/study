<html>
<head>
  <title>关联容器</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="689"/>
<h1>关联容器</h1>

<div>
<span><div><div><font face="Georgia" style="font-size: 12pt;"><span style="font-size: 12pt; font-family: Georgia; font-weight: bold;">总说：</span></font></div><div><span style="font-size: 10pt; font-family: Georgia;">8个关联容器体现在三个维度上：</span></div><ol><li><div><span style="font-size: 10pt; font-family: Georgia;">或者是map，或者是set；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">或者要求不重复的关键字，或者允许重复，允许重复的前加multi</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">顺序或无序保存，无序的前加unordered</span></div></li></ol><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-family: Georgia; font-weight: bold;">set</span></font><span style="font-size: 11pt; font-family: Georgia;">：#include&lt;set&gt;——<span style="font-size: 11pt; font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">主要应用场合？</span></span></div><div><span style="font-size: 10pt; font-family: Georgia;">特点：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">set和multiset通常以平衡二叉树完成（实际以红黑树完成），multiset允许元素重复而set不允许重复</span></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">自动排序</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">优点：令二叉树于查找元素时拥有良好效能，其查找函数具有对数复杂度</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">(</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">怎样算出来的？</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">)</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">缺点：造成set和multiset的一个重要限制，不能直接改变元素值，因为这样会打乱原本正确的顺序，因此要改变元素值必须先删除旧元素，再插入新元素，以下接口反映了这种情况：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">set和multiset不提供任何操作函数可以直接访问元素</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">通过迭代器进行元素间接访问，有一个限制：从迭代器的角度看，元素值是常量</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">——？</span></font></div></li></ul></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">set有以下形式：</span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-family: Georgia;"><img src="关联容器_files/Image.png" type="image/png" data-filename="Image.png" width="744"/></span></span></div><div><span style="font-size: 10pt; font-family: Georgia;">操作函数：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">创建/复制/销毁：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">两种方式定义排序准则：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">以template参数定义之</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">以构造函数参数定义之</span></div></li></ul></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">非更易性操作：</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.key_comp()：返回比较准则——</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia;">返回一个函数对象？</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.value_comp():返回针对value的比较准则</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.empty()：返回是否容器为空</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.size()：返回当前元素个数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.max_size():返回元素个数之最大可能量——？返回了一个很大的数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">比较操作：==, !=, &lt;, &gt;, &lt;=, &gt;=</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: unset; font-family: Georgia;">特殊查找函数：set和multiset再元素快速查找方面有优化设计，所以应优先采取以下而非stl算法，因为以下是</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">对数复杂度</span><span style="font-size: 10pt; color: unset; font-family: Georgia;">，而stl算法是线性复杂度：</span></font></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c.count(val)：返回元素值为val的元素个数；对于set来说元素是不重复的，所有最大为1</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.find(val):返回元素值为val的第一个元素的迭代器，如果找不到就返回end()</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.lower_bound(val):返回val的第一个可安插位置，也就是元素值&gt;=val的第一个元素位置——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">未验证</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.upper_bound(val):</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.equal_range(val)</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">赋值：</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c = c2/</span><span style="font-size: 10pt; font-family: Georgia;">c = rv/</span><span style="font-size: 10pt; font-family: Georgia;">c = initlist</span><span style="font-size: 10pt; font-family: Georgia;">：将c2的全部元素赋值给c/</span><span style="font-size: 10pt; font-family: Georgia;">将右值rv的所有元素以移动的方式给c/</span><span style="font-size: 10pt; font-family: Georgia;">将初值列initlist的所有元素赋值给c</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c1.swap(c2)/swap(c1,c2):置换c1和c2的数据</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">迭代器操作：双向迭代器，不支持随机访问的stl算法；更重要的是从迭代器的角度看，所有元素都被视为常量，这可确保元素不会被改动以至于打乱既有顺序(</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">什么意思？</span><span style="font-size: 10pt; font-family: Georgia;">)</span></font></div></li><ul><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">元素的添加与删除：</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.insert(val)：安插一个val，返回一个pair，第一个元素是新元素迭代器，第二个是bool值表示是否插入成功，如果不成功返回的pair的second是false。——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">以下未验证</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.insert(pos, val):安插一个val拷贝，返回新元素位置</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.insert(begin, end):将区间[begin,end)内所有元素的拷贝安插到c</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.insert(initlist)：安插初始值列表initlist内的所有元素的一份拷贝</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.emplace(args...)：安插一个以args为初值的元素，并返回新元素的位置</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(val)：删除与val相等的所有元素，返回被移除的元素的个数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(pos)：移除iterator位置pos上的元素，无返回值</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(beg,end)：移除[beg, end)上的所有元素</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.clear():移除所有元素，将容器清空</span></div></li></ul></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">用以安插元素的函数：insert()和emplace()，返回类型不尽相同set返回以pair组织起来的两个值：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">pair结构中的second成员表示安插是否成功</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">pair结构中的first成员表示新元素的位置，或现存的同值元素的位置</span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">  运行期指定排序准则：</span></div><div><span style="font-size: 11pt;"><br/></span></div><div><span style="font-size: 12pt; font-family: Georgia; font-weight: bold;">map</span><span style="font-size: 11pt; font-family: Georgia;">：</span><span style="font-size: 11pt; color: unset; font-family: Georgia;">#include&lt;map&gt;</span></div><div><span style="font-size: 10pt; font-family: Georgia;">特点：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">map和multimap：元素类型是pair(key/value组成)，可根据key的排序准则自动为元素排序，multimap不允许元素重复，map允许元素重复。</span></div></li><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">map/multimap通常是以平衡二叉树完成，但C++标准并未规定</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: unset; font-family: Georgia;">map和multimap会根据元素的key自动对元素排序，</span><span style="font-size: 10pt; font-family: Georgia;">默认以less做比较，</span><span style="font-size: 10pt; color: unset; font-family: Georgia;">所以根据已知的key查找某个元素时有很好的效率，而根据已知value查找元素时效率就很差；自动排序这一性质使得map和multimap有一条重要限制：不可以直接改变元素的key，因为这会破坏正确次序。要修改元素的key，必须先移除该key的元素，然后插入新的key/value；</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">从迭代器的观点看，元素的key是常量</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">key和value必须满足：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">key和value必须是可复制或可移动的</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">对指定的排序准则而言，key必须是可比较的</span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">map可为以下形式：</span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-family: Georgia;"><img src="关联容器_files/Image [1].png" type="image/png" data-filename="Image.png" width="852"/></span></span></div><div><span style="font-size: 10pt; font-family: Georgia;">操作函数：</span></div><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">创建/复制/销毁：</span><span style="font-size: 10pt; font-family: Georgia;">    </span></font></div></li><ul><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">两种方式定义排序准则：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">以template实参定义之</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">以构造函数参数定义之</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">类型别名：</span></div></li><ul><li><div><span style="font-family: Georgia;">key_type：关键字类型</span></div></li><li><div><span style="font-family: Georgia;">mapped_type：每个关键字关联的类型，只适用于map</span></div></li><li><div><span style="font-family: Georgia;">value_type：对于set，与key_type相同；多于map，为pair&lt;const key_type, mapped_type&gt;</span></div></li></ul><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">非更易性操作：</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.key_comp():返回比较准则——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">返回的是一个函数对象？</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.value_comp():返回针对value的比较准则——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">同问</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.empty():返回是否容器为空</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.size():返回目前的元素个数</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.max_size()：返回元素个数之最大可能量——</span><span style="font-size: 10pt; color: rgb(65, 173, 28); font-family: Georgia;">一个很大的数</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">比较操作：==/!=/&lt;/&gt;/&lt;=/&gt;=：</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">比较的是什么？</span></font></div></li></ul><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">特殊查找：和set一样，推荐使用以下而非stl算法</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c.count(val)：返回key为val的元素个数——map返回最多一个吧</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.find(val):返回第一个key为val的第一个元素的迭代器，找不到就返回end()；不能以find查找拥有某个特定value的元素，必须使用stl算法find_if或自实现</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.lower_bound(val)——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">未验证</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.upper_bound(val)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.equal_range(val)</span></div></li></ul><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">赋值：</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c=c2/</span><span style="font-size: 10pt; font-family: Georgia;">c=rv/</span><span style="font-size: 10pt; font-family: Georgia;">c=initlist</span><span style="font-size: 10pt; font-family: Georgia;">:将c2的全部元素赋值给c/将右值rv的所有元素以移动的方式给予c/将初始值initlist的所有元素给c</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c1.swap(c2)/</span><span style="font-size: 10pt; font-family: Georgia;">swap(c1, c2):置换c1和c2的数据</span></font></div></li></ul><li><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">插入删除操作：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c.insert(val):安插一个val的拷贝，返回pair，第一个元素为插入元素的迭代器，第二个为bool值表示是否插入成功</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.insert(pos,val)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.insert(beg,end)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.insert(initlist)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.emplace(args...)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.emplace_hint(pos, args...)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(val)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(pos)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(beg,end)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.clear()</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia" style="font-size: 10pt;">// 有三种不同的方式通过insert将value传入map或multimap内 </font></div><div><font face="Georgia" style="font-size: 10pt;">std::map&lt;int, string&gt; map;</font></div><div><font face="Georgia" style="font-size: 10pt;">// 运用value_type:</font></div><div><font face="Georgia" style="font-size: 10pt;">map.insert(std::map&lt;int, string&gt;::value_type(2, &quot;hello&quot;));</font></div><div><font face="Georgia" style="font-size: 10pt;">// 运用pair&lt;&gt;:</font></div><div><font face="Georgia" style="font-size: 10pt;">map.insert(std::pair&lt;int, string&gt;(5, &quot;good&quot;));</font></div><div><font face="Georgia" style="font-size: 10pt;">// 运用make_pair()</font></div><div><font face="Georgia" style="font-size: 10pt;">map.insert(std::make_pair&lt;int, string&gt;(8, &quot;make&quot;));</font></div></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">另外map提供operator[]和at()，作为便捷的元素安插和设定操作</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">at操作如果不存在这样的元素会抛出out_of_range异常，否则返回一个引用指向带着key的元素</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">operator[]:如果存在key，会返回元素的引用——？；如果不存在则会自动安插一个新元素，返回</span></div></li></ul></ul><div><span style="font-size: 11pt;"><br/></span></div><div><span style="font-size: 11pt; font-family: Georgia; font-weight: bold;">无序容器</span><span style="font-size: 11pt; font-family: Georgia;">：</span><span style="font-size: 10pt; font-family: Georgia;">都是以<b>哈希表</b>为基础实现，#include&lt;unordered_set&gt;/#include&lt;unordered_map&gt;</span></div><div><span style="font-size: 10pt; font-family: Georgia;">  unordered容器的几乎所有操作-包括拷贝构造和赋值，元素的安插和寻找，以及等价比较的预期行为都是取决于哈希函数的质量</span></div><div><span style="font-size: 10pt; font-family: Georgia;">  unordered_map：只要满足两个条件：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">key和value都必须可被复制或可被移动</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">key必须可被等价准则拿来比较</span></div></li></ul><div><span style="font-size: 10pt; font-family: Georgia;">和其他容器比较后的缺点：</span></div><ol><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">不提供operator&lt;, operator&gt;,&lt;=,&gt;=,然而提供了==，!=（</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">原因？</span><span style="font-size: 10pt; font-family: Georgia;">）</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">不提供lower_bound和upper_bound</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">由于迭代器只保证至少是个前向迭代器，因此反向迭代器包括rbegin(), rend(), crbegin(), crend()都不提供</span></div></li></ol><div><span style="font-size: 10pt; font-family: Georgia;">操作：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">创建和控制unordered容器</span></div></li></ul><div><span style="font-size: 10pt; font-family: Georgia;"><img src="关联容器_files/Image [2].png" type="image/png" data-filename="Image.png" width="541"/></span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">布局操作：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c.hash_function()：返回hash函数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.key_eq()：返回&quot;相等性判断式&quot;</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.bucket_count()：返回当前的bucket个数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.max_bucket_count()：返回bucket最大可能数量</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.load_factor()：返回当前的负载数</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">c.max_laod_factor()/</span><span style="font-size: 10pt; font-family: Georgia;">c.max_laod_factor(val)</span><span style="font-size: 10pt; font-family: Georgia;">：返回当前的最大负载系数/设定当前最大负载系数为val</span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.rehash(bnum)：将容器rehash，使其bucket个数至少为bnum</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.reserve(num)：将容器reshah，使其空间至少拥有num个元素</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">非更易性操作：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c.empty()：容器是否为空</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.size()：返回目前的元素个数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.max_size()：返回元素个数之最大可能</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c1 == c2/c1 != c2：判断c1是否等于/不等于c2。unorder容器只提供==和!=，</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">在最坏的情况下有可能提供二次复杂度?</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">特殊的查找操作：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c.count(val)：返回元素值为val的元素个数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.find(val):返回元素值为val的第一个元素，如果找不到就返回val</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.equal_range(val):返回val可被安插的第一个位置和最后一个位置，也就是元素值==val的元素区间</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">赋值操作：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c=c2/c=rv/c=initlist：将c2的值给c/将右值rv的值转移给c/将初始值initlist的所有元素给c</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c1.swap(c2)/swap(c1,c2)：置换c1和c2的数据</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">安插和删除元素：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">insert(val)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">insert(pos, val)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">...</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(val)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(pos)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.erase(begin, end)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.clear()</span></div></li></ul><li><div><span style="font-family: Georgia;">下标操作：</span></div></li><ul><li><div><span style="font-family: Georgia;">c[key]：如果不存在，安插一个带key的元素；如果存在，返回一个引用指向key对应的值</span></div></li><li><div><span style="font-family: Georgia;">c.at(key)：返回key值的引用；如果元素不存在抛出out_of_range异常</span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">bucket接口：可通过一个特定的bucket接口访问个别bucket，用以暴露整个hash表的内部状态</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">c.bucket_count()</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.bucket(val)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.bucket_size(buckidx)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">c.begin()/c.end()/c.cbegin()/c.cend()</span></div></li></ul><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">哈希：</span></div><div><span style="font-size: 10pt;">1.哈希函数的好坏取决于其避免冲突发生的能力</span></div><div><span style="font-size: 10pt; font-family: Georgia;">疑问/注意点：</span></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">1.</span><span style="font-size: 10pt; font-family: Georgia;">set中的元素是const，map中元素是pair，其第一个成员是const的？</span></font></div><div><span style="font-size: 10pt; font-family: Georgia;">通常不对关联容器使用泛型算法；</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">key_type：容器类型的关键字类型</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">mapped_type：每个关键字关联的类型，只适用于map</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">value_type：对于set，与key_type相同；对于map，为pair&lt;</span><span style="font-size: 10pt; font-family: Georgia; font-style: italic; font-weight: bold;">const</span> <span style="font-size: 10pt; font-family: Georgia;">key_type,mapped_type&gt; （不能改变一个元素的关键字，因此这些pair的关键字部分是const的）</span></div></li></ul><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">问题</span><span style="font-size: 10pt; font-family: Georgia;">：</span></font></div><ol><li><div><span style="font-size: 10pt; font-family: Georgia;">字典必须通过关键字查询其元素？map只能通过迭代的方式访问其元素</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">为何map和set的插入删除效率比其他序列容器高？因为不需要内存拷贝和内存移动</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">为何map和set每次Insert之后，以前保存的iterator不会失效？因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">当数据元素增多时（从10000到20000），map的set的查找速度会怎样变化？RB-TREE用二分查找法，时间复杂度为logn，所以从10000增到20000时，查找次数从log10000=14次到log20000=15次，多了1次而已。</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">map是怎么实现的？查找的复杂度是多少？能不能边遍历边插入？红黑树和散列</span></div></li></ol><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">源码剖析：关联容器没有所谓的头尾，只有最大元素和最小元素，所以不会有push_back，begin()之类的操作</span><span style="font-size: 10pt; color: unset; font-family: Georgia;">一般情况下关联容器内部结构是一个平衡二叉树，最广泛使用的是红黑树</span></font></div></div><div><br/></div></span>
</div></body></html> 