<html>
<head>
  <title>基础总结</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="708"/>
<h1>基础总结</h1>

<div>
<span><div><div><span style="font-family: Georgia;">一.预编译/预定义/编译相关指令：</span></div><ul><li><div><span style="font-family: Georgia;">_Pragma：</span><span style="font-family: Georgia;">#pragma是一条预处理指令，用来向编译器传达语言标准以外的信息，</span><span style="font-family: Georgia;">_Pragma是</span><span style="font-family: Georgia;">与#pragma功能一样的操作符：格式如下：_Pragma (字符串字面常量)，如_Pragma(&quot;once&quot;),相比</span><span style="font-family: Georgia;">#pragma</span><span style="font-family: Georgia;">，由于</span><span style="font-family: Georgia; font-weight: bold;">_Pragma是一个操作符</span><span style="font-family: Georgia;">，因此可以用在一些宏中，而#pragma则不能在宏中展开——</span><span style="color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">待验证，</span></div></li><li><div><span style="color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">预处理的指令还有哪些？</span></div></li><ul><li><div><span style="font-family: Georgia;">#pragma once：只编译一次</span></div></li><li><div><span style="font-family: Georgia;">#pragma pack()：用来指定结构体对齐，括号中指定对其字节数：参考：</span> <a href="https://www.jianshu.com/p/90a6eef329ec" style="font-family: Georgia;">https://www.jianshu.com/p/90a6eef329ec</a></div></li><ul><li><div><span style="font-family: Georgia;">#pragma pack(show)：显示当前内存对齐的字节数，vs不会打印出来，但会在编译阶段给出一个警告，说明当前对齐字节数</span></div></li><li><div><span style="font-family: Georgia;">#</span><span style="font-size: 10pt; font-family: Georgia;">pragma pack(push [, identifier] [, n])：</span><span style="font-family: Georgia;">将当前对齐字节数压入栈顶，并设置n为新的对齐字节数；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">#pragma pack(pop [, identifier] [, n])：</span> <span style="box-sizing: border-box; font-size: 12px; border: none; vertical-align: middle; white-space: pre-wrap; background-color: rgb(242, 242, 242); letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(199, 37, 78); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">#pragma pack(pop)</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">会弹出栈顶对齐字节数，并设置默认对齐字节</span></span></div></li></ul><li><div><span style="font-family: Georgia;">#pragma message：用于自定义编译信息输出到终端，一般和#if配合使用，用在控制版本号；在vs下编译时需要用()将message括起来</span></div></li><li><div><span style="font-family: Georgia;">#pragma warning：警告设置，只对当前文件有效</span></div></li><ul><li><div><span style="font-family: Georgia;">#pragma warning(push)：存储当前报警设置</span></div></li><li><div><span style="font-family: Georgia;">#pragma warning(push, n)：存储当前报警设置，并设置报警级别为n，n为从1到4的自然数</span></div></li><li><div><span style="font-family: Georgia;">#pragma warning(pop)：恢复之前压入堆栈的报警设置，<span style="font-family: Georgia; color: rgb(79, 0, 154);">在一对push和pop之间的任何设置都将在后面失效</span></span></div></li><li><div><span style="font-family: Georgia;">#pragma warning(disable: n)：将某个报警设置为失效——<span style="font-family: Georgia; color: rgb(255, 0, 0); font-weight: bold;">n有哪些？</span></span></div></li><li><div><span style="font-family: Georgia;">#pragma warning(default: n)：将报警设置为默认</span></div></li></ul><li><div><span style="font-family: Georgia;">vs中的代码收缩：</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#pragma region Region_1</div><div>void Test() {}</div><div>#pragma endregion Region_1</div></div><ul><li><div><span style="font-family: Georgia;">变长参数的宏定义以及__VA_ARGS__：</span><span style="font-family: Georgia;">C99中可以使用变长参数的宏定义。变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏__VA_ARGS__则可以在宏定义的实现部分替换省略号所代表的字符串；除了在宏定义中用来展开参数而外还有其他用途吗</span></div></li><li><div><span style="font-family: Georgia;">可变长参数函数：#include&lt;stdarg.h&gt; (#include&lt;cstdarg&gt;)</span></div></li><ul><li><div><span style="font-family: Georgia;">宏：</span></div></li><ul><li><div><span style="font-family: Georgia;">va_list</span></div></li><li><div><span style="font-family: Georgia;">va_start</span></div></li><li><div><span style="font-family: Georgia;">va_arg</span></div></li><li><div><span style="font-family: Georgia;">va_end</span></div></li></ul><li><div><span style="font-family: Georgia;">实现原理：得益于C语言默认的cdecl调用惯例的自右向左压栈传递方式；cdecl调用惯例保证了参数的正确清除，有些调用惯例是由被调用方负责清除堆栈的参数，但被调用方不知道有多少参数被传递进来，所以没办法清除，cdecl是调用方负责清除堆栈，因此没有这个问题</span></div></li><li><div><span style="font-family: Georgia;">变长参数函数：函数原型里的...符号前一般都需要一个先导参数，用于标识可变参数的起始位置，并且一般都是用来标识参数个数时使用的</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define PR(...) printf(__VA_ARGS__)    // 给PR传个参数就能打印出来了</div></div><ul><li><div><span style="font-family: Georgia;">宏__cplusplus:在C++11标准中的值与之前不同，可以通过该值判断是否支持C++11：</span></div></li><ul><li><div><span style="font-family: Georgia;">C++03标准中，__cplusplus值为199711L</span></div></li><li><div><span style="font-family: Georgia;">C++11标准中，__cplusplus值为201103L</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Georgia;">#if __cplusplus&gt;=201103L</span></div><div><span style="font-family: Georgia;">...</span></div><div><span style="font-family: Georgia;">#endif</span></div></div><ul><li><div><span style="font-family: Georgia;">断言：</span></div></li><ul><li><div><span style="font-family: Georgia;">预处理指令：#error “...”,当预处理器遇到该指令时</span><span style="font-family: Georgia;">停止编译</span><span style="font-family: Georgia;">并将后面的自定义错误消息输出，通过和预处理指令#if配合，在预处理阶段进行断言。</span></div></li><li><div><span style="font-family: Georgia;">运行时断言</span><span style="font-family: Georgia;">assert(expression)：expression为false触发；如果要禁用assert宏,</span><span style="font-family: Georgia;">在包含头文件之前#define NDEBUG。会极大影响性能。 （头文件：</span><span style="font-family: Georgia;">#include&lt;cassert&gt;或</span><span style="font-family: Georgia;">#include</span><span style="font-family: Georgia;">&lt;assert.h&gt;）</span></div></li><li><div><span style="font-family: Georgia;">编译期断言</span><span style="font-family: Georgia;">static_assert：</span><span style="font-family: Georgia;">语法：static_assert(</span><span style="font-family: Georgia;">断言表达式</span><span style="font-family: Georgia;">，字符串提</span><span style="font-family: Georgia;">警告信息</span><span style="font-family: Georgia;">)，</span><span style="font-family: Georgia;">通常需要返回一个bool值</span></div></li><ul><li><div><span style="font-family: Georgia;">static_assert断言表达式的结果必须是在编译时期可以计算的表达式，即常量表达式</span></div></li><ul><li><div><span style="font-family: Georgia;">编译期断言的一个简单实现:</span></div></li></ul></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define STATIC_CHECK(expr) { char unnamed[(expr) ? 1: 0]; }</div></div><ul><ul><ul><ul><li><div><span style="font-family: Georgia;">上面这个解法无法表达正确的错误信息，</span><span style="font-family: Georgia;">一个较好的解法是依赖一个名称带有意义的template，如下：</span></div></li></ul></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>template&lt;bool&gt; struct CompileTimeError;</div><div>template&lt;&gt; struct CompileTimeError&lt;true&gt; {};</div><div>#define STATIC_CHECK(expr) (CompileTimeError&lt;(expr) != 0&gt;())</div></div><ul><ul><ul><li><div><span style="font-family: Georgia;">可以说，assert，#error，static_assert三者分工明确，都是在不同时期的断言，根据需要而定；不过感觉大部分情况下可以用static_assert代替#error</span></div></li><li><div><span style="font-family: Georgia;">可以用在模板中在模板具现化时判断类别信息等</span></div></li></ul></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">标准中预定义宏（编译期）：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">__LINE__：当前源代码行号；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">__FILE__：当前源文件名，字符串；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">__DATE__：当前 </span><span style="font-size: 10pt; color: rgb(79, 0, 154); font-family: Georgia; font-style: italic;">编译日期</span><span style="font-size: 10pt; font-family: Georgia;">，格式(内容)为月 日 年</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">__TIME__：当前 </span><span style="font-size: 10pt; color: rgb(79, 0, 154); font-family: Georgia; font-style: italic;">编译时间</span><span style="font-size: 10pt; font-family: Georgia;">，格式为hh:mm:ss；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">__cplusplus：当编写C++程序时该标识符被定义，可以用来区别c++11(&gt;201103L)。</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">__func__：当前所在函数名；</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">原理是，按照标准定义，编译器会隐式地在函数的定义之后定义__func__标识符</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">C++11标准允许在类或者结构体中使用；但不允许将__func__作为默认函数值，因为__func__还未被定义</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// 例1：编译器隐式定义</span></div><div>void hello() </div><div>{    </div><div>    static const char *__func__ = &quot;hello&quot;;</div><div>    // ...</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// 例2：在自定义类型中使用</span></div><div>struct TestStruct</div><div>{</div><div>       TestStruct() : name(__func__) {}</div><div>       const char* name;</div><div>};</div></div><ul><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">__STC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；——</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">暂时不知道有什么用</span></div></li></ul><li><div><span style="font-size: 10pt; color: rgb(1, 1, 1); font-family: Georgia;">#和##：这两个都是处理变量名而不是变量值</span></div></li><ul><li><div><span style="font-size: 10pt; color: rgb(1, 1, 1); font-family: Georgia;">#：将宏定义中的变量名转化为字符串，具体为把#后的形参转化成一个字符串</span><span style="font-size: 10pt; color: rgb(1, 1, 1); font-family: Georgia;">，注意不是值</span><span style="font-size: 10pt; color: rgb(1, 1, 1); font-family: Georgia;">，只能修饰带参数的宏的形参</span></div></li><li><div><span style="font-size: 10pt; color: rgb(1, 1, 1); font-family: Georgia;">##:变量名称的字符串连接，注意不是值的连接，但拼接完之后不是字符串，是一个名称</span></div></li></ul></ul><div><br/></div><div><span style="font-family: Georgia;">二. POD类型：平凡的和标准布局的</span><span style="font-family: Georgia;">——</span><span style="color: rgb(227, 0, 0); font-family: Georgia;">貌似和深度探索C++对象模型中关于按位拷贝冲突</span></div><ul><li><div><span style="font-family: Georgia;">平凡的定义：符合以下四点定义：是不是可以总结为：构造，析构，拷贝/移动构造/赋值运算符 都是自动生成，不包含虚函数/虚基类</span></div></li><ul><li><div><span style="font-family: Georgia;">有平凡的构造和析构：即构造和析构什么都不干，而一旦定义了构造或析构，即使不含参数，实现为空，也不再平凡，需定义成default；一般默认生成即可</span></div></li><li><div><span style="font-family: Georgia;">平凡的拷贝构造和移动构造：平凡的拷贝构造等同于使用memcpy进行类型的构造；默认生成或显式定义成default</span></div></li><li><div><span style="font-family: Georgia;">平凡的拷贝赋值运算符和移动赋值运算符，这基本上同平凡的拷贝构造和平凡的移动构造类似</span></div></li><li><div><span style="font-family: Georgia;">不能包含虚函数和虚基类</span></div></li></ul><li><div><span style="font-family: Georgia;">标准布局：</span></div></li><ul><li><div><span style="font-family: Georgia;">所有非静态成员都有相同的访问权限</span></div></li><li><div><span style="font-family: Georgia;">类或结构体继承时，满足以下两种情况之一：就是非静态成员不能同时出现在基类和派生类中</span></div></li><ul><li><div><span style="font-family: Georgia;">派生类中有非静态成员，且只有一个仅包含静态成员的基类</span></div></li><li><div><span style="font-family: Georgia;">基类有非静态成员，而派生类没有非静态成员</span></div></li></ul><li><div><span style="font-family: Georgia;">类中第一个非静态成员的类型与其基类不同</span></div></li><li><div><span style="font-family: Georgia;">没有虚函数和虚基类</span></div></li><li><div><span style="font-family: Georgia;">所有非静态数据成员均符合标准布局类型，其基类也符合标准布局</span></div></li></ul><li><div><span style="font-family: Georgia;">pod类型相关的类模板工具 #include&lt;type_traits&gt;：</span></div></li><ul><li><div><span style="font-family: Georgia;">template&lt;typename T&gt;struct std::is_trivial的成员value可以用于判断T类型是否是一个POD类型；除了类和结构体之外，is_trivial可以对内置的标量类型数据及数组类型进行判断</span></div></li><li><div><span style="font-family: Georgia;">template&lt;typename T&gt;struct std::is_standard_layout的value可以判断类型是否是一个标准布局的类型</span></div></li><li><div><span style="font-family: Georgia;">template&lt;typename T&gt;std::is_pod&lt;T&gt;::value可以判断一个类型是否是POD，T可以是基本类型</span></div></li></ul><li><div><span style="font-family: Georgia;">使用POD类型有什么好处：</span></div></li><ul><li><div><span style="font-family: Georgia;">提供对C内存布局兼容，C++程序和C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的</span></div></li><li><div><span style="font-family: Georgia;">字节赋值：可以安全的使用memset和memcpy对POD类型进行初始化和拷贝等操作</span></div></li><li><div><span style="font-family: Georgia;">保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更简单—(比如放入目标文件的bss段，在初始化中直接赋值为0)。</span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">三. 左值和右值：</span></div><ul><li><div><span style="color: rgb(51, 51, 51); font-family: Georgia;">左值：可以取地址，有名字的就是左值，反之就是右值（更简单的，=左边的就是左值，右边的就是右值），</span><span style="font-size: 10pt; color: rgb(79, 0, 154); font-family: Georgia;">调用一个返回引用的函数得到的是左值，其他返回类型得到右值，特别的，可以为返回类型是非常量引用的函数的结果赋值</span></div></li><li><div><span style="font-family: Georgia;">C++11中的右值分为纯右值和将亡值</span></div></li><ul><li><div><span style="font-family: Georgia;">纯右值：之前的右值概念</span></div></li><li><div><span style="font-family: Georgia;">将亡值：C++11中新增的跟右值引用相关的表达式，如返回右值引用T&amp;&amp;的函数返回值，</span><span style="font-family: Georgia;">或者转换为T&amp;&amp;的类型转换函数的返回值，</span><span style="font-family: Georgia;">std::move的返回值</span></div></li></ul><li><div><span style="font-family: Georgia;">右值引用：对一个右值进行引用的类型；右值引用也必须立即初始化；右值引用是为了支持移动操作而引入的</span></div></li><ul><li><div><span style="font-family: Georgia;">一般右值不具有名字，</span><span style="font-family: Georgia;">通常情况下只能从右值表达式获取其引用，如T&amp;&amp; t = ReturnRValue()；函数返回的右值在表达式语句结束后生命就结束了，通过右值引用的声明，该右值又重获新生，其声明周期和右值引用类型变量t的生命周期一样，不过需要注意，能够声明右值引用t的前提是ReturnRvalue返回的是一个右值</span></div></li><li><div><span style="font-family: Georgia;">左值引用和右值引用都是都必须立即初始化，左值引用是具名变量值的引用，右值引用是不具名变量值的引用</span></div></li><li><div><span style="font-family: Georgia;">右值引用不能绑定到任何左值，只能绑定到一个将要销毁的对象</span></div></li><li><div><span style="font-family: Georgia;">左值引用是否可以绑定到右值？</span></div></li><li><div><span style="font-family: Georgia;">右值引用的来由从来就跟移动语义紧密相关，这是右值存在的最大价值之一</span></div></li><li><div><span style="font-family: Georgia;">为什么不使用常量右值引用？一，右值引用主要是为了移动语义，而移动语义需要右值是可以被修改的；二，如果要引用右值且不可以更改，常量左值就足够了</span></div></li></ul><li><div><span style="font-family: Georgia;">判断是否是引用类型/左值引用/右值引用：#include&lt;type_traits&gt;，通过类模板的成员value获取</span></div></li><ul><li><div><span style="font-family: Georgia;">is_rvalue_reference</span></div></li><li><div><span style="font-family: Georgia;">is_lvalue_reference</span></div></li><li><div><span style="font-family: Georgia;">is_reference</span></div></li></ul></ul><div><br/></div><div><span style="font-size: 10pt; font-family: Georgia;">四. 静态全局变量(static)</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">static修饰的全局变量的声明与定义同时进行，即当你在头文件中使用static声明了全局变量，同时它也被定义了，</span><span style="font-size: 10pt; font-family: Georgia;">如果没有明确的值会赋值为0(NULL, &quot;&quot;)，不像其他变量不明确</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">static变量只会被初始化一次，下次进来的时候不会重新执行，以此特性可以使用单例模式</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">static修饰的全局变量的作用域只能是本身的编译单元。在其他编译单元使用它时，只是简单的把其值复制给了其他编译单元，其他编译单元会另外开个内存保存它，在其他编译单元对它的修改并不影响本身在定义时的值。即在其他编译单元A使用它时，它所在的物理地址，和其他编译单元B使用它时，它所在的物理地址不一样，A和B对它所做的修改都不能传递给对方。这也是</span><span style="font-size: 10pt; color: rgb(79, 0, 154); font-family: Georgia;">不能用extern修饰static变量</span><span style="font-size: 10pt; font-family: Georgia;">的原因，</span><span style="font-size: 10pt; font-family: Georgia;">extern修饰全局变量和函数，在其他文件中是通用的；这也是</span><span style="font-size: 10pt; font-family: Georgia;">多个地方引用静态全局变量所在的头文件不会出现重定义错误的原因，因为在每个编译单元都对它开辟了额外的空间进行存储。</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">C++中，全局static变量和class的static成员在main之前先初始化，main之后销毁</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">函数内的static变量在什么时候执行初始化？</span></div></li><ol><li><div><span style="font-size: 10pt; font-family: Georgia;">如果初始值是一个编译期常量，在函数的任何一行执行之前就已经初始化了</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果初始值不是一个编译期常量，或者静态变量是一个拥有构造函数的对象，在执行期初始化，也就是函数第一次调用时初始化</span></div></li></ol><li><div>static成员变量：</div></li><ul><li><div>类外定义static成员时不能重复static变量，该关键字只出现在类内部的声明中</div></li><li><div>不能在类内部初始化静态成员，相反必须在类的外部定义和初始化每个静态成员</div></li><li><div>类似于全局变量，静态数据成员定义于任何函数之外，因此一旦被定义，就存在于程序的整个生命周期</div></li><li><div>类外定义时需要指定对象的类型，类名，作用域运算符及成员自己的名字</div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">五. 类型转换</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">知识点：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">任何一个转型动作往往令编译器编译出运行期间执行代码</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">——<span style="font-size: 10pt; font-family: Georgia; font-weight: bold; color: rgb(227, 0, 0);">？？</span></span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">显示转型可能发生拷贝</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">——<span style="font-size: 10pt; font-family: Georgia; font-weight: bold; color: rgb(227, 0, 0);">？？</span></span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">显示转换会不会抛出异常——<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">待验证</span></span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">转换符：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">static_cast：强迫隐式转换，不包含底层const的任何具有明确定义的类型转换。——<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0);">底层const也可以转啊，比如boost::simple_segregated_storage中的nextof</span></span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">适用场合：编译器隐式执行的任何类型转换都可以由static_cast来完成</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">需要把一个较大的算术类型赋值给较小的类型</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">对于编译器无法自动执行的类型转换如：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">子类(指针)转成基类(指针)但不做运行时的检查，不如dynamic_cast安全。static_cast仅靠类型转换语句中提供的信息来进行转换，而dynamic_cast则会遍历整个类继承体系进行类型检查,因此dynamic_cast在执行效率要差一些。</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">void*转成具体结构，</span><span style="font-size: 10pt; font-family: Georgia;">不同指针类型之间的转换使用static_cast&lt;void*&gt;作为桥梁</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">int转成对应的枚举</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">将non-const转成const等，但不能将const转成non-const——<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0);">不需要吧，non-const可以直接给const</span></span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">针对右值引用的特许转换规则：虽然不能隐式的将一个左值转换为右值引用，但可以用static_cast显式地将一个左值转换为一个右值引用，也就是std::move的功能吧：static_cast&lt;T&amp;&amp;&gt;(t)</span></div></li></ul></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">const_cast：只能改变底层const；因为不能把一个const对象赋给非const对象，通过该函数可进行转换：去const属性；</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">适用场合：——<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">待验证</span></span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">const_cast常常用于有函数重载的上下文中</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">去const属性</span></div></li></ul></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia" style="font-size: 10pt;">const char *pc;</font></div><div><font face="Georgia" style="font-size: 10pt;">char *p = const_cast&lt;char*&gt;(pc);     //正确但通过p写值是未定义的行为</font></div></div><ul><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释？执行低级转型，实际动作取决于编译器，这也表示他是不可移植的,转换结构几乎都是在执行期定义</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">适用场合：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">从语法上看，这个操作符仅用于指针类型的转换（返回值是指针）。它用来将一个类型指针转换为另一个类型指针，它只需在编译时重新解释指针的类型。这个操作符基本不考虑转换类型之间是否是相关的。</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">注意</span>：在gcc上大转小不被允许，需要加编译参数：-fpermissive</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia" style="font-size: 10pt;">int *ip;</font></div><div><font face="Georgia" style="font-size: 10pt;">char *pc = reinterpret_cast&lt;char *&gt;(ip);</font></div><div><font face="Georgia" style="font-size: 10pt;">//这个转换虽然不会有任何错误或警告信息，但必须牢记：pc所指的真实对象是一个int而非字符，把pc当成普通字符指针使用就可能在运行时发生错误</font></div><div><font face="Georgia" style="font-size: 10pt;">string str(pc);     //导致异常</font></div></div><ul><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">dynamic_cast：支持运行时类型识别，主要被用于安全地沿着类的继承关系向下进行类型转换，将一个基类转换成派生类</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">语法：A=dynamic_cast&lt;typeA&gt;(B) （typeA通常含有虚函数）</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">该运算符把B转换成typeA类型的对象。TypeA必须是类的指针、类的引用或者void *——只能针对指针或引用进行强转；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">dynamic_cast的转换</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia; font-weight: bold;">是在运行时进行的（指向派生类的基类指针可以转成派生类类型，但静态的基类转派生类是不会成功的，同样适用于引用）</span><span style="font-size: 10pt; font-family: Georgia;">，它的一个好处是会在运行是做类型检查，如果对象的类型不是期望的类型，它会在指针转换的时候返回NULL，在引用转换的时候抛出一个</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">std::bad_cast</span><span style="font-size: 10pt; font-family: Georgia;">异常。所以有两个步骤：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">第一，判断是不是某个类型；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">第二，是的话就把指针强转成要的类型，不是就返回NULL或抛出异常；</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">dynamic_cast一般只在继承类对象的指针之间或引用之间进行类型转换。如果没有继承关系，则被转化的类具有虚函数对象的指针进行转换，</span><span style="font-size: 10pt; font-family: Georgia;">不能被用于缺乏虚函数的类型上（more effective c++ 2）——<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">待验证？</span></span></div></li></ul></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">备注：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">尽量避免类型转换，特别是dynamic_cast，有两种方法代替：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">使用容器并直接在其中存储指向derived class的指针</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">使用虚函数代替</span></div></li></ul></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">六. const与constexpr</span></div><div><span style="font-size: 10pt; font-family: Georgia;">    const：</span><span style="font-family: Georgia;">编译期和运行时常量，两者没有区分</span></div><ul><li><div><span style="font-family: Georgia;">const变量：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">const对象必须初始化，而且是在声明的时候初始化，不能分开，不然会报错。</span><span style="font-size: 10pt; font-family: Georgia;">其对象一旦创建后就不能再改变，在const类型的对象上只能执行不改变其内容的操作</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">声明时加extern，再定义（定义时可加可不加），这时候包含声明const头文件的</span><span style="font-size: 13.3333px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">多个文件共享同一个const对象</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果声明时不加extern直接定义，包含了const变量头文件的编译单元会开辟新的内存存放该变量，类似static变量，不会报链接时重定义，但地址不同</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">初始化对const的引用：允许为一个常量引用绑定非常量的对象，</span><span style="font-size: 10pt; font-family: Georgia; text-decoration: underline;">字面值（右值）</span><span style="font-size: 10pt; font-family: Georgia;">，甚至一般表达式，但数据类型是要一致的；常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是常量未做限定，所以允许通过其他途径改变它的值；（常量左值引用是万能的）</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 10pt; font-family: Georgia;">const int &amp;r = 42;     //正确；常量值（右值）作为实参传递给const T&amp;也是允许的</span></div></div><ul><ul><li><div><span style="font-family: Georgia;">如果用一个对象去初始化另一个对象，则它们是不是const都无关紧要</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int i = 42;</div><div>const int v = i;    // 可以用非const变量初始化const变量</div><div>int j = v;          // 可以用const变量初始化非const变量，但<font color="#FF0000">注意如果变量是指针类型则不允许（常量指针还是指向常量的指针？）</font></div></div><ul><ul><li><div><span style="font-family: Georgia;">默认状态下const对象仅在文件内有效</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">初始化指向常量的指针：同初始化对const的引用，允许一个指向常量的指针指向一个非常量对象；指向常量的指针要求不能通过该指针改变对象的值，但没有规定那个对象的值不能通过其他方式改变；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">不能用指向非常量的指针或引用指向一个常量对象，但</span><span style="color: rgb(227, 0, 0); font-family: Georgia;">可以用非指针或引用的const变量初始化一个非const变量</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">顶层const（常量指针）：const作用于对象本身，本身是一个常量；——*const；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">低层const（指针常量）：所指的对象是一个常量；</span><span style="font-size: 10pt; font-family: Georgia;">声明引用的const都是低层const</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">执行拷贝操作时，顶层const不受什么影响，拷入和拷出的对象是否是常量都没什么影响；——<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0);">什么意思</span></span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">底层const：拷入和拷出的对象必须具有相同的底层const资格，或者，两个对象的数据类型必须能够转换，一般是非常量可以转换成常量<span style="font-size: 10pt; font-family: Georgia; color: rgb(255, 0, 0);">——？</span></span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">const成员函数：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">默认情况下，this指针是类类型非常量版本的常量指针（如class A，默认this类型是A *const；加上const后的类型为为const A *const），这一情况使得</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">不能在一个常量对象上调用普通的成员函数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">在设计类的时候，一个原则就是对于不改变数据成员的成员函数在后面加 const；</span><span style="font-size: 10pt; font-family: Georgia;">不允许修改类的数据成员，但可以修改成员指针变量指向的数据；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">在类外定义时要加上const，</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia;">在类中声明方法时可以不带const，在类外定义时可以带const——boost库中</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia;">simple_segregated_storage::</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia;">segregate就是这样的，感觉很奇怪</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">const对象能调用const成员函数但不能调用非const成员函数，非const对象是可以调用const成员函数的</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">const成员函数可以被具有相同形参列表的非const成员函数重载，在这种情况下，类对象的常量属性决定了调用哪个方法——<span style="font-size: 10pt; font-family: Georgia;">已验证</span></span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">    </span>constexpr：</span><span style="font-size: 10pt; font-family: Georgia;">编译期常量——<span style="font-size: 10pt; font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">待验证</span></span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">常量表达式：值不会改变且在编译时就能得到结果的表达式</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">一个对象是不是常量表达式由它的数据类型和初始值共同决定，数据类型是constexpr，初始值必须是常量</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">用常量表达式初始化的const对象也是常量表达式</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">声明constexpr类型的变量一定是一个常量且必须用常量表达式初始化</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">常量表达式的类型要求：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">字面值类型：算术类型，引用，指针；string/IO/自定义等不是</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">指针和引用的初始值受到严格限制：指针必须是nullptr或0，或存储于某个固定地址中的对象</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">函数体内定义的变量并非存放在固定的地址中，因此不能指向这样的这样的变量；定义在所有函数体外的所有变量地址固定不变，可以用来初始化</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">定义有效范围超出函数本身的变量，这类变量也有固定地址，可以用来初始化，如static变量？</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">constexpr定义的指针把定义的对象设置为了顶层const（仅对指针有效，对指针指向的对象无关）</span></div></li><li><div><span style="font-family: Georgia;">constexpr修饰变量：const int i=1；和constexpr int j=1；两者在大多数情况下没有区别，但如果i在全局变量中编译期会为i产生数据，对于j，如果没有显式使用编译期不会为其产生数据</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia" style="font-size: 10pt;">const int *p = nullptr;        // p是一个指向整型常量的指针</font></div><div><font face="Georgia" style="font-size: 10pt;">constexpr int *q = nullptr;    // q是一个指向整数的常量指针</font></div></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">constexpr函数：被隐式的指定为内联函数，</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">函数的返回类型及所有形参都是字面值类型，且函数体中有且只有一条return语句(</span><span style="font-family: Georgia;">必须返回值</span><span style="font-size: 10pt; font-family: Georgia;">)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">函数体中也可以包含其他语句，只要这些语句在运行时不执行任何操作就行（不执行任何操作有什么用？）</span><span style="font-family: Georgia;">如static_assert/using/typedef 等</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">允许constexpr的返回值并非一个常量；所以constexpr函数不一定返回常量表达式</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">constexpr构造函数：声明了constexpr的构造函数的类就是字面值常量类了（</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">不知道有啥用</span><span style="font-size: 10pt; font-family: Georgia;">）。除了声明为=default或者=delete之外，constexpr构造函数的函数体一般为空，使用初始化列表或其他constexpr构造函数初始化成员</span></div></li></ul><li><div><span style="font-family: Georgia;">为什么要用constexpr？存在的意义</span></div></li></ul><div><span style="font-size: 10pt; font-family: Georgia;">七. 数据对齐</span></div><ul><li><div><span style="font-family: Georgia;">总说：</span></div></li><ul><li><div><span style="font-family: Georgia;">对齐方式：表示的是一个类型的对象存放的内存地址应满足的条件</span></div></li><li><div><span style="font-family: Georgia;">好处：对齐的数据在读写上有性能优势</span></div></li><li><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(26, 26, 26); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">对于不对齐的结构体，编译器会自动补齐以提高CPU的寻址效率</span></div></li></ul><li><div><span style="font-family: Georgia;">数据对齐：(四个函数/描述符)</span></div></li><ul><li><div><span style="font-family: Georgia;">offsetof(X, x)：X为结构体名（也可为对象名），x为结构体成员，返回x在X中的偏移(以0开始)——</span><span style="color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">带虚函数的类计算不了偏移？</span></div></li><li><div><span style="font-family: Georgia;">alignof(X)：查询X的对齐字节，由最大元素类型（，基础类型，如果有嵌套结构体，取该结构体中的最大基础类型比较）的字节数决定；</span><span style="color: rgb(227, 0, 0); font-family: Georgia;">数组的对齐值</span><span style="font-family: Georgia;">由其元素决定；如alignof(char)就是1</span></div></li><ul><li><div><span style="font-family: Georgia;">参数X：</span><span style="font-family: Georgia;">自定义类型或内置类型或者变量，不完整类型编译不过</span></div></li><li><div><span style="font-family: Georgia;">返回std::size_t类型值</span></div></li><li><div><span style="font-family: Georgia;">__alignof是Microsoft的运算符</span></div></li><li><div><span style="font-family: Georgia;">引用与其引用的数据b对齐值相同</span></div></li></ul><li><div><span style="font-family: Georgia;">对齐描述符alignas：重新设定结构体的对齐方式；既可以接收常量表达式，也可以接受类型作为参数；</span></div></li><ul><li><div><span style="font-family: Georgia;">使用常量表达式作为alignas的操作符时结果必须是以2的幂次作为对齐值，设定的对齐值如果小于默认对齐则会忽视</span></div></li><li><div><span style="font-family: Georgia;">C++11标准中规定了一个“基本对齐值”，一般情况下等于平台支持的最大标量数据类型的对齐值，可以通过alignof(std::max_align_t)来查询其值 (#include&lt;cstddef&gt;)</span></div></li><li><div><span style="font-family: Georgia;">在C++11之前，使用编译器的扩展来描述对齐方式，如gnu的__attribute__((__aligned__(8)))</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>使用示例：</div><div>alignas(x) char c //指定c的对齐是x</div><div>struct alignas(x) XX  { A xx; }    // 指定结构体对齐字节为x</div></div><ul><ul><li><div><span style="font-family: Georgia;">C++11对于对齐的支持不限于alignof操作符和alignas描述符，STL中的内建函数</span><span style="font-family: Georgia; font-weight: bold;">std::align</span><span style="font-family: Georgia;">函数来动态指定的对齐方式调整数据块的位置（</span><span style="color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;">待验证</span><span style="font-family: Georgia;">）</span></div></li></ul><li><div><span style="font-family: Georgia;">通过属性（属性是对语言中的实体对象如函数变量等附加的一些额外注解信息，用来实现功能或代码优化）：</span></div></li><ul><li><div><span style="font-family: Georgia;">linux：</span><span style="font-family: Georgia;">通过GNU的关键字__attribute__来声明：</span><span style="font-family: Georgia;">__attribute__((attribute-list))，详细参考gcc在线文档：</span> <a href="https://gcc.gnu.org/onlinedocs/" style="font-family: Georgia;">https://gcc.gnu.org/onlinedocs/</a></div></li><li><div><span style="font-family: Georgia;">windows：__declspec，如控制变量的对齐方式：__declspec(align(x))</span></div></li><li><div><span style="font-family: Georgia;">C++11的通用属性：[[ attribute_list]]</span></div></li><ul><li><div><span style="font-family: Georgia;">语法上，通用属性可以作用于类型，变量，名称，代码块等。对于作用于声明的通用属性，既可以写在声明的起始处，也可写在声明的标识符之后；对作用于整个语句的通用属性，应该写在语句起始处</span></div></li><li><div><span style="font-family: Georgia;">现有C++11标准中只预定义了两个通用属性：</span></div></li><ul><li><div><span style="font-family: Georgia;">[[noreturn]]：用于标识不会返回的函数(不会返回的函数和返回void不同，不会返回的函数在被调用完成后后续代码不会再被执行)，主要用于标识那些不会将控制流返回给原调用函数的函数，如终止应用程序的函数，异常抛出函数等，好处有利于编译器进行优化，但要谨慎使用——<span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">待验证</span></span></div></li><li><div><span style="font-family: Georgia;">[[carries_dependency]]：和并行情况下的编译期优化有关，主要是用来解决弱内存模型平台上使用memory_order_consume内存顺序枚举问题</span></div></li></ul></ul></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">结构体对齐原则：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">结构体成员变量是基本类型：结构体中的第一个成员位置在偏移量0，之后每个变量的偏移量必须是它本身字节数的整数倍；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果结构体中嵌套结构体，那么嵌套结构体成员的偏移量必须是它最大成员的字节数的整数倍。注意：1.不是按结构体整体的大小偏移；2.不是展开后偏移，整个结构体的偏移量是包括嵌套结构体在内的最大成员的字节数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果是继承关系，目测和嵌套结构体一样</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;-en-paragraph:true;">结构体的总大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的整数倍，</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia;">这样在处理数组时可以保证每一项都边界对齐。</span><span style="font-size: 10pt; font-family: Georgia;-en-paragraph:true;">，在最后还会根据需要自动填充空缺的字节</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;-en-paragraph:true;">强制对齐：编译器提供了</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia;-en-paragraph:true;">#pragma pack(n)</span><span style="font-size: 10pt; font-family: Georgia;-en-paragraph:true;">来设定变量以n字节对齐方式：</span></font></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">结构的总大小也有个约束条件，分下面两种情况：如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。</span></div></li><li><div><span style="font-family: Georgia;"><span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">注意</span>：这个预编译命令会不论大小都会改变对齐值，alignas只会改大不会改小</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt; font-family: Georgia;">#pragma pack(push)         //保存对齐状态</font></div><div><font style="font-size: 10pt; font-family: Georgia;">#pragma pack(4)                //设定为4字节对齐,n=1,2,4,8,16改变系统的对齐系数</font></div><div><font face="Georgia" style="font-size: 10pt;">struct test</font></div><div><font face="Georgia" style="font-size: 10pt;">{</font></div><div><font face="Georgia" style="font-size: 10pt;">char m1;</font></div><div><font face="Georgia" style="font-size: 10pt;">double m4;</font></div><div><font face="Georgia" style="font-size: 10pt;">int m3;</font></div><div><font face="Georgia" style="font-size: 10pt;">};</font></div><div><font face="Georgia" style="font-size: 10pt;">#pragma pack(pop)            //恢复对齐状态</font></div><div><font color="#E30000" face="Georgia" style="font-size: 10pt;">在linux下测试好像一直都有效；</font></div><div><font color="#E30000" face="Georgia" style="font-size: 10pt;">单独使用#pragma pack(x)在vs下测试会使后面定义的结构体都按x对齐；</font></div></div><div><font face="Georgia" style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt; font-family: Georgia;">八. </span><span style="font-family: Georgia;">C++11特性：</span></div><ul><li><div><span style="font-family: Georgia;">连续两个右尖括号&gt;中间空格隔开，C++98会优先解析为右移，C++11会优先解析为模板参数界定符</span></div></li><li><div><span style="font-family: Georgia;">auto类型推导：auto声明变量的类型必须由编译器在编译时期推导而得；auto声明的变量必须被初始化；优势是可以匹配返回类型，因为有时候不确定返回类型，就会声明错误</span></div></li><li><div><span style="font-family: Georgia;">for_each/范围for循环——待验证</span></div></li><li><div><span style="font-family: Georgia;">C++11中新增long long类型（其实在之前就支持了），标准要求long long类型可以在不同的平台上有不同的长度，但至少64位</span></div></li><li><div><span style="font-family: Georgia;">就地初始化：只能使用&quot;=&quot;或&quot;{}&quot;进行初始化；作用先于列表初始化；</span><span style="font-family: Georgia;">如果既有列表初始化又有就地初始化，最终值取决于列表初始化</span></div></li><li><div><span style="font-family: Georgia;">非静态成员的sizeof：在C++98中对非静态成员变量使用sizeof是不能通过编译的，需要对象的实例才能对其成员进行sizeof操作；C++11可以——<span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">有什么用?</span></span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct People{ int hand; static People *all; }</div><div>People p;</div><div>cout &lt;&lt; sizeof(p.hand) &lt;&lt; endl;         // 都支持</div><div>cout &lt;&lt; sizeof(People::all) &lt;&lt; endl;    // 都支持</div><div>cout &lt;&lt; sizeof(People::hand) &lt;&lt; endl;   // C++11才支持</div></div><ul><li><div><span style="font-family: Georgia;">C++11新增关键字：</span></div></li><ul><li><div><span style="font-family: Georgia;">final：</span></div></li><ul><li><div><span style="font-family: Georgia;">禁止继承：将类标记为final，方法是直接在类名后使用关键字final，这样继承该类将导致编译出错</span></div></li><li><div><span style="font-family: Georgia;">禁止重写：在成员函数的参数列表后使用final关键字，使派生类不可覆盖它所修饰的虚函数(防止重载和重写)</span></div></li></ul><li><div><span style="font-family: Georgia;">新增虚函数描述符override：如果派生类在虚函数声明时使用了override,该函数必须重写其基类中的同名函数</span></div></li><ul><li><div><span style="color: rgb(255, 0, 0); font-family: Georgia;">声明和定义在一起的时候不能使用？</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">initialize_list:——<span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">待验证</span></span></div></li><ul><li><div><span style="font-family: Georgia;">标准库中容器对初始化列表的支持源自 #include&lt;initializer_list&gt;这个头文件中initialize_list类模板的支持</span></div></li><li><div><span style="font-family: Georgia;">自定义类型使用列表初始化需要包含该头文件，并且声明一个initialize_list模板类为参数的构造函数</span></div></li><li><div><span style="font-family: Georgia;">函数的参数列表也可以使用初始化列表，即以initializer_list作为模板参数</span></div></li><li><div><span style="font-family: Georgia;">初始化列表可以用于函数返回的情况。返回一个初始化列表通常会导致构造一个临时变量，当然列表初始化构造成什么类型依据返回类型</span></div></li><li><div><span style="font-family: Georgia;">使用初始化列表的一大优势防止类型收窄——类型收窄一般是一些使得数据变化或者精度丢失的隐式类型转换</span></div></li></ul><li><div><span style="font-family: Georgia;">提高类型安全——<span style="font-family: Georgia; color: rgb(227, 0, 0); font-weight: bold;">待验证</span></span></div></li><ul><li><div><span style="font-family: Georgia;">强类型枚举，在enum后加上关键字class，具有以下优势：</span></div></li><ul><li><div><span style="font-family: Georgia;">强作用域：强类型枚举成员的名称不会被输出到其父作用域空间</span></div></li><li><div><span style="font-family: Georgia;">转换限制：不可与整型隐式的相互转换</span></div></li><li><div><span style="font-family: Georgia;">可以指定顶层类型：具体方法是在枚举名称后面加上“:type”，如 enum class Type: char { ... }</span></div></li><li><div><span style="font-family: Georgia;">匿名的enum class可能什么都做不了</span></div></li></ul><li><div><span style="font-family: Georgia;">nullptr: 是一个“指针空值类型”的常量，指针空值类型被命名为 nullptr_t,所以可以通过nullptr_t来声明一个指针空值类型的变量（使用nullptr_t的头文件 #include&lt;cstddef&gt;）</span></div></li><ul><li><div><span style="font-family: Georgia;">所有定义为nullptr_t类型的数据都是等价的，行为也是完全一致</span></div></li><li><div><span style="font-family: Georgia;">nullptr_t类型数据可以隐式转换为任意一个指针类型</span></div></li><li><div><span style="font-family: Georgia;">nullptr_t类型数据不能转换为非指针类型，即使是使用reinterpret_cast&lt;nullptr_t&gt;()的方式</span></div></li><li><div><span style="font-family: Georgia;">nullptr_t类型数据不适用于算术运算表达式</span></div></li></ul></ul></ul><div><br/></div><div><span style="font-size: 10pt; font-family: Georgia;">九.C++14特性</span></div><div><span style="font-size: 10pt; color: unset; font-family: Georgia;">十.总结</span></div><div><span style="font-size: 10pt; font-family: Georgia;">    C++中的关键字：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">mutable：可变数据成员，在const成员函数内也能改变数据成员，通过在变量的声明中加入mutable。一个mutable数据成员永远不会是const，即使是const对象的成员</span></div></li><li><div><span style="font-size: 10pt; box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 255); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">__declspec</span><span style="font-size: 10pt; box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(1, 1, 1); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 10pt; box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(1, 1, 1); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">(</span><span style="font-size: 10pt; box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 255); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">novtable</span><span style="font-size: 10pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 10pt; box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(1, 1, 1); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">)：表示这个类不生成虚函数表，但继承类不受影响；使用此关键字相对节省空间——</span><span style="font-size: 10pt; color: rgb(255, 0, 0); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">待验证</span></span></div></li><li><div>delctype：类型指示符，作用是选择并返回操作数的数据类型</div></li><li><div><span style="font-size: 10pt; color: rgb(1, 1, 1); font-family: Georgia;">register：让编译器将变量直接放入寄存器中，以提高存取速度</span><span style="font-size: 10pt; box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(1, 1, 1); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">——</span><span style="font-size: 10pt; box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">待验证</span></div></li></ul><div><span style="font-size: 10pt; font-family: Georgia;">    基础知识点：</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">全局变量和</span><span style="font-size: 10pt; font-family: Georgia;">函数</span><span style="font-size: 10pt; font-family: Georgia;">：</span><span style="font-size: 10pt; font-family: Georgia;">在. h中声明时加上extern，在.cpp中定义(不需要加extern)；包括了声明了extern头文件的文件中可以直接使用该变量，如果没有包含头文件，需要加上extern声明</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">不完全类型使用情景：只能是本类型的指针或引用，声明以不完全类型作为参数或返回值的函数；所以类允许包含指向自身的指针或引用</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">单一定义规则(ODR)：可以多处声明但只能单一定义；在一个头文件中不要定义，因为C++的编译单位是cpp文件，如果这个头文件被多个cpp文件包含，在.o文件链接的时候会报多处定义的错；如果非要用，可以定义成static变量；或使用extern</span></div></li><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">引用和指针的区别：</span></div></li></ul><ol><ol><li><div><span style="font-size: 10pt; font-family: Georgia;">引用必须要初始化，且不能为空，指针可以为空——不存在指向空值的引用意味着使用引用的代码效率比使用指针的要高，因为在使用引用前不需要测试它的合法性；相反指针应该总是被测试，防止其为空</span></div></li><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: Georgia; font-variant-caps: normal; font-variant-ligatures: normal;">引用类型的变量会占用内存空间，占用的内存空间的大小和指针类型的大小是相同的。</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">引用自始至终只能绑定一个变量，指针可以指向不同的地址</span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(85, 85, 85); font-family: &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, Arial, &quot;Microsoft YaHei&quot;, Verdana, Roboto, Noto, &quot;Helvetica Neue&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">sizeof 运算符应用于引用，给出它所引用的元素的大小，所以用sizoef直接计算一个引用变量的大小取到的不是引用本身的大小</span></div></li></ol></ol><ul><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">移位操作：</span></div></li><ul><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">左移相当于乘，左移一位乘以2</span></div></li><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">右移相当于除，右移一位相当于除以2，右移两位相当于除以4</span></div></li><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">对于右移大于或等于位宽的操作，或者右移负数的操作，结果依赖于编译器，不唯一，vs上为原数不变</span></div></li></ul><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: Georgia;">C++确保delete一个空指针是安全的(vs实测delete一个NULL指针没事)</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">数组指针和指针数组</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">数组指针（也称行指针）：是个指针，指向数组</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">定义 int (*p)[n];</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如要将二维数组赋给一指针，应这样赋值：</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Georgia" style="font-size: 10pt;">* int a[3][4];</font></div><div><font face="Georgia" style="font-size: 10pt;">int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。</font></div><div><font face="Georgia" style="font-size: 10pt;">p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</font></div><div><font face="Georgia" style="font-size: 10pt;">p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</font></div></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><ul><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">指针数组：是个数组，里面包含的是指针</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">定义 int *p[n];</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">这两者的区别：数组指针似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。</span><span style="font-size: 10pt; color: rgb(45, 79, 201); font-family: Georgia;">注意：char类型的不管是指针还是数组，</span><span style="font-size: 10pt; font-family: Georgia;">都要以&quot;\0&quot;结尾，不然不知道何时结束，导致出现奇怪的值，或者长度和申请的长度不一致</span></div></li></ul><li><div><span style="font-family: Georgia;">strlen和sizeof的区别：</span></div></li><ul><li><div><span style="font-family: Georgia;">strlen计算长度不包含终止null字节的字符串长度，sizeof则计算了包括终止null字节的缓冲区长度</span></div></li><li><div><span style="font-family: Georgia;">strlen需要一次函数调用，而对于sizeof而言，因为缓冲区已用已知字符串进行初始化，其长度是固定的，所以sizeof是在编译时计算缓冲区长度</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const char *a = &quot;hello&quot;;</div><div>cout &lt;&lt; sizeof(a) &lt;&lt; endl;    // 输出6</div><div>cout &lt;&lt; strlen(a) &lt;&lt; endl;    // 输出5</div></div></div><ul><li><div><span style="font-size: unset; color: unset; font-family: unset;">小型对象分配：</span><span style="font-size: unset; color: unset; font-family: unset;">为什么需要小型对象分配器：</span></div></li><ul><li><div>C++中的new/delete只是对C heap分配器的包装，C heap分配器并未特别对小块内存的分配进行优化，C分配器通常用来分配中大型对象（数百或数千个bytes），所以导致分配速度慢</div></li><li><div>C++缺省分配器的通用性也造成小型对象空间分配的低效。缺省分配器管理一个记忆池，而这种管理通常需要耗费一些额外内存，如果分配区块大的话这些开销是微不足道的，但如果分配区块小的话开销所占的比例就非常大了</div></li><li><div>在C++中动态分配很重要，执行期多态和动态分配的联系最为紧密，高效的C++程序开发缺省分配器的低劣性能成为一种障碍</div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">输入/输出运算符的重载：</span><span style="font-size: 10pt; font-family: Georgia;">输入输出运算符必须是非成员函数，一般声明为友元</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">输出运算符&lt;&lt;：</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">第一个形参是non-const的ostream引用，向流写入内容，所以是non-const，无法复制ostream对象，所以是引用; 第二个形参是一个常量的引用，是要打印的类类型</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">为了与其他输出运算符保持一致，operator&lt;&lt;一般返回它的ostream形参</span></div></li></ul><li><div><span style="font-size: 10pt; font-family: Georgia;">输入运算符&gt;&gt;:</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">第一个形参是运算符将要读取的流的引用，第二个形参是将要读到的非常量对象的引用</span></div></li></ul></ul><li><div><span style="font-family: Georgia;">一种for的用法：（范围for循环？）</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int elem : coll1)</div><div>{</div><div>   cout &lt;&lt; elem &lt;&lt; &quot; &quot;;</div><div>}</div></div><ul><li><div><span style="font-family: Georgia;">转换函数：</span></div></li><ul><li><div><span style="font-family: Georgia;">C中整数，浮点数，字符串之间的转换：</span></div></li><ul><li><div><span style="font-family: Georgia;">atoi：字符串转整数</span></div></li></ul><li><div><span style="font-family: Georgia;">C++中的转换：</span></div></li><ul><li><div><span style="font-family: Georgia;">std::stod: 字符串转浮点型</span></div></li></ul></ul><li><div><span style="font-size: 10pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: Georgia;">口算二进制：</span><a href="https://blog.csdn.net/devnn/article/details/82597660" style="font-size: 10pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Georgia;">https://blog.csdn.net/devnn/article/details/82597660</a></div></li></ul><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt; font-family: Georgia;">十. 编译与函数参数入栈总结：</span></div><div><span style="font-size: 10pt; font-family: Georgia;">摘自：</span><a href="http://blog.csdn.net/frankiewang008/article/details/7481865" style="font-size: 10pt; font-family: Georgia;">http://blog.csdn.net/frankiewang008/article/details/7481865</a></div></div><div><br/></div><div><img src="基础总结_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div></span>
</div></body></html> 