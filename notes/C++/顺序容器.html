<html>
<head>
  <title>顺序容器</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="705"/>
<h1>顺序容器</h1>

<div>
<span><div><div>容器的选择：</div><div>1.在意查找速度：散列容器，排序的vector和标准关联容器</div><div>2.容器中的数据的内存布局需要兼容C吗？使用vector</div><div><br clear="none"/></div><div>总结：effective stl</div><ul><li><div>使用typedef代码代替“容器无关代码”</div></li><li><div>在容器中进行拷贝操作：不管是添加对象还是删除对象，都是进行拷贝操作，如果是类的对象，存在以下问题</div></li><li><div>以基类对象建立一个容器，将派生类对象加入容器中时会导致分割，解决办法是建立指针的容器而不是对象的容器，但是指针也可能会存在问题，智能指针是个不错的选择（应该是智能指针的类型作为容器元素类型）</div></li><li><div>判断容器为空首选empty而不是size()=0，理由很简单：对于所有的标准容器，empty是一个常数时间的操作，但对于一些list实现，size花费线性时间。</div></li><li><div>尽量使用区间成员函数如assign，区间insert等代替单元素操作如单元素insert：代码量更少，更清晰；效率更高</div></li></ul><div><br clear="none"/></div><div>注意：</div><ol><li><div>使用new的指针作为容器元素，要确保在销毁容器前delete指针，容器在销毁时会销毁它包含的每个元素，但指针的析构无操作！所以：</div></li></ol><ol><li><div>使用智能指针代替原始指针(effective STL 7)</div></li><li><div>使用vector，string等代替动态分配的数组(effective STL 13)</div></li></ol><ul><li><div>STL容器的元素需要满足三个要素：</div></li></ul><ol><ol><li><div>可拷贝</div></li><li><div>可赋值</div></li><li><div>可析构</div></li></ol></ol><div>去除一个容器中有特定值的所有对象：</div><ul><li><div>如果容器是vector，string，deque，使用erase-remove</div></li><li><div>如果容器是list，使用list::remove</div></li><li><div>如果容器是标准关联容器，使用他的erase函数</div></li></ul><div><br clear="none"/></div><div>一. 添加/删除元素和访问顺序是选择容器类型的标准</div><table style="table-layout: fixed; border-collapse: collapse; min-width: 100%;-evernote-table:true;"><colgroup><col style="width: 248px;"></col><col style="width: 219px;"></col><col style="width: 131px;"></col><col style="width: 250px;"></col></colgroup><tbody><tr><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 248px; padding: 8px;"><div>容器类型</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 219px; padding: 8px;"><div>访问顺序</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 131px; padding: 8px;"><div>添加/删除元素顺序</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 250px; padding: 8px;"><div>备注</div></td></tr><tr><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 248px; padding: 8px;"><div>string</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 219px; padding: 8px;"><div>随机访问</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 131px; padding: 8px;"><div>尾部</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 250px; padding: 8px;"><div><br clear="none"/></div></td></tr><tr><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 248px; padding: 8px;"><div>vector：会自动增长的数组</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 219px; padding: 8px;"><div>随机访问</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 131px; padding: 8px;"><div>尾部</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 250px; padding: 8px;"><div>1.如无很好的理由，使用vector是最好的选择;</div><div>2.避免使用vector&lt;bool&gt;</div></td></tr><tr><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 248px; padding: 8px;"><div>deque：deque模板是通过链接若干片连续的数据实现的，所以均衡了以上两个容器的特点</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 219px; padding: 8px;"><div>双端队列，随机访问</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 131px; padding: 8px;"><div>头部，尾部</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 250px; padding: 8px;"><div>支持对所有元素的随机访问，在中间位置添加或删除代价很高，两端插入或删除则很快；</div><div>在deque容器首部或尾部插入元素不会使任何迭代器失效，而在首部或尾部删除元素则只会使指向该元素的迭代器失效。在deque容器的任何其他位置的插入与删除操作将使指向该容器元素的所有迭代器失效。</div></td></tr><tr><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 248px; padding: 8px;"><div>list</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 219px; padding: 8px;"><div>双向链表，只支持双向顺序访问</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 131px; padding: 8px;"><div>任何位置</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 250px; padding: 8px;"><div>1.这两个容器的目的是在任何位置添加或删除都很快速；</div><div>2.作为代价不支持元素的随机访问，为访问一个元素需遍历整个容器；</div><div>3.删除或插入不会使list的迭代器失效，list和forwar_list的额外内存开销很大</div></td></tr><tr><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 248px; padding: 8px;"><div>forward_list（c++11中新增加）</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 219px; padding: 8px;"><div>单向链表，只支持单向顺序访问</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 131px; padding: 8px;"><div>任何位置</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 250px; padding: 8px;"><div>没有size操作</div></td></tr><tr><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 248px; padding: 8px;"><div>array（c++11中新增加）</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 219px; padding: 8px;"><div>随机访问</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 131px; padding: 8px;"><div>/</div></td><td rowspan="1" style="border: 1px solid rgb(211, 211, 211); width: 250px; padding: 8px;"><div>1.大小是固定的；所以不支持删除和改变容器大小的操作</div></td></tr></tbody></table><div>类型别名</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 192px;"></col><col style="width: 345px;"></col><col style="width: 291px;"></col></colgroup><tbody><tr><td rowspan="1" style="width: 192px; padding: 8px; border: 1px solid;"><div>类型别名</div></td><td rowspan="1" style="width: 345px; padding: 8px; border: 1px solid;"><div>操作</div></td><td rowspan="1" style="width: 291px; padding: 8px; border: 1px solid;"><div>备注</div></td></tr><tr><td rowspan="1" style="width: 192px; padding: 8px; border: 1px solid;"><div>iterator/const_iterator</div></td><td rowspan="1" style="width: 345px; padding: 8px; border: 1px solid;"><div>容器的迭代器类型</div></td><td rowspan="1" style="width: 291px; padding: 8px; border: 1px solid;"><div><br clear="none"/></div></td></tr><tr><td rowspan="1" style="width: 192px; padding: 8px; border: 1px solid;"><div>size_type</div></td><td rowspan="1" style="width: 345px; padding: 8px; border: 1px solid;"><div>无符号整数类型</div></td><td rowspan="1" style="width: 291px; padding: 8px; border: 1px solid;"><div><br clear="none"/></div></td></tr><tr><td rowspan="1" style="width: 192px; padding: 8px; border: 1px solid;"><div>difference_type</div></td><td rowspan="1" style="width: 345px; padding: 8px; border: 1px solid;"><div>带符号整数类型，足够保存两个迭代器之间的距离</div></td><td rowspan="1" style="width: 291px; padding: 8px; border: 1px solid;"><div><br clear="none"/></div></td></tr><tr><td rowspan="1" style="width: 192px; padding: 8px; border: 1px solid;"><div>value_type</div></td><td rowspan="1" style="width: 345px; padding: 8px; border: 1px solid;"><div>元素类型</div></td><td rowspan="1" style="width: 291px; padding: 8px; border: 1px solid;"><div><br clear="none"/></div></td></tr><tr><td rowspan="1" style="width: 192px; padding: 8px; border: 1px solid;"><div>reference/const_reference</div></td><td rowspan="1" style="width: 345px; padding: 8px; border: 1px solid;"><div>元素的左值类型，与value_type&amp;含义相同</div></td><td rowspan="1" style="width: 291px; padding: 8px; border: 1px solid;"><div><br clear="none"/></div></td></tr></tbody></table><div>注：</div><ol><li><div>如果在读取输入时需要在容器中间位置插入元素，随后随机访问：（1）vector—&gt;sort；（2）list——&gt;拷贝到vector    为什么要拷贝到vector中？</div></li></ol><div>vector: effective stl</div><div>1.vector和string重新分配内存有以下四个部分：</div><ul><li><div>分配新的内存</div></li><li><div>把所有的元素从容器的旧内存拷贝到新内存中</div></li><li><div>销毁旧内存中的对象</div></li><li><div>回收旧内存</div></li></ul><div>1. 避免使用vector&lt;bool&gt;，因为vector&lt;bool&gt;是一个伪容器，并不保存真正的bool，而是打包bool以节省空间，在一个典型的实现中，每个保存在vector中的bool占用一个bit，一个byte可以容纳8个bool</div><div>替代品：</div><ul><li><div>deque&lt;bool&gt;:保存真正的bool</div></li><li><div>使用bitset（#include&lt;bitset&gt;）代替</div></li></ul><div>2.收缩到合适：假如有一个vector v的capacity()大于size()：vector&lt;T&gt;(v).swap(v)会使v的capacity大小同size()一样大：因为拷贝构造只分配拷贝的元素需要的内存，所以这个临时的vector没有多余的空间，然后再交换，就可以达到收缩到合适大小；同样的技巧可以用到string，这个技巧也可以用来清除vector和string</div><div>3.在使用vector前先判断empty</div><div>4.当你需要一个指向vector内部数据的指针时不该使用begin(),begin返回的时iterator而不是指针，虽然vector的迭代器是指针但不能依赖于此，最好&amp;v[i];</div><div>5.类似于vector上获取指向内部数据的指针，对string也是不可靠的</div><div><br clear="none"/></div><div><span style="font-weight: bold;">vector</span></div><div>初始化操作：</div><div>vector&lt;T&gt; v1(n)：包含了n个重复执行值初始化的对象</div><div>非更易性操作：</div><ul><li><div>shrink_to_fit()：要求降低容量，以符合元素个数</div></li></ul><div>operator==：<font style="color: rgb(227, 0, 0);">个数相同且元素相同，不计较元素的顺序——？待核实</font></div><div><br/></div><div>list</div><div>更易性操作：</div><ul><li><div>sort()：以operator&lt;为准则对所有元素排序</div></li><li><div>sort(op)：以op为准则对所有元素排序</div></li></ul><div><br/></div><div>三.所有容器都提供的操作：</div><div>     1.获取迭代器：</div><ul><li><div>c.begin()，c.end()：返回指向c的首元素和尾元素之后位置的迭代器，解引用迭代器返回所指元素的引用；如果对象是常量则返回const_iterator</div></li><li><div>c.cbegin()，c.cend()：返回const_iterator，当不需要写访问 时应当使用这两个迭代器；不管对象是否是常量，这两个函数返回的都是const_iterator</div></li></ul><div>     2.赋值与swap：</div><ul><li><div>c1=c2；</div></li><li><div>c1={a，b，c，... ...}：将c1中的元素替换为列表中的元素——不适用于array</div></li><li><div>a.swap(b)：交换容器a和b的元素：元素本身并未交换，只是交换了两个容器的内部数据结构，但swap两个array会真正交换他们的元素</div></li><li><div>swap（a，b）：同上，应统一使用非成员版本的</div></li><li><div>注解：除array外swap不对任何元素进行拷贝，删除或插入操作</div></li><li><div>与其他容器不同，对一个string调用swap会导致迭代器，引用和指针失效，为什么？</div></li></ul><div>     4.大小：</div><ul><li><div>c.size()：c中元素的数目；—— forward_list 不支持size，但支持max_size()和empty()</div></li><li><div>c.max_size()：返回一个大于或等于该类型容器所能容纳的最大元素数的值；</div></li><li><div>c.empty()：判断c是否为空，若为空返回true，否则返回false</div></li></ul><div>     5.添加/删除元素（不支持array）</div><ul><li><div>c.insert（args）：</div></li><li><div>list中的insert支持以下：</div></li><li><div>l.insert(pos, elem):在迭代器pos之前插入元素elem</div></li><li><div>l.insert(pos, n, elem):在迭代器pos之前插入n个elem，并返回第一个新元素的位置</div></li><li><div>l.insert(pos, beg, end): 在迭代器pos之前插入区间[beg, end)的一份拷贝，并返回第一个新元素的位置</div></li><li><div>l.insert(pos, initlist)</div></li><li><div>c.emplace(inits)：</div></li><li><div>c.erase(args)：删除参数指定的元素</div></li><li><div>c.clear()：删除c中所有元素，返回void</div></li></ul><div>     6.构造函数</div><ul><li><div>C c：默认构造函数</div></li><li><div>C c(n)：n为数字，表示容器c的大小，默认初始化（如果是int则为0）</div></li><li><div>拷贝初始化：C c1（c2）/C c1=c2：c1和c2必须是相同类型（相同的容器类型以及相同的元素类型；对array来说还具有相同的大小）</div></li><li><div>列表初始化：C c{a,b,c, ... ...}/C c={a,b,c, ... ...}：</div></li><li><div>C c(b,e)：初始化为迭代器b和e指定范围中的元素的拷贝，范围中元素的类型与C的元素类型必须相容（容器类型可以不一样）（也可用数组指针表示的范围初始化）——不支持array</div></li><li><div>顺序容器支持（不包括array）：C seq（n）/C seq（n，t），接受一个容器大小和一个（可选的）元素初始值</div></li></ul><div>     7.反向容器的额外成员：反向遍历容器的迭代器不支持forward_list</div><ul><li><div>reverse_iterator：按逆序寻址元素的迭代器</div></li><li><div>const_reverse_iterator：不能修改元素的逆序迭代器</div></li><li><div>c.rbegin(), c.rend()：返回指向c尾元素和首元素之前位置的迭代器</div></li><li><div>c.crbegin(), c.crend()：返回const_reverse_iterator</div></li></ul><div>四.顺序容器支持的操作：assign操作不适用于关联容器和array；容器类型可以不同，但元素类型必须相同；传递给assign的迭代器不能指向调用assign的容器</div><ol><li><div>seq.<span style="font-weight: bold;">assign</span>(b,e)：将seq中的元素替换为迭代器b和e表示的范围中的元素，这两个迭代器不能指向seq中的元素；b和e可以是表示数组范围的指针</div></li><li><div>seq.assign(il)：将seq中的元素替换为初始化列表i1中的元素</div></li><li><div>seq.assign(n,t):将seq中的元素替换为n个值为t的元素</div></li></ol><div>五.顺序容器中的操作：（添加/插入/删除 操作不支持array）</div><div>     1. 后面添加（不支持forward_list）：</div><ul><li><div>c.push_back(t):返回void，添加到对象尾端</div></li><li><div>c.emplace_back(args)：返回void</div></li></ul><div>     2.前面添加（不支持string和vector）：最好只用于deque</div><ul><li><div>c.push_front(t)：返回void</div></li><li><div>c.emplace_front(t)</div></li></ul><div>     3.在迭代器之前位置之前插入（forward_list有自己版本的insert）：都返回新添加的第一个元素的迭代器；最好只用于list和forward_list</div><ul><li><div>c.insert(p,t):迭代器p指向的元素之前插入t或args创建的元素，返回新添加的元素的迭代器</div></li><li><div>c.emplace(p,args):</div></li><li><div>c.insert(p,n,t):迭代器p指向的元素之前插入n个置位t的元素，返回新添加的第一个元素的迭代器</div></li><li><div>c.insert(p,b,e):将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前</div></li><li><div>c.insert(p,i1):在p之前插入i1，i1是花括号包围的元素值列表</div></li></ul><div>     注解：</div><ul><li><div>前面几种出现了emplace_xxxx，与push_back不同点：push_xx是将构造好的对象拷贝到容器中，而emplace则是根据提供的参数直接在容器中构造元素而不是拷贝；当调用push或insert时是将元素的对象传递给它们，这些对象被拷贝到容器中，当调用emplace时则是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素。（C++ Primer P346）</div></li><li><div>emplace函数的参数必须与元素类型的构造函数相匹配</div></li></ul><div>     4.删除元素：这些操作都会改变容器的大小，所以不适用于array；在删除元素前必须确保是存在的</div><ul><li><div>c.pop_back():删除尾元素，返回void；（forward_list不支持）</div></li><li><div>c.pop_front():删除首元素，返回void；（vector和string不支持 ）</div></li><li><div>c.erase(p):删除迭代器p指定的元素，返回被删除元素之后元素的迭代器【fordlist_list有特殊版本的erase】</div></li><li><div>c.erase(b,e):删除[b,e)范围的元素，返回指向最后一个被删元素之后的元素迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器</div></li><li><div>c.remove: list使用这个更高效——是否支持其他？</div></li><li><div>c.remove_if</div></li><li><div>c.clear():删除c中所有元素，返回void</div></li></ul><div>     5.访问元素：在容器中访问成员函数返回的都是引用，如果容器是const对象，返回的是const的引用；如果容器中没有元素，访问的结果是未定义的，所以在调用back和front之前要确保c为非空</div><ul><li><div>c.back()：返回尾元素的引用（除forward_list）</div></li><li><div>c.front()：返回首元素的引用 (所有顺序容器)</div></li><li><div>c[n]:返回下标为n的元素的引用，n的类型为size_type</div></li><li><div>c.at(n)：返回下标为n的元素的引用，若下标越界，抛出out_of_range异常，这大概 是与c[n]的唯一区别；c[n]和c.at(n)的区别还有哪些？如果元素是sting的话返回const char*, []返回string</div></li></ul><div>     6.四个成员函数，只有vector和string提供了这些函数：</div><ul><li><div>如果resize缩小容器，则指向被删除元素的迭代器，引用和指针都会失效；对vector，string或deque进行resize可能导致迭代器，指针，引用失效</div></li><li><div>array不支持</div></li><li><div>c.resize(n):调整容器大小，增大或缩小容器，使容器大小改变为n——vector的内存应该有移动吧？</div></li><li><div>c.resize(n,t)：调整c的大小为n，多出的空间用t初始化</div></li><li><div>capacity():容量大小</div></li><li><div>size():容器中有多少元素</div></li></ul><div>    7.list独有的操作：</div><ul><li><div>排序：l.sort():以operator&lt;为准则（从小到大）对元素进行排序</div></li></ul><div>链表：list和forward_list</div><ul><li><div>总说：</div></li><ul><li><div>这两个容器的设计目的是令容器任何位置的添加和删除操作很快速，作为代价，不支持元素的随机访问：为了访问一个元素只能遍历整个容器</div></li><li><div>与vector，deque和array相比，这两个容器的额外内存开销很大</div></li></ul></ul><div>list：</div><ul><li><div>相比较array，vector，deque的不同：</div></li><ul><li><div>不支持随机访问，如果要访问第5个元素，就得沿着link航行前4个元素</div></li><li><div>任何位置安插和删除元素很快（<span style="color: rgb(227, 0, 0); font-weight: bold;">确定这个位置的过程是否很慢？</span>）</div></li><li><div>安插和删除动作不会造成指向其他元素的pointer，reference和iterator失效</div></li><li><div>list提供的成员函数反映出其与vector，array，deque的不同：</div></li><ul><li><div>list提供front，push_front，pop_front，back，push_back，pop_back等操作函数</div></li><li><div>由于不支持随机访问，所以不提供下标运算符，也不支持at方法</div></li><li><div>list不提供容量，空间重新分配操作函数</div></li></ul></ul></ul><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">forward_list</span>操作：单向链表，通过改变给定元素之后的元素完成</div><ul><li><div>相比较list，forward_list有以下约束：</div></li><ul><li><div>只提供前向迭代器，不支持双向迭代器，也不支持反向迭代器，所以诸如rbegin等方法是不支持的</div></li><li><div>不提供size方法——<span style="color: rgb(227, 0, 0); font-weight: bold;">为什么？</span></div></li><li><div>没有指向最末元素的锚点，所以用以处理末元素的方法诸如back，push_back，pop_back等是不支持的——<span style="color: rgb(227, 0, 0); font-weight: bold;">为什么？</span></div></li><li><div><span style="color: rgb(227, 0, 0); font-weight: bold;">……</span></div></li></ul><li><div>除了以上，其他和list相同：</div></li><ul><li><div>不提供随机访问，如要访问第5个元素，必须沿着link航行前4个元素，因此在forward_list中访问任意元素会非常慢</div></li><li><div>在任意位置安插和移除元素会速度会非常快，前提是指出了那个位置（<span style="color: rgb(227, 0, 0); font-weight: bold;">确定这个位置的过程是不是又非常慢？</span>）</div></li><li><div>安插或移除元素不会造成指向其他节点的指针，引用，迭代器失效</div></li></ul><li><div>非更易性操作：</div></li><ul><li><div>c.empty()：判断容器是否为空</div></li><li><div>c.max_size()</div></li><li><div>6个比较操作</div></li></ul></ul><div>为什么说链表在插入和删除上效率要高于数组？</div><div>插入删除操作时间复杂度对比：</div><div>在只知道小标时：</div><ul><li><div>数组：O(n)：需要移动其后所有项的位置</div></li><li><div>链表：O(n)：需要遍历前面所有项以得到下标对应的项</div></li></ul><div>在拥有操作项的引用(或指针，迭代器等)时：</div><ul><li><div>数组：O(n)</div></li><li><div>链表：O(1)</div></li></ul><div>结论：</div><ul><li><div>若线性表需要频繁查找，很少进行插入和删除操作时，应该采用顺序存储结构；</div></li><li><div>频繁插入和删除需要采用链表结构</div></li><li><div>当不确定线性表中元素个数变化或者大小时采用单链表结构</div></li></ul><div><br/></div><div>    1.迭代器：</div><ul><li><div>lst.before_begin( )/lst.cbefore_begin( )：返回指向链表首元素之前不存在的元素的迭代器，不能解引用；</div></li></ul><div>    2.插入操作：</div><ul><li><div>lst.insert_after(p,t)：在迭代器p之后插入元素，t是一个对象；返回一个指向最后一个插入元素的迭代器，如果范围为空则返回p；</div></li><li><div>lst.insert_after(p,n,t)：n是数量</div></li><li><div>lst.insert_after(p,b,e)：b和e是表示范围的一对迭代器（b和e不能指向lst内）</div></li><li><div>lst.insert_after(p.i1)：i1是一个花括号列表。</div></li></ul><div>    3.删除操作：</div><ul><li><div>lst.erase_after(p)：删除p指向的位置之后的元素，返回一个被删除元素之后元素的迭代器，若不存在这个元素则返回尾后迭代器</div></li><li><div>lst.erase_after(b,e)：删除b之后直到e之间（b，e）的元素</div></li></ul><div>七.容器操作可能导致迭代器失效：</div><div>八.容量管理：</div><ul><li><div>c.capacity( )：（适用于vector和string）在容器不扩张内存的情况下可以容纳元素的个数</div></li><li><div>c.reserve(n)：（适用于vector和string）分配至少能容纳n个元素的内存空间（可以比n更多）,如果n比实际容器中的个数小则不做任何改变，但一般会强迫进行一次重新分配；reserve之后迭代器会失效；避免使用重新分配的关键是使用reserve尽快把容器容量；通常有两种情况使用reserve来避免不必要的重新分配：</div></li><li><div>第一：大约知道有多少元素出现在容器中</div></li><li><div>第二：保留你可能需要的最大空间</div></li><li><div>c.shrink_to_fit()：（适用于vector，string，deque）：请求将capacity（）减少为与size()相同大小，只是一个请求，标准库并不保证退还内存</div></li></ul><div>九.string操作：</div><ul><li><div>构造string：接收string 或const char* 参数</div></li><ul><li><div>string s(cp,n)：s是cp指向的数组 中前n个字符的拷贝</div></li><li><div>string s(s2,pos2):s是string s2从下标pos2开始的字符的拷贝</div></li><li><div>string s(s2,pos2,len2):string s2从下标pos2开始的len2个字符的拷贝</div></li></ul><li><div>转换为字符数组或C数组</div></li><ul><li><div>data() / c_str()：返回一个以'\0'结尾的C数组</div></li><li><div>copy(char* const buf, size_t count, const size_t off)：将string内容复制到调用者提供的字符数组中，末尾不添加'\0'字符</div></li></ul><li><div>大小和容量</div></li><ul><li><div>empty()：用来检验字符串是否为空，应该优先使用该函数</div></li><li><div>size() / length()：返回string的现有字符，两个函数等效</div></li><li><div>max_size()：string最多能包含的字符数</div></li><li><div>capacity()：重新分配内存前，string所能包含的最大字符数</div></li><li><div>reserve()：预留容量，避免重新分配；与vector不同，string使用reserve可以缩减容量；默认参数为0</div></li><li><div>shrink_to_fit()：非强制性缩减容量，不一定缩减成功</div></li></ul><li><div>元素访问：</div></li><ul><li><div>operator[] / at()：[]不会检查索引是否有效，at会检查，如果调用at时指定的索引无效会抛出out_of_range</div></li><li><div>front()相当于[0]</div></li><li><div>back()</div></li></ul><li><div>比较：</div></li><ul><li><div>&lt;/&lt;=/&gt;/&gt;=是将比较的两个字符串的各个字符ascii码进行比较</div></li><li><div>compare：作用同上</div></li></ul><li><div>更改内容：</div></li><ul><li><div>swap</div></li><li><div>clear() / erase()：令string为空</div></li></ul><li><div>搜索和查找：</div></li><ul><li><div>每个函数有4个重载版本</div></li><li><div>查找失败返回一个特殊值：npos，定义于string中，如 if(idx == string::npos)，npos被定义为一个const string::size_type类型，并初始化为-1；</div></li><li><div>检验查找函数的返回值时使用string::size_type类型而不是int或unsigned，表示匹配发生的下标位置，否则与npos的比较动作无法有效运行</div></li><li><div>可以查找字符，字符串</div></li><li><div>成员函数：</div></li><ul><li><div>find() / rfind():查找第一个/最后一个 与value相等的字符，如果成功就返回字符索引，否则返回string::npos</div></li><li><div>find_first_of() / find_last_of()：查找第一个/最后一个 与value中的某值相等的字符</div></li><li><div>find_first_not_of() / find_last_not_of()：查找第一个 / 最后一个 与value中的任何值都不相等的字符</div></li><li><div>第一参数永远是被查找对象</div></li></ul></ul><li><div>函数而非成员数值转换：</div></li><ul><li><div>stoi(str, idexRet=nullptr, base=10)：将str转换成int，同样的函数还有stol等，具体参考C++标准库13.2.13</div></li><li><div>to_string(val)：将val转换成一个string，val可以是int，long等</div></li></ul><li><div>支持迭代器操作：</div></li><ul><li><div>迭代器类型：string::iterator</div></li><li><div>begin,end</div></li></ul></ul><ol start="2"><li><div>s.substr(pos,n): </div></li><ol><li><div><span style="font-size: unset; color: unset; font-family: unset;">参数：</span><span style="font-size: unset; color: unset; font-family: unset;">传递一个可选的开始位置和计数值：</span></div></li><ol><li><div><span style="font-size: unset; color: unset; font-family: unset;">pos：开始位置，默认值为0；</span></div></li><li><div><span style="font-size: unset; color: unset; font-family: unset;">n：为从pos开始要取得字符的个数，默认为从pos开始的所有字符，若n&gt;s.size(),只取从pos开始到结束的部分。</span></div></li></ol><li><div><span style="font-size: unset; color: unset; font-family: unset;">返回值：返回一个string，它是原始string的一部分或全部的拷贝。[ )</span></div></li></ol></ol><div>九.array：定义时指定元素类型和大小</div><ul><li><div>array不允许用花括号包围的列表赋值但可以列表初始化？？？</div></li></ul><div><br/></div><div>十.<span style="font-size: 11pt; font-weight: bold;">容器适配器</span>：标准库定义了三个顺序容器适配器：stack（栈适配器），queue（队列适配器），priority_queue（优先队列），所有的适配器都要求容器具有添加，删除，以及访问尾元素的能力</div><div>   1.所有容器都支持的类型：</div><ul><li><div>size_type:表示当前类型对象的大小</div></li><li><div>value_type：元素类型</div></li><li><div>container_type：实现适配器的底层容器类型</div></li><li><div>A a/A a(C)：创建一个名为a的空适配器/带有容器C的一个拷贝；</div></li><li><div>关系运算符：支持所有关系运算符：==，！=，&lt;,&lt;=,&gt;,&gt;=</div></li><li><div>a.empty():为空则返回true，否则返回false</div></li><li><div>a.size():返回a中元素数目</div></li><li><div>a.swap(a,b)：交换a和b的内容,a和b必须有相同类型，包括底层容器类型也必须相同</div></li><li><div>swap（a,b）:</div></li></ul><div>   2.栈适配器stack：定义在头文件stack中，默认基于deque实现，也可以在list或vector之上实现，适用场合？</div><ul><li><div>s.pop()：删除栈顶元素，但不返回该元素值</div></li><li><div>s.push(item)/s.emplace(args)：创建一个新元素压入栈顶，该元素通过拷贝或移动item而来,或者由args构造</div></li><li><div>s.top()：返回栈顶元素，但不删除元素</div></li><li><div>注意：除了最顶端外，没有任何其他方法可以存取stack的其他元素。</div></li></ul><div>   3.队列适配器：queue是通过deque实现，主要接口为：</div><ul><li><div>q.push()：将一个元素放入到queue尾</div></li><li><div>q.front()：返回队列queue的第一个元素（最先插入的）</div></li><li><div>q.back()：返回队列queue中最后一个元素</div></li><li><div>q.pop()：移除最前端的元素（最先进的元素），不返回值</div></li><li><div>注意：</div></li></ul><div>queue和priority_queue（优先队列）适配器定义在queue头文件中，queue是基于deque 实现，priority_queue默认基于vector 实现</div><ul><li><div>q.pop()：返回queue的首元素或priority_queue的最高优先级的元素，但不能删除此元素</div></li><li><div>q.front()：返回首元素或尾元素，但不删除此元素</div></li><li><div>q.back()：只适用于queue，返回队列最后一个元素的引用</div></li><li><div>q.top()：返回最高优先级元素，但不删除该元素，只适用于priority_queue</div></li><li><div>q.push(item)/q.emplace(args)：在queue末尾或priority_queue中恰当的位置创建一个元素，值为item,或者由args构造</div></li></ul><div>   2.默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的，可以将一个命名的顺序容器作为第二个类型参数重载默认容器类型</div><ul><li><div>stack：可以使用除array和forward_list之外的任何容器类型来构造stack</div></li><li><div>queue：可以构造于list或deque之上，但不能基于vector构造</div></li><li><div>priority_queue：可以构造于vector或deque之上，但不能基于list</div></li></ul><div>十一.补充：</div><ol><li><div>可以使用数组或数组的一部分初始化vector，必须使用指针</div></li><li><div>有成员版本的swap，也有非成员版本的swap，在泛型编程中使用非成员版本的swap；swap除array外不对任何元素进行拷贝，删除，或插入操作，因此，除string外，指向容器的迭代器，引用和指针在swap操作之后都不会失效，仍指向swap操作之前所指向的那些元素，但swap之后这些元素已经属于不同的容器了。对string调用swap会导致迭代器，引用和指针失效。swap两个array 会真正交换它们的元素。</div></li></ol><div><br/></div><div><br clear="none"/></div><div style="margin: 10px auto 10px 73.5pt; padding: 0px; text-indent: -73.5pt; letter-spacing: normal; orphans: 2; text-align: left; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div><br/></div></div></div><div><br/></div></span>
</div></body></html> 