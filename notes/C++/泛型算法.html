<html>
<head>
  <title>泛型算法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="715"/>
<h1>泛型算法</h1>

<div>
<span><div><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div>总说：</div><ul><li><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">大多数算法在头文件algorithm中，在头文件numeric中定义了一组数值泛型算法。理解算法最基本的方法就是了解他们是否读取元素，改变元素，或是重排元素顺序</span></div></li><li><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 10pt; font-family: Georgia;">使用STL算法经常需要使用函数对象和函数适配器，所以需要#include&lt;functional&gt;</span></div></li><li><div style="background-color: rgb(255, 255, 255);"><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">所有算法都被设计用来</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">处理</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">一个或多个</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">iterator区间，</span></font><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">所以，迭代器令算法不依赖于容器，但算法依赖于元素类型的操作，如find算法依赖元素&quot;==&quot;运算符，其他算法可能要求元素支持&quot;&lt;&quot;运算符。这也意味着如果想让自定义类型支持算法，需要自定义运算符</span><span style="font-size: 10pt; color: rgb(227, 0, 0); font-family: Georgia;">泛型算法只作用于迭代器上而不会执行容器上的操作，带来了一个特性：算法永远不会改变容器的大小</span></div></li></ul><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-weight: bold;">插入迭代器：back_inserter/front_inserter/inserter：</span></div><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 10pt;"><br/></span></div><div style="background-color: rgb(255, 255, 255);"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;">STL算法命名时引入了两个后缀：</span></div><ol style="background-color: rgb(255, 255, 255);"><li><div><span style="font-size: 10pt; font-family: Georgia;">后缀_if:要求有函数或函数对象作为参数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">后缀_copy:此算法表示元素不只被操作，还会被复制到标的区间</span></div></li></ol><div><font style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">一. for_each()算法（</span><span style="background-color: rgb(255, 250, 165);font-size: 10pt;-evernote-highlight:true;"><span style="font-size: 10pt; background-color: rgb(255, 250, 165); color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;-evernote-highlight:true;">常用指数：*****</span></span><span style="background-color: rgb(255, 255, 255); font-size: 10pt; font-family: Georgia; font-weight: bold;">）</span></span><span style="background-color: rgb(255, 255, 255); font-size: 10pt; font-family: Georgia;">：C++11之后范围for循环提供了更大的方便</span></font></div><ul style="background-color: rgb(255, 255, 255);"><li><div><span style="font-size: 10pt; font-family: Georgia;">UnaryProc for_each(beg, end, UnaryProc op)</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">对区间[beg, end)的每一个元素调用op(elem)</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">返回op的一个拷贝，</span><span style="font-size: 10pt; font-family: Georgia; font-style: italic;">在C++11中返回的op是移动过的  </span></font></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">op可以改动元素，但它的任何返回值都会被忽略</span></div></li><li><div><font style="font-size: 10pt;"><br/></font></div></li></ul></ul></div><div><span style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;"><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">二.非更易型算法</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">：不会改变元素值和元素次序</span></font></span></div><div><span style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">1.元素计数：</span></span></div><ul><li><div><span style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;"><span style="font-size: 10pt; font-family: Georgia;">difference_type</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">count</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value)/difference_type</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">count_if</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, op)</span></span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">第一形式计算[beg, end)中元素值等于value的元素个数，第二形式计算[beg, end)中令op(elem)结果为true的元素个数</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">返回类型difference_type,用来表示iterator间距的类型</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">注意：op不应该在函数调用过程中改变状态</span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">2.最大值和最小值</span></div><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">min_element</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">min_element</span>(beg, end, op)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">max_element</span>(beg, end)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">max_element</span>(beg, end, op)/pair&lt;ForwardIterator,</span><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span><span style="font-size: 10pt; font-family: Georgia;">&gt; </span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">minmax_element</span>(beg,end)/</span><span style="font-size: 10pt; font-family: Georgia;">pair&lt;ForwardIterator,</span><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span><span style="font-size: 10pt; font-family: Georgia;">&gt; </span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">minmax_element</span>(beg, end, op)</span></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">这6个算法分别返回(beg, end]中最小元素位置，最大元素位置，最小和最大组成的pair</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">无op版本的将以operator&lt;进行比较</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">op用来比较两个元素，op(elem1, elem2)，如果elem1&lt;elem2应返回true</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果存在多个最小值和最大值，min_element和max_element返回找到的第一个目标元素，minmax_element返回第一个最小元素和最后一个最大元素，所以max_element和minmax_element返回的最大元素不是同一个</span></div></li></ul></ul><div><span style="font-size: 10pt; font-family: Georgia;">3.查找元素：</span></div><ul><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal;">查找第一个匹配元素：InputIterator</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">find</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal;">(beg, end, const T&amp; value)/</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">find_if</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal;">(beg, end, op)</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal;">/</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">find_if_not</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal;">(beg, end, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一形式返回[beg, end)中第一个元素值等于value的元素位置，第二形式返回[beg, end)中第一个op(elem)为true的元素；第三形式（始自C++11）返回op(true)为false的元素</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">如果没有找到，返回end</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">op不应该在函数调用过程中改变状态</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">如果是已排序区间，使用已排序区间的算法更有效</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">查询前n个连续匹配值：</span><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">search_n</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, count, const T&amp; value)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">search_n</span>(beg, end, const T&amp; value, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一形式返回[beg, end)中连续count个元素值都等于value的第一个元素位置；第二形式返回[beg, end)中连续count个元素造成op(elem, value)返回为true的第一个元素的位置，如果没有找到返回end</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">注意，op不应在调用过程中改变状态</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">查找第一个子区间：ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">search</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, searchBeg, searchEnd)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">search</span>(beg, end, searchBeg, searchEnd, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两种形式都返回[beg, end)内与[searchBeg, searchEnd)吻合的第一个子区间内的第一元素位置；第一种形式中，子区间内的元素必须完全等于[searchBeg,searchEnd)内的元素；第二种形式中，子区间内的元素和[searchBeg, searchEnd)对应元素必须op(elem, searchElem)为true；如果没有找到，两种形式都返回end</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">查找最后一个子区间：</span><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">find_end</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, searchBeg, searchEnd)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">find_end</span>(beg, end, searchBeg, searchEnd, op)：同上一个的区别是，返回最后一个匹配的子区间的第一元素位置</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">查找某些元素的第一次出现的地点：InputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">find_first_of</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, searchBeg, searchEnd)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">find_first_of</span>(beg, end, searchBeg, searchEnd, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一个形式返回第一个出现于[beg,end)和[searchBeg, searchEnd)的元素的位置；第二形式返回[beg,end)区间中第一个满足以下条件的元素：它和[searchBeg, searchEnd)内的每个元素进行op(elem, searchElem)的结果都是true；没有找到则返回end</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">查找两个连续且相等的元素：ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">adjacent_find</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">adjacent_find</span>(beg, end, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一个形式返回第一对连续两个相等元素中的第一元素位置；第二形式返回[beg, end)内第一对op(elem, nextElem)为true的元素；如果没有找到则返回end</span></div></li></ul></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">4.区间的比较：</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">检验相等性：bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">equal</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, cmpBeg)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">equal</span>(beg, end, cmpBeg, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一形式判断[beg, end)区间的元素是否都和以cmpBeg开头的区间内的元素相等；第二形式判断[beg, end)区间的元素和以cmpBeg开头的区间对应的元素是否能够在调用op(elem, cmpElem)后返回true</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">必须确保以cmpBeg开头的区间包含足够元素</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">测试不定序的相等性(C++11)：bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">is_permutation</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, end1, beg2)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">is_permutation</span>(beg1, end1, beg2, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两种形式都检测[beg1, end1)区间的元素是否和beg2起始之区间元素在顺序无所谓的情况下相等</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一种形式以operator==比较，第二种形式使用predicate op(elem1,elem2)比较，应该在elem1与elem2相等时返回true</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">注意：所有的迭代器必须要有相等的值类型</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">查找第一处不同：pair&lt;InputIterator1, InputIterator2&gt;</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">mismatch</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, cmpBeg)/</span><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">mismatch</span>(beg, end, cmpBeg, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一形式返回[beg, end)区间</span></div></li></ul></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">5.Predicate用以检验区间：始自C++11，用来检验某个给定区间是否符合某条件</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">检验是否排序：bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">is_sorted</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end) / bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">is_sorted</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, op) / ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">is_sorted_until</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end) / </span><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">is_sorted_until</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">is_sorted检验区间内的元素是否已经排序；is_sorted_until返回[beg, end)内第一个破坏排序的元素</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">第一和第三使用operator&lt;比较元素，第二和第四使用op(elem1, elem2),如果elem1小于elem2返回true</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">如果区间为空返回true，如果只有一个元素返回end </span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">检验是否被分割：使用op(elem1, elem2),elem1小于elem2时返回true</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">is_partitioned</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">判断符合op的元素是否被置于所有不符合的元素之前</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">partition_point</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">？</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">如果区间为空，partition_point返回end</span></div></li></ul></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">检验是否形成Heap</span></div></li></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br clear="none"/></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">三.更易型算法</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">：</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">会改动区间的内容，</span></font></div><ul><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">有两种方法可以更易：</span><span style="font-size: 10pt; font-family: Georgia;">写算法要求：原序列必须不小于要求算法写入的元素数目</span></font></div></li><ul><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">运用迭代器遍历序列</span></div></li><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">将元素从源区间复制到目标区间</span></div></li></ul></ul><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">1.复制元素：</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(255, 255, 255); font-size: 10pt; font-family: Georgia;">OutputIterator</span> <span style="background-color: rgb(255, 255, 255); font-size: 10pt; font-family: Georgia; font-weight: bold;">copy</span><span style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">(sourceBeg, sourceEnd, destBeg)：destBeg不能在[sourceBeg, sourceEnd)之间（</span><span style="background-color: rgb(255, 250, 165);font-size: 10pt;-evernote-highlight:true;"><span style="font-size: 10pt; background-color: rgb(255, 250, 165); color: rgb(227, 0, 0); font-family: Georgia; font-weight: bold;-evernote-highlight:true;">常用指数：*****</span></span><span style="background-color: rgb(255, 255, 255); font-size: 10pt; font-family: Georgia;">）</span></span></div></li><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">OutputIterator </span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">copy_if</span><span style="font-size: 10pt; font-family: Georgia;">(sourceBeg, sourceEnd, destBeg, op)：源区间和目标区间不可重叠</span></font></div></li><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">copy_n</span><span style="font-size: 10pt; font-family: Georgia;">(sourceBeg, Size num, destBeg)</span></div></li><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">BidirectionalIterator2</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">copy_backward</span><span style="font-size: 10pt; font-family: Georgia;">(BidirectionalIterator1 sourceBeg, BidirectionalIterator1 sourceEnd, BidirectionalIterator2 destEnd)：destEnd不可处于(sourceBeg, sourceEnd]区间</span></div></li><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">上述四个算法都将源区间[sourceBeg, sourceEnd)中的所有元素复制到以destBeg为起点或以destEnd为终点的目标区间</span></div></li><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">返回目标区间内最后一个被复制元素的下一个位置</span></div></li></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">2.搬移元素：</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">move</span><span style="font-size: 10pt; font-family: Georgia;">(InputIterator sourceBeg, InputIterator sourceEnd, OutputIterator destBeg)</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">BidirectionalIterator2 </span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">move_backward</span><span style="font-size: 10pt; font-family: Georgia;">(</span><span style="font-size: 10pt; font-family: Georgia;">BidirectionalIterator1 </span><span style="font-size: 10pt; font-family: Georgia;">sourceBeg,</span> <span style="font-size: 10pt; font-family: Georgia;">BidirectionalIterator1 </span><span style="font-size: 10pt; font-family: Georgia;">sourceEnd,</span> <span style="font-size: 10pt; font-family: Georgia;">BidirectionalIterator2 </span><span style="font-size: 10pt; font-family: Georgia;">destBeg)</span></div></li></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">3.转换和结合元素：</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-family: Georgia; font-size: 10pt;">OutIter</span> <span style="font-family: Georgia; font-size: 10pt; font-weight: bold;">transform</span><span style="font-family: Georgia; font-size: 10pt;">(InIter beg, InIter end, OutIter destBeg, op)：将源区间的元素转换到目标区间</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-family: Georgia; font-size: 10pt;">OutIter</span> <span style="font-family: Georgia; font-size: 10pt; font-weight: bold;">transform</span><span style="font-family: Georgia; font-size: 10pt;">(InIter beg, InIter end, Initer sourceBeg, InputIter sourceEnd, op)：将两个源序列中的元素合并后写到目标区间</span></div></li></ul><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">四。移除算法</span></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">1.移除某些元素</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">移除序列内的元素</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">函数：</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">remove</span><span style="font-size: 10pt; font-family: Georgia;">(ForwardIterator beg, ForwardIterator end, const T&amp; value)：移除区间内与value相等的元素</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">remove_if</span><span style="font-size: 10pt; font-family: Georgia;">(ForwardIterator beg, ForwardIterator end, op)：移除区间中每个令op(elem)为true的元素</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">返回最后一个未被移除元素的下一位置</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">会把原本置于后面的未移除元素向前移动，覆盖被移除元素</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">无法删除元素，也不会改变元素状态</span></div></li></ul></ul><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font face="Georgia" style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; color: rgb(0, 0, 0); font-style: normal; font-variant: normal; font-weight: bold;">四.排序算法</span><span style="font-size: 10pt; font-family: Georgia; color: rgb(0, 0, 0); font-style: normal; font-variant: normal; font-weight: normal;">：</span></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">1.对所有元素排序：</span></div><ul><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">sort(first, end)/sort(first, end, op)：</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">对区间[first, end)进行排序，第一形式使用operator&lt;排序，第二形式使用op(elem1, elem2)进行排序</span><span style="background-color: initial; font-size: 10pt; font-family: Georgia;">(如果是string,首字母按字典顺序进行排列)</span></font></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="background-color: initial; font-size: 10pt; font-family: Georgia; font-weight: bold;">stable_sort：</span><span style="background-color: initial; font-size: 10pt; font-family: Georgia;">与sort的区别是，能保证相等元素的相对位置不变。</span><span style="font-size: 10pt; font-family: Georgia;">前两个参数接收表示范围的迭代器，第三个参数为可调用表达式表示重新排序的条件</span></font></div></li></ul><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-variant: normal; font-weight: bold;">注意</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-variant: normal;">：以上四个算法需要随即访问迭代器，所以只能用于vector,string,deque和数组，所以不能用于关联容器；list有自己的sort成员函数</span></font></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">2.局部排序</span><span style="font-size: 10pt; font-family: Georgia;">：</span></font></div><ul><li><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: Georgia; font-variant-numeric: normal; font-weight: bold;">partial_sort</span><span style="letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: Georgia;">(first, sort_end, end)/</span><span style="letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: Georgia; font-variant-numeric: normal; font-weight: bold;">partial_sort</span><span style="letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: Georgia;">(first, sort_end, end, op)：第一形式以operator&lt;对[beg, end)区间内的元素进行排序，使[first, sort_end)区间内的元素处于已序状态；第二形式使用二元谓词排序</span></font></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">与sort不同的是partial_sort并不对所有元素排序，一旦[first, sort_end)之间的之间的所有元素都排序好就立马停止；</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果sort_end等于end则对所有序列进行排序</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">partial_sort_copy</span><span style="font-size: 10pt; font-family: Georgia;">(first, end, destfirst, destend)：copy和partion_sort的结合，将元素从源区间[first, end)复制到[destfirst, destend)并进行排序，</span></font></div></li><ul><li><div><span style="font-size: 10pt; font-family: Georgia;">被排序和复制的元素是源和目标两者所含元素量的较小值</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">两者都返回目标区间内最后一个被复制元素的下一个位置</span></div></li><li><div><span style="font-size: 10pt; font-family: Georgia;">如果源区间小于目标区间，所有元素都会被排序</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-variant: normal; font-weight: bold;">partition：</span><span style="letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-variant: normal;">接受两个表示序列的迭代器，第三个参数为谓词，使得谓词为true的排在序列前半部分，谓词为false的排在序列的后半部分，</span><span style="font-size: 10pt; font-family: Georgia;">算法返回一个迭代器，指向最后一个使谓词为true的元素后面的位置</span></font></div></li><li><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-variant: normal;">该算法只需要双向迭代器，因此可以在任何标准序列迭代器上使用partition和stable_partition</span></span></div></li></ul><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">3.根据第n个元素排序</span><span style="font-size: 10pt; font-family: Georgia;">：</span></font></div><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; font-variant-numeric: normal; font-weight: bold;">nth_element(first, biu, end)/</span><span style="font-size: 10pt; font-family: Georgia; font-variant-numeric: normal; font-weight: bold;">nth_element(first, biu, end, func):</span><span style="font-size: 10pt; font-family: Georgia;">排序后，第biu位置前的元素小于biu位置的元素，第biu位置后的元素大于biu位置的元素</span></font></div></li></ul></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">5.partition：</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">接受两个表示序列的迭代器，第三个参数为谓词，使得谓词为true的排在序列前半部分，谓词为false的排在序列的后半部分</span></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">算法返回一个迭代器，指向最后一个使谓词为true的元素后面的位置</span></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">该算法只需要双向迭代器，因此可以在任何标准序列迭代器上使用partition和stable_partition</span></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="background-color: inherit; font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">6.stable_partition</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">: partition的重载，用法类似stable_sort</span></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">7.堆算法</span><span style="font-size: 10pt; font-family: Georgia;">：</span></font></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">函数：</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;"><b>make_heap</b>：将某个区间转换成一个heap</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;"><b>push_heap</b>(beg, end)/push_heap(beg, end, op&gt;：将end元素之前的最后一个元素加入原本就是heap的[beg, end-1)区间内，使整个[beg, end)区间成为一个heap；</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">调用者必须保证进入函数时，[beg, end-1)区间内的元素原本便已经形成一个heap，而新元素紧跟其后</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">复杂度：对数，至少执行log(numElems次比较</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;"><b>pop_heap</b>(beg, end)/pop_heap(beg, end, op)：</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两种形式从heap[beg, end)内的最高元素移动到最后位置，并将剩余区间[beg, end-1)内的元素组织起来，成为一个新的heap</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">op(elem1, elem2)：排序准则，可有可无</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">调用者必须保证进入函数时[beg, end)区间内的元素原本已经形成一个heap</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">复杂度：</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;"><b>sort_heap</b>：对heap进行排序，完成后就不再是一个heap了</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">可以传递一个函数作为排序准则，默认的排序准则是operator&lt;</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">is_heap：检验区间内的元素是否排序成为一个堆</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">is_heap_until：返回区间内第一个破坏heap排序状态的元素</span></div></li></ul><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">五.已排序区间算法：以下算法适用前提是源区间必须在某个排序准则的作用下已经排好序</span></div><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">1.查找元素</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;"><span style="font-size: 10pt; font-family: Georgia;">bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">binary_search</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value) / </span></span><span style="font-size: 10pt; font-family: Georgia;">bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">binary_search</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">调用者必须保证，进入算法之际，工作区间已经排序</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">op(elem1, elem2)</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两种形式都判断区间[beg, end)是否包含&quot;和value等值&quot;的元素</span></div></li></ul></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">2.检查数个元素是否存在</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">includes</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, searchBeg, searchEnd)/bool</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">includes</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, searchBeg, searchEnd, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两种形式都用来判断已排序区间[beg, end)是否包含另一个已排序区间[searchBeg, searchEnd)的全部元素</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">op(elem1, elem2)</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">调用者必须确保，在进入算法之际两个区间都已经根据同一个准则排好序了</span></div></li></ul></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">3.查找第一个或最后一个可能位置</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">lower_bound</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value)/ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">lower_bound</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value, op)</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">upper_bound</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value)/ForwardIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">upper_bound</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">返回第一个大于等于value的元素位置，这是可插入元素值为value且不破坏区间[beg, end)已排序性的第一个位置</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">返回第一个大于value的元素，这是可插入元素值为value且不破坏区间[beg, end)已排序性的最后一个位置</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">如果不存在值为value的元素，都返回end</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">若要同时获得lower_bound和upper_bound的结果，使用equal_range()</span></div></li></ul></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">4.查找第一个和最后一个可能位置</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia;">pair&lt;ForwardIterator, ForwardIterator&gt;</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">equal_range</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value)/pair&lt;ForwardIterator, ForwardIterator&gt;</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">equal_range</span><span style="font-size: 10pt; font-family: Georgia;">(beg, end, const T&amp; value, op)</span></font></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两种形式都返回与value相等的元素所形成的区间pair(返回区间为[beg, end))，在此区间内插入值为value的元素并不会破坏[beg, end)区间的已排序性</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">等效于：make_pair(lower_bound(...), upper_bound(...))</span></div></li></ul></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">5.合并元素</span></div><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两个已排序集合的总和</span></div><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">merge</span><span style="font-size: 10pt; font-family: Georgia;">(Beg, End, Beg2, End2, destBeg)/OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">merge</span><span style="font-size: 10pt; font-family: Georgia;">(Beg, End, Beg2, End2, destBeg, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">将两个源区间【beg，end)合并，使以destBeg起始之目标区间内含两个源区间的所有元素</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">目标区间的元素都处于排序状态下</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">返回目标区间内最后一个被复制元素的下一个位置</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">源区间不会有任何变化</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">list和forward_list都提供一个特殊的成员函数merge来合并两个list</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">如果要确保两个源区间中出现的元素在目标区间中只出现一次，使用set_union</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">如果只想获得同时存在于两个源区间内的元素，使用set_intersection</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两个已排序集合的并集：OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_union</span><span style="font-size: 10pt; font-family: Georgia;">(beg1,end1, beg2,end2,destBeg)/OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_union</span><span style="font-size: 10pt; font-family: Georgia;">(beg1,end1, beg2,end2,destBeg, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两者都是将区间[beg1,end1)和[beg2, end2)内的元素合并，得到以destBeg起始的目标区间，后者内含的元素要么来自第一个区间，要么来自第二个区间，或者同时来自两者</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">同时出现于两个源区间内的元素在并集区间中将只出现一次，但是如果原来的某个源区间内本身就存在重复的元素则目标区间也会存在重复元素</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">返回最后一个被复制元素的下一位置</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">目标区间内的元素都处于排序状态</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">必须要保证目标区间有足够的空间，否则就要使用insert iterator</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">源区间和目标区间两者不可重叠</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两个已排序集合的交集：OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_intersection</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, end1, beg2, end2, destbeg)/</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_intersection</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, end1, beg2, end2, destbeg, op)</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">两个已排序集合的差集：</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_difference</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, end1, beg2, beg2, destbeg)/</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_difference</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, end1, beg2, beg2, destbeg, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">目标区间的元素只存在于第一区间，不存在于第二区间</span></div></li><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">返回最后一个被合并元素的下一个位置</span></div></li></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_symmetric_difference</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, end1, beg2, beg2, destbeg)/OutputIterator</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">set_symmetric_difference</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, end1, beg2, beg2, destbeg, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">目标区间内含的元素或存在于第一源区间，或存在于第二源区间，不同时存在于两个区间内</span></div></li></ul></ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">合并连贯之已排序区间：void</span> <span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">inplace_merge</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, beg2, end2)/</span><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">inplace_merge</span><span style="font-size: 10pt; font-family: Georgia;">(beg1, beg2, end2, op)</span></div></li><ul><li><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: Georgia;">将已排序源区间[beg1, beg2), [beg2, end2)合并，使区间[beg1, end2)成为两者之和</span></div></li></ul></ul><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Georgia; font-weight: bold;">数值算法</span><span style="font-size: 10pt; font-family: Georgia;">：#include&lt;numeric&gt;</span></font></div><div style="background-color: rgb(255, 255, 255); letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: bold;">std::max</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia; font-style: normal; font-variant: normal; font-weight: normal;">(const T&amp;a, const T&amp; b)：返回较大的数</span></font></div><div><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;">void <b>generate</b>(ForwardIterator beg, ForwardIterator end, Func op): 调用op产生新值，并将它赋值给区间（beg, end）的所有元素</span></div><ul><li><div><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;">注意是每次给区间中的一个元素赋值时会调用一次op，所以调用的次数和区间中的元素个数相同</span></div></li><li><div><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;">区间是（beg，end），即第二个和倒数第二个（目前测试是这样，见C++标准库10.1.2）</span></div></li></ul><div><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;"><b>generator_n</b>(OutputIterator beg, Size num, Func op)：调用op产生新值，并将它赋值给以beg起始的区间内的前num个元素，如果num为负值不做任何事，返回最后被该动的元素的下一位置，注意是每次给区间中的一个元素赋值时会调用一次op，所以调用的次数和区间中的元素个数相同</span></div><div><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;"><b>accumulate</b>(InputIterator beg, InputIterator end, T initValue)/</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;">accumulate(InputIterator beg, InputIterator end, T initValue, op)</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;">：结合所有元素（求和，求乘积）</span></div><ul><li><div><span style="font-family: Georgia;">第一形式：</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;">计算initValue</span><span style="font-family: Georgia;">对区间[beg, end)内的每个元素的总和，具体：initValue=initValue+elem</span></div></li><li><div><span style="font-family: Georgia;"><br/></span></div></li></ul><div><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Georgia;"><br/></span></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><div style="letter-spacing: normal; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><br/></font></div></div><div><font style="font-size: 10pt;"><br clear="none"/></font></div></div><div><br/></div></span>
</div></body></html> 