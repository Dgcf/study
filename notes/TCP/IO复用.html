<html>
<head>
  <title>IO复用</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="730"/>
<h1>IO复用</h1>

<div>
<span><div><div><span style="font-size: 12pt; font-weight: bold;">描述符就绪的条件：</span></div><div><span style="font-size: 10pt;">读就绪：</span></div><div><span style="font-size: 10pt;">写就绪：</span></div><div><span style="font-size: 12pt; font-weight: bold;">select</span></div><div>int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptedset, struct timeval *timeout):</div><ul><li><div>用于测试文件描述符集合中是否有一个文件描述符已处于<span style="color: rgb(255, 0, 0);">可读状态</span>、<span style="color: rgb(255, 0, 0);">可写状态</span>、<span style="color: rgb(255, 0, 0);">错误状态或经历一段指定的时间后才唤醒它</span>，它将阻塞以等待某个文件描述符进入这三个状态。将在这三个集合中有可读/可写/有错误时返回。</div></li><li><div>调用方法和顺序：设置文件描述符-&gt;指定监视范围-&gt;设置超时—&gt;调用select函数—&gt;查看调用结果</div></li><ul><li><div>设置文件描述符：对数据结构fd_set进行操作，fd_set是由打开的文件描述符构成的集合</div></li><li><div>指定监视范围：通过第一个参数监视对象文件描述符的数量</div></li><li><div>超时时间与最后一个参数有关</div></li></ul><li><div>参数：</div></li><ul><li><div>maxfd：监视对象文件描述符数量，一般是所监视的文件描述符个数+1，描述符0，1，2...直到maxfd-1均将被测试，+1的原因是指定描述符个数而非最大值，而描述符是从0开始的<span style="color: rgb(227, 0, 0); font-weight: bold;">（描述符是从0开始依次递增的吗？）</span></div></li><li><div>readset:将所有关注 是否存在可读取数据 的文件描述符注册到fd_set型变量，并传递其地址值</div></li><li><div>writeset:将所有关注 是否可传输无阻塞数据 的文件描述符注册到fd_set变量</div></li><li><div>exceptedset：将所有关注 是否发生异常 的文件描述符注册到fd_set变量，并传递其地址</div></li><li><div>timeout：</div></li><ul><li><div>永远等下去：设置为空指针，仅在有一个描述符准备好IO后返回调用select之后为防止陷入无限阻塞状态，传递超时time-out信息</div></li><li><div>等待一段固定时间：不超过指定的时间</div></li><li><div>根本不等待：检查描述符后立即返回，称为轮询，结构体中的值都为0</div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include&lt;sys/types.h&gt;</div><div>#include&lt;sys/time.h&gt;</div><div>void FD_ZERO(fd_set *fdset)；         //将fd_set初始化为空集合</div><div>void FD_CLR(int fd, fd_set *fdset);   //清除由参数fd传递的文件描述符</div><div>void FD_SET(int fd, fd_set *fdset);   //设置由参数fd传递的文件描述符</div><div>int FD_ISSET(int fd, fd_set *fdset);  //判断fd指向的文件描述符是否是由fdset指向的fd_set中的一个元素，如果是则返回非零值，用于验证select的调用结果</div></div><ul><li><div>返回值：返回状态发生变化的描述符总数，失败时返回-1并设置errno，FD_ISSET来测试fd_set数据类型中的描述符，描述符集内任何与未就绪描述符对应的位返回时均清成0，所以每次调用select函数时都得再次把所有描述符集内所关心的位置为1</div></li><li><div>select的缺陷：</div></li><ul><li><div>调用select后针对所有文件描述符的循环语句</div></li><li><div>每次调用select函数时需要向该函数传递监视对象信息，是传递给操作系统的，对性能造成很大的影响</div></li></ul><li><div>适用select的场合：</div></li><ul><li><div>服务器端接入者少</div></li><li><div>程序具有兼容性</div></li></ul></ul><div>所以，仅向操作系统传递1次监视对象，监视范围或内容发生变化时只通知发生变化的事项，linux支持epoll，windows支持IOCP</div><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">poll</span></div><ul><li><div>#include &lt;poll.h&gt; int poll(struct pollfd* fdarray, unsigned long nfds, int timeout)</div></li><ul><li><div>参数：</div></li><ul><li><div>struct pollfd：使用这个结构来监控一组文件描述符，测试条件由events指定，由revents返回结果，避免 值-结果 参数</div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct pollfd{</div><div>    int fd;           // 文件描述符</div><div>    short events;     // 要求查询的事件掩码</div><div>    short revents;    // 返回的事件掩码</div><div>}</div></div><div><img src="IO复用_files/Image.png" type="image/png" data-filename="Image.png" width="680"/></div><ul><ul><ul><li><div>nfds：要监控的文件描述符的数量</div></li><li><div>timeout：超时毫秒数，负数表示无限等待；为0表示立即返回</div></li></ul><li><div>返回：若有就绪描述符则为其数目，若超时则为0（超时前没有任何事件发生），若出错则为-1</div></li><li><div>poll识别三类数据：</div></li></ul></ul><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">epoll</span>：</div><div>select中为了保存监视对象文件描述符，直接声明了fd_set变量，但epoll方式下由操作系统负责保存监视对象文件描述符，因此需要向操作系统请求创建保存文件描述符的空间，此时使用的是epoll_create;为了添加和删除监视对象文件描述符，select需要FD_SET等函数，epoll中通过epoll_ctl完成；select中使用select等待文件描述符的变化，而eopll中调用epoll_wait函数；select中通过fd_set查看监视对象的状态变化，而epoll下通过epoll_event将发生变化的文件描述符单独集中到一起</div><ul><li><div>优点：</div></li><ul><li><div>无需编写以监视状态变化为目的的针对所有文件描述符的循环语句</div></li><li><div>调用对应于select函数的epoll_wait函数时无需每次传递监视对象信息</div></li></ul><li><div>epoll函数 #include&lt;sys/epoll.h&gt;：</div></li><ul><li><div>int epoll_create(int size):创建保存epoll文件描述符的空间；size：epoll实例的大小；返回值：成功返回epoll的文件描述符，失败返回-1；这个函数相当于select的fd_set变量</div></li><li><div>int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event):向空间注册或注销文件描述符;select中需要FD_SET等函数，epoll中为该函数</div></li><ul><li><div>参数：</div></li><ul><li><div>epfd:用于注册监视对象的epoll例程的文件描述符</div></li><li><div>op：用于指定监视对象的添加，删除或更改措施，可以取以下值</div></li><ul><li><div>EPOLL_CTL_ADD:将文件描述符注册到epoll</div></li><li><div>EPOLL_CTL_DEL:从epoll中删除文件描述符，这时候第四个参数应为NULL</div></li><li><div>EPOLL_CTL_MOD:更改</div></li></ul><li><div>fd：需要注册的监视对象的文件描述符</div></li><li><div>event：监视对象的事件类型</div></li></ul><li><div>返回值：成功返回0，失败返回-1</div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct <span style="font-weight: bold;">epoll_event</span>{</div><div>__uint32_t events;</div><div>epoll_data_t data;//</div><div>}</div><div>其中，events取值：</div><div>* EPOLLIN：表示对应的文件描述符可以读，包括对端socket的正常关闭</div><div>* EPOLLOUT：输出缓冲为空，表示对应的文件描述符可以写</div><div>* EPOLLPRI：表示对应的文件描述符有紧急数据可读</div><div>* EPOLLHUP：表示对应的文件描述符被关闭</div><div>* EPOLLRDHUP：断开连接或半关闭的情况</div><div>* EPOLLERR：表示对应的文件描述符发生错误的情况</div><div>* EPOLLLET：将对应的文件描述符设置为以边缘触发的方式</div><div>* EPOLLONESHOT：只监听一次，发生一次事件通知后，相应文件描述符不再接收到事件通知。因此需要向epoll_ctl函数的第二个参数传递EPOLL_CTL_MOD,再次设置事件</div><div>typedef union epoll_data_t{</div><div>    void* ptr;</div><div>    int fd;</div><div>    __uint32_t u32;</div><div>    __uint64_t u64;</div><div>}</div></div><ul><ul><ul><li><div>可以通过位或运算同时传递多个上述参数</div></li></ul><li><div>int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout):等待文件描述符发生变化；相当于select模式中的select</div></li><ul><li><div>参数：</div></li><ul><li><div>maxevents：第二个参数中可以保存的最大事件数</div></li><li><div>1/1000s为单位的等待时间，传递-1为一直等待直到发生事件</div></li></ul><li><div>返回值：成功时返回发生事件的文件描述符个数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合；失败返回-1</div></li></ul></ul><li><div>条件触发和边缘触发：区别在与发生事件的时间点</div></li><ul><li><div>条件/水平触发：只要输出缓存中有数据就会一直通知该事件，每当收到数据都会注册该事件，并因此多次调用epoll_wait函数。epoll默认以条件触发方式工作</div></li><li><div>边缘触发：输入缓存中收到数据时仅注册一次该事件</div></li></ul></ul><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">IO复用优缺点分析</span>：</div><ul><li><div>select缺点：</div></li><ul><li><div>最大并发数限制：只能监听1024个fd</div></li><li><div>效率低，每次都会线性扫描整个fd_set,集合越大速度越慢</div></li><li><div>内核/用户空间内存拷贝问题</div></li></ul><li><div>epoll的提升：</div></li><ul><li><div>本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制</div></li><li><div>效率提升：只有活跃的socket才会主动调用</div></li><li><div>省去不必要的内存空间：epoll是共享内存</div></li></ul></ul></div><div><br/></div></span>
</div></body></html> 