<html>
<head>
  <title>套接字</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604043 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="692"/>
<h1>套接字</h1>

<div>
<span><div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">字节排序函数：</span></span></div><ul><li><div><span style="font-size: 10pt;">存储字节的方式：网络字节序统一为大端序</span></div></li><ul><li><div><span style="font-size: 10pt;">大端序：先保存最高位字节，高位字节放到低位地址</span></div></li><li><div><span style="font-size: 10pt;">小端序：高位字节放到高位地址</span></div></li></ul></ul><div><span style="font-size: 11pt; font-weight: bold;">TCP</span></div><div><span style="font-size: 10pt;">调用流程:</span></div><ul><li><div>服务端：创建套接字socket-&gt;分配套接字地址bind-&gt;等待连接请求状态listen-&gt;允许连接accept-&gt;数据交换write/read-&gt;断开连接close</div></li><li><div>客户端：socket-&gt;connect</div></li></ul><div>其他：</div><ul><li><div>AF_前缀表示地址族，PF_前缀表示协议族</div></li></ul><div>套接字：</div><div>int <span style="font-weight: bold;">socket</span>(int domain, int type, int protocol);</div><ul><li><div>参数：</div></li><ul><li><div>domain：协议族信息，常用的为PF_INET(IPv4)</div></li><li><div>type：套接字类型：</div></li><ul><li><div>SOCK_STREAM：可靠，按序传递的，基于字节的面向连接的套接字</div></li><ul><li><div>传输过程中数据不会消失</div></li><li><div>按序传输数据</div></li><li><div>传输的数据不存在边界—发送数据的套接字内部有缓冲，简言之就是字节数组，通过套接字传输的数据将保存到该数组中，因此收到数据并不意味着马上调用read函数。如果接收缓冲满了之后传输端会停止传输</div></li></ul><li><div>SOCK_DGRAM：不可靠，不按序传递，以数据的高速传递为目的的套接字</div></li><ul><li><div>传输的数据有边界</div></li><li><div>限制每次传输的数据大小</div></li></ul></ul><li><div>protocol：</div></li></ul><li><div>返回值：成功时返回文件描述符，失败时返回-1</div></li></ul><div>int <span style="font-weight: bold;">bind</span>(int sockfd, struct sockaddr* myaddr, socklen_t addrlen);</div><ul><li><div>参数：</div></li><ul><li><div>sockaddr：sockaddr_in （<span style="color: rgb(50, 135, 18); font-style: italic;">#include&lt;netinet/in.h&gt;</span>）转换而来，</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct sockaddr_in{</div><div>    sa_family_t     sin_family; //取值：AF_INET ipv4；AF_INET6 ipv6 AF_LOCAL其他</div><div>    uint16          sin_port;   //该成员保存16位端口号，重点在于以网络字节序保存 </div><div>    struct in_addr  sin_addr;   //保存32位IP地址信息，以网络字节序保存，服务端IP地址指定为INADDR_ANY，服务器有多个网络接口，服务器进程就可以在                                   //任意网络接口上接受客户连接</div><div>    char            sin_zero[8];//预留</div><div>}</div></div><div>sin_addr需要使用转换函数：</div><div>   <span style="color: rgb(50, 135, 18); font-style: italic;"> #include &lt;arpa/inet.h&gt;</span></div><div>    in_addr_t inet_addr(const char* str)：将字符串形式的IP地址转换成32位整数，并在转换类型的同时进行网络字节序的转换，失败返回INADDR_NONE</div><ul><li><div>返回值：成功时返回0，失败时返回-1</div></li><li><div>注意：</div></li><ul><li><div>对于IPv4来说，通配地址由常值INADDR_ANY指定，值一般为0，它告知内核去选择IP地址。无论是网络还是主机字节序INADDR_ANY值都是一样的，因此使用htonl并非必需要，但是都是按主机字节序定义的，所以最好使用</div></li><li><div>如果需要得到bind选择的临时端口值，必须调用函数getsockname来返回协议地址</div></li></ul></ul><div>int <span style="font-weight: bold;">listen</span>(int sock, int backlog):</div><ul><li><div>参数</div></li><ul><li><div>sock：socket返回值</div></li><li><div>backlog：连接请求等待队列的最大长度。为了理解这个参数，必须认识到内核为任何一个给定的监听套接字维护两个队列：</div></li><ul><li><div>未完成连接队列：每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，服务器正在等待相应的三次握手。这些套接字处于SYN_RCVD状态</div></li><li><div>已完成连接队列：这些套接字处于ESTABLISHED状态</div></li><li><div>该参数是这两个队列的和</div></li><li><div>当客户SYN到达时，TCP在未完成队列中创建一个新项，然后到第二次握手，即服务器相应SYN，其中捎带对客户端SYN的ACK，这一项一直保留在未完成连接队列中，直到第三次握手到达或者超时为止。三次握手正常完成时，该项就从未完成队列转移到已完成队列的尾部</div></li><li><div>如果客户的一个SYN到达后未完成对列是满的，TCP就暂时忽略而不是发送RST，因为客户将会重新发送SYN</div></li></ul></ul><li><div>返回值：失败时返回-1，成功时返回0</div></li><li><div>注意：</div></li><ul><li><div>调用listen将导致套接字从CLOSED状态转换到LISTEN状态</div></li></ul><li><div>其他：</div></li><ul><li><div><br/></div></li><li><div>如果</div></li></ul></ul><div><img src="套接字_files/Image.png" type="image/png" data-filename="Image.png" width="606"/></div><div>int <span style="font-weight: bold;">accept</span>(int sock, struct sockaddr* addr, socklen_t* addrlen); 服务端调用</div><ul><li><div>参数：</div></li><ul><li><div>sock：服务器套接字的文件描述符</div></li><li><div>addr：保存发起连接请求的客户端地址信息的变量地址值</div></li><li><div>addrlen：第二个参数长度的地址</div></li></ul><li><div>返回值：</div></li><ul><li><div>成功时返回一个由内核自动生成的全新描述符，代表与客户TCP的连接，失败时返回-1</div></li></ul><li><div>注意：</div></li><ul><li><div>TCP的三次握手是在这里发生的，握手完毕时accept返回</div></li><li><div>从已完成连接队列队头返回下一个已完成连接，如果已完成连接为空，进程投入睡眠</div></li></ul></ul><div>int <span style="font-weight: bold;">connect</span>(int sock, struct sockaddr* servaddr, socklen_t addrlen); </div><ul><li><div>参数：</div></li><ul><li><div>sock：文件描述符</div></li><li><div>servaddr：地址结构体</div></li><li><div>addrlen：</div></li></ul><li><div>返回值：成功时返回0，失败时返回-1</div></li><li><div>服务端响应：</div></li><ul><li><div>如果没有收到SYN，则返回ETIMEDOUT</div></li><li><div>若对客户的SYN响应是RST(表示复位)，则表明服务器在指定的端口上没有进程与之连接</div></li></ul><li><div>状态变化：</div></li><ul><li><div>connect将导致当前套接字从CLOSED状态转移到SYN_SENT状态，若成功再转移到ESTABLISHED状态，若connect失败则该套接字不再可用，必须关闭</div></li></ul><li><div>注意：</div></li><ul><li><div>客户在调用connect前不必非得调用bind函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。</div></li><li><div>调用connect将激发三次握手</div></li></ul></ul><div><span style="font-weight: bold;">断开连接</span>：linux的<span style="font-weight: bold;">close</span>函数和windowsd的<span style="font-weight: bold;">closesocket</span>函数意味着完全断开，不仅无法传输数据，而且也不能接收数据</div><div><span style="font-weight: bold;">半关闭</span>：#include&lt;sys/socket.h&gt;</div><div>int <span style="font-weight: bold;">shutdown</span>(int sock, int howto):即发送了EOF，同时又保留了输入流</div><ul><li><div>参数：</div></li><ul><li><div>sock：文件描述符；</div></li><li><div>howto：传递断开方式的信息，该函数的行为依赖于这个参数</div></li><ul><li><div>SHUT_RD:关闭连接的读这一半——断开输入流，即使输入缓冲中收到数据也会抹去，进程不能再对该套接字调用任何读函数</div></li><li><div>SHUT_WR:关闭连接的写这一半——断开输出流，但是输出缓冲中还留有未传输数据，则将传递至目标主机</div></li><li><div>SHUT_RDWR:同时断开IO流</div></li></ul></ul><li><div>返回值：成功时返回0，失败时返回-1</div></li><li><div>使用shutdown代替close的原因：</div></li><ul><li><div>close把描述符的引用计数减1，仅在该计数变为0时菜关闭套接字，shutdown不管引用计数就激发TCP的正常连接终止</div></li><li><div>close终止读写两个方向的数据传递</div></li></ul></ul><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">常用IO接口</span>：</div><div>1. read&amp;write：#include&lt;unistd.h&gt;</div><div>ssize_t read(int fd, void* buf, size_t nbytes);</div><ul><li><div>参数：</div></li><ul><li><div>fd：接受数据对象的文件描述符</div></li><li><div>buf：要保存接收数据的缓冲地址</div></li><li><div>nbytes:要接收数据的最大字节数</div></li></ul><li><div>返回值：成功时返回接收的字节数，失败时返回-1</div></li></ul><div>ssize_t write(int fd, const void*buf, size_t nbytes)</div><ul><li><div>参数：</div></li><ul><li><div>fd：文件描述符</div></li><li><div>buf：保存要传输数据的缓冲地址值</div></li><li><div>nbytes：要传输数据的字节数</div></li></ul><li><div>返回值：成功时返回写入的字节数，失败时返回-1</div></li><li><div>注意：write和windows的send函数并不会在完成向对方主机的数据传输时返回，而是在数据移动到输出缓冲时。但tcp会保证输出缓冲数据的传输，所以说write函数在数据传输完成时返回</div></li></ul><div>2。recv&amp;send： #include &lt;sys/socket.h&gt;</div><div>ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags)</div><ul><li><div>参数：</div></li><ul><li><div>sockfd：表示与数据传输对象的连接的套接字文件描述符</div></li><li><div>buf：待传输buf</div></li><li><div>nbytes：待传输的字节数</div></li><li><div>flags：传输数据时指定的可选项信息</div></li><ul><li><div>MSG_DONTROUTE：绕过路由表查询</div></li><li><div>MSG_DONTWAIT：仅本操作非阻塞</div></li><li><div>MSG_OOB：发送或接收带外数据</div></li><li><div>MSG_PEEK：窥看外来消息</div></li><li><div>MSG_WAITALL：等待所有数据</div></li></ul></ul><li><div>返回值：成功时返回发送的字节数，失败时返回-1</div></li></ul><div>ssize_t recv(int sockfd, void* buf, size_t nbytes, int flags)</div><ul><li><div>参数：</div></li><ul><li><div>sockfd：套接字描述符</div></li><li><div>buf：接收数据的缓冲地址</div></li><li><div>nbytes：可接收的最大字节数</div></li><li><div>flags：接收数据时指定的可选项信息</div></li></ul></ul><div>3.recvfrom&amp;sendto</div><div>4。readv &amp; writev：#include &lt;sys/uio.h&gt; 对数据进行整合传输及发送的函数，有助于提高数据通信效率，也就是说，可以将分散保存在多个缓存中的数据一并发送，通过readv函数可以由多个缓冲分别接收（也称为分散读，集中写）；</div><div>ssize_t writev(int filedes, const struct iovec* iov, int iovcnt)，</div><ul><li><div>参数：</div></li><ul><li><div>filedes：文件描述符，不限于套接字</div></li><li><div>iov：iovec结构体的地址，包含发送数据的位置和大小信息</div></li><li><div>iovcnt：上一个参数的数组长度</div></li></ul><li><div>返回值：成功时返回发送的字节数，失败时返回-1</div></li><li><div>注：writev是一个原子操作，</div></li></ul><div>ssize_t readv(int filedes, const struct iovec* iov, int iovcnt)</div><ul><li><div>参数：</div></li><ul><li><div>filedes：传递接收数据的文件描述符</div></li><li><div>iov：包含数据保存位置和大小信息的iovec结构体数组的地址值</div></li><li><div>iovcnt：第二个参数的数组大小</div></li></ul><li><div>返回值：成功返回读到的总字节数，遇到文件结尾，无数据可读返回0；<span style="color: rgb(173, 0, 0); font-weight: bold;">返回0是否意味着关闭？</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct iovec {</div><div>    ptr_t iov_base; /* Starting address */指向一个缓冲区，这个缓冲区是用来存放readv接受或writev发送的数据</div><div>    size_t iov_len; /* Length in bytes */接受的最大长度或写入的实际长度</div><div>};</div></div><div><br/></div><div>向量IO：readv/writev，是一种在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可把单个数据流读到多个缓冲区；</div><div>线性IO：标准读写系统调用read/write，称为线性IO</div><div>优势：</div><ul><li><div>效率更高：单个向量IO操作可以取代多个线性IO操作</div></li><li><div>性能更好：减少了发起的系统调用，</div></li><li><div>支持原子操作</div></li></ul><div>5.recvmsg&amp;sendmsg：#include&lt;sys/socket.h&gt;</div><div>ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags)</div><div>ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags) </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct msghdr{</div><div>    void *msg_name;</div><div>    socklen_t msg_namelen;</div><div>    struct iovec *msg_iov;</div><div>    int    msg_iovlen;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        void*     msg_control;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    socklen_t msg_controllen;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    int    msg_flags;</span></div><div>}</div></div><div>6。标准I/O：</div><ul><li><div>两个优点：</div></li><ul><li><div>具有良好的可移植性</div></li><li><div>可以利用缓冲提高性能</div></li></ul></ul><div>    使用标准IO函数：#include&lt;stdio.h&gt;</div><div>    FILE* fdopen(int fields, const char* mode); 可以通过该函数将创建套接字时返回的文件描述符转换为标准IO函数中使用的FILE结构体指针</div><ul><li><div>参数：</div></li><ul><li><div>fildes：需要转换的文件描述符</div></li><li><div>mode：将要创建的FILE结构体指针的模式信息，常用的有“r”和“w”</div></li></ul><li><div>返回：成功时返回转换的FILE结构体指针，失败返回NULL</div></li></ul><div>    int fileno(FILE* stream)：与fdopen函数相反</div><ul><li><div>参数：向函数传递FILE指针返回相应的文件描述符</div></li><li><div>返回值：成功时返回转换后的文件描述符，失败时返回-1</div></li></ul><div><br clear="none"/></div><div>int close(int fd)：#include&lt;unistd.h&gt; fd为文件描述符，成功时返回0，失败时返回-1</div><div>原理：write函数调用后并非立即传输数据，read函数调用后也并非立即接收数据</div><div>IO缓冲特性如下：</div><ul><li><div>IO缓冲在每个TCP套接字中单独存在</div></li><li><div>IO缓冲在创建套接字时自动生成</div></li><li><div>即使关闭套接字也会继续传递输出缓冲中遗留的数据</div></li><li><div>关闭套接字将丢失输入缓冲中的数据</div></li></ul><div><br clear="none"/></div><div>5.fork和exec函数</div><ul><li><div>fork：#include&lt;unistd.h&gt; pid_t fork(void)</div></li><ul><li><div>返回值：返回值本身告知当前进程是子进程还是父进程</div></li><ul><li><div>在调用进程中返回一次，返回值为子进程的进程ID</div></li><li><div>在子进程中返回一次，返回值为0</div></li></ul><li><div>两个典型用法：</div></li><ul><li><div>一个进程创建一个副本</div></li><li><div>一个进程想要执行另一个进程。具体通过fork创建子进程，然后在子进程总调用exec把自身替换成新进程</div></li></ul></ul><li><div>exec：把调用exec的进程称为调用进程</div></li></ul><div><br/></div><div>6.getsockname和getpeername：</div><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">套接字选项</span>：#include&lt;sys/socket.h&gt;</div><div>getsockopt(int sockfd, int level, int optname, void* optval, socklen_t* optlen);</div><div>setsockopt(int sockfd, int level, int optname, const void* optval, socklen_t optlen)</div></div><div><br/></div></span>
</div></body></html> 